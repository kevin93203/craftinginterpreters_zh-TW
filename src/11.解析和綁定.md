# 11. Resolving and Binding 解析和綁定

> Once in a while you find yourself in an odd situation. You get into it by degrees and in the most natural way but, when you are right in the midst of it, you are suddenly astonished and ask yourself how in the world it all came about.
>
> ​																																				——  Thor Heyerdahl, *Kon-Tiki*

你也許偶爾會發現自己處於一種奇怪的情況。你曾以最自然的方式逐漸進入其中，但當你身處其中時，你會突然感到驚訝，並問自己這一切到底是怎麼發生的。

> Oh, no! Our language implementation is taking on water! Way back when we [added variables and blocks](http://craftinginterpreters.com/statements-and-state.html), we had scoping nice and tight. But when we [later added closures](http://craftinginterpreters.com/functions.html), a hole opened in our formerly waterproof interpreter. Most real programs are unlikely to slip through this hole, but as language implementers, we take a sacred vow to care about correctness even in the deepest, dampest corners of the semantics.

哦，不! 我們的語言實現正在進水! 在我們剛添加變量和代碼塊時，我們把作用域控制的很好很嚴密。但是當我們後來添加閉包之後，我們以前防水的解釋器上就出現了一個洞。大多數真正的程序都不可能從這個洞裏溜走，但是作為語言實現者，我們要立下神聖的誓言，即使在語義的最深處、最潮濕的角落裏也要關心正確性。【譯者注：這一段好中二，其實原文中有很多地方都有類似的中二之魂燃燒瞬間】

> We will spend this entire chapter exploring that leak, and then carefully patching it up. In the process, we will gain a more rigorous understanding of lexical scoping as used by Lox and other languages in the C tradition. We’ll also get a chance to learn about *semantic analysis*—a powerful technique for extracting meaning from the user’s source code without having to run it.

我們將用整整一章的時間來探索這個漏洞，然後小心翼翼地把它補上。在這個過程中，我們將對Lox和其他C語言傳統中使用的詞法範圍有一個更嚴格的理解。我們還將有機會學習語義分析——這是一種強大的技術，用於從用户的源代碼中提取語義而無需運行它。

> ## 11 . 1 Static Scope

## 11.1 靜態作用域

> A quick refresher: Lox, like most modern languages, uses *lexical* scoping. This means that you can figure out which declaration a variable name refers to just by reading the text of the program. For example:

快速複習一下：Lox和大多數現代語言一樣，使用詞法作用域。這意味着你可以通過閲讀代碼文本找到變量名字指向的是哪個聲明。例如：

```java
var a = "outer";
{
  var a = "inner";
  print a;
}
```

> Here, we know that the `a` being printed is the variable declared on the previous line, and not the global one. Running the program doesn’t—*can’t*—affect this. The scope rules are part of the *static* semantics of the language, which is why they’re also called *static scope*.

這裏，我們知道打印的`a`是上一行聲明的變量，而不是全局變量。運行代碼並不會（也不能）影響這一點。作用域規則是語言的靜態語義的一部分，這也就是為什麼它們被稱為靜態作用域。

> I haven’t spelled out those scope rules, but now is the time for precision:

我還沒有詳細説明這些作用域規則，但是現在是時候詳細説明一下了[^1]：

> **A variable usage refers to the preceding declaration with the same name in the innermost scope that encloses the expression where the variable is used.**

**變量指向的是使用變量的表達式外圍環境中，前面具有相同名稱的最內層作用域中的變量聲明。**

> There’s a lot to unpack in that:

其中有很多東西需要解讀：

- > I say “variable usage” instead of “variable expression” to cover both variable expressions and assignments. Likewise with “expression where the variable is used”.

  我説的是“變量使用”而不是“變量表達式”，是為了涵蓋變量表達式和賦值兩種情況。類似於“使用變量的表達式”。

- > “Preceding” means appearing before *in the program text*.

  “前面”意味着出現在*程序文本*之前。

  ```java
  var a = "outer";
  {
    print a;
    var a = "inner";
  }
  ```

  > Here, the `a` being printed is the outer one since it appears before the `print` statement that uses it. In most cases, in straight line code, the declaration preceding in *text* will also precede the usage in *time*. But that’s not always true. As we’ll see, functions may defer a chunk of code such that its *dynamic temporal* execution no longer mirrors the *static textual* ordering.

  這裏，打印的`a`是外層的，因為它在使用該變量的`print`語句之前。在大多數情況下，在單行代碼中，文本中靠前的變量聲明在時間上也先於變量使用。但並不總是如此。正如我們將看到的，函數可以推遲代碼塊，以使其動態執行的時間不受靜態文本順序的約束[^2]。

- > “Innermost” is there because of our good friend shadowing. There may be more than one variable with the given name in enclosing scopes, as in:

  “最內層”之所以存在，是因為我們的好朋友——變量遮蔽的緣故。在外圍作用域中可能存在多個具有給定名稱的變量。如：
  
  ```java
  var a = "outer";
  {
    var a = "inner";
    print a;
  }
  ```
  
  > Our rule disambiguates this case by saying the innermost scope wins.
  
  我們通過優先使用最內層作用域的方式來消除這種歧義。

> Since this rule makes no mention of any runtime behavior, it implies that a variable expression always refers to the same declaration through the entire execution of the program. Our interpreter so far *mostly* implements the rule correctly. But when we added closures, an error snuck in.
>

由於這條規則沒有提及任何運行時行為，它意味着一個變量表達式在程序的整個執行過程中總是指向同一聲明。到目前為止，我們的解釋器基本正確實現了這一規則。但是當我們添加了閉包後，一個錯誤悄悄出現了。

```java
var a = "global";
{
  fun showA() {
    print a;
  }

  showA();
  var a = "block";
  showA();
}
```

> Before you type this in and run it, decide what you think it *should* print.

在你執行這段代碼之前，先思考一下它*應該*輸出什麼[^3]。

> OK . . . got it? If you’re familiar with closures in other languages, you’ll expect it to print “global” twice. The first call to `showA()` should definitely print “global” since we haven’t even reached the declaration of the inner `a` yet. And by our rule that a variable expression always resolves to the same variable, that implies the second call to `showA()` should print the same thing.
>

好的……清楚了嗎？如果你熟悉其它語言中的閉包，你可能期望會輸出兩次“global”。對 `showA() `的第一次調用肯定會打印 “global”，因為我們甚至還沒有執行到內部變量 `a` 的聲明。而根據我們的規則，一個變量表達式總是解析為同一個變量，這意味着對 `showA() `的第二次調用也應該打印出同樣的內容。

> Alas, it prints:

唉，它輸出的是：

```
global
block
```

> Let me stress that this program never reassigns any variable and contains only a single `print` statement. Yet, somehow, that `print` statement for a never-assigned variable prints two different values at different points in time. We definitely broke something somewhere.
>

我要強調一下，這個代碼中從未重新分配任何變量，並且只包含一個`print`語句。然而，不知何故，對於這個從未分配過的變量，`print`語句在不同的時間點上打印了兩個不同的值。我們肯定在什麼地方出了問題。

> ### 11 . 1 . 1 Scopes and mutable environments

### 11.1.1 作用域和可變環境

> In our interpreter, environments are the dynamic manifestation of static scopes. The two mostly stay in sync with each other—we create a new environment when we enter a new scope, and discard it when we leave the scope. There is one other operation we perform on environments: binding a variable in one. This is where our bug lies.
>

在我們的解釋器中，環境是靜態作用域的動態表現。這兩者大多情況下保持同步——當我們進入一個新的作用域時，我們會創建一個新的環境，當我們離開這個作用域時，我們會丟棄它。在環境中還有一個可執行的操作：在環境中綁定一個變量。這就是我們的問題所在。

> Let’s walk through that problematic example and see what the environments look like at each step. First, we declare `a` in the global scope.
>

讓我們通過這個有問題的例子，看看每一步的環境是什麼樣的。首先，我們在全局作用域內聲明`a`。

![The global environment with 'a' defined in it.](11.解析和綁定/environment-1.png)

> That gives us a single environment with a single variable in it. Then we enter the block and execute the declaration of `showA()`.

這為我們提供了一個環境，其中只有一個變量。然後我們進入代碼塊，並執行`showA()`的聲明。

![A block environment linking to the global one.](11.解析和綁定/environment-2.png)

> We get a new environment for the block. In that, we declare one name, `showA`, which is bound to the LoxFunction object we create to represent the function. That object has a `closure` field that captures the environment where the function was declared, so it has a reference back to the environment for the block.

我們得到一個對應該代碼塊的新環境。在這個環境中，我們聲明瞭一個名稱`showA`，它綁定到為表示函數而創建的LoxFunction對象。該對象中有一個`closure`字段，用於捕獲函數聲明時的環境，因此它有一個指向該代碼塊環境的引用。

> Now we call `showA()`.

現在我們調用`showA()`。

![An empty environment for showA()'s body linking to the previous two. 'a' is resolved in the global environment.](11.解析和綁定/environment-3.png)

> The interpreter dynamically creates a new environment for the function body of `showA()`. It’s empty since that function doesn’t declare any variables. The parent of that environment is the function’s closure—the outer block environment.

解釋器為showA()的函數體動態地創建了一個新環境。它是空的，因為該函數沒有聲明任何變量。該環境的父環境是該函數的閉包——外部的代碼塊環境。

> Inside the body of `showA()`, we print the value of `a`. The interpreter looks up this value by walking the chain of environments. It gets all the way to the global environment before finding it there and printing `"global"`. Great.

在`showA()`函數體中，輸出`a`的值。解釋器通過遍歷環境鏈來查找這個值。它會一直到達全局環境，在其中找到變量`a`並打印“global”。太好了。

> Next, we declare the second `a`, this time inside the block.

接下來，我們聲明第二個`a`，這次是在代碼塊內。

![The block environment has both 'a' and 'showA' now.](11.解析和綁定/environment-4.png)

> It’s in the same block—the same scope—as `showA()`, so it goes into the same environment, which is also the same environment `showA()`’s closure refers to. This is where it gets interesting. We call `showA()` again.

它和`showA()`在同一個代碼塊中——同一個作用域，所以它進入了同一個環境，也就是`showA()`的閉包所指向的環境。這就是有趣的地方了。我們再次調用`showA()`。

![An empty environment for showA()'s body linking to the previous two. 'a' is resolved in the block environment.](11.解析和綁定/environment-5.png)

> We create a new empty environment for the body of `showA()` again, wire it up to that closure, and run the body. When the interpreter walks the chain of environments to find `a`, it now discovers the *new* `a` in the block environment. Boo.

我們再次為`showA()`的函數體創建了一個新的空環境，將其連接到該閉包，並運行函數體。當解釋器遍歷環境鏈去查找`a`時，它會發現代碼塊環境中新的變量`a`。

> I chose to implement environments in a way that I hoped would agree with your informal intuition around scopes. We tend to consider all of the code within a block as being within the same scope, so our interpreter uses a single environment to represent that. Each environment is a mutable hash table. When a new local variable is declared, it gets added to the existing environment for that scope.

我選擇了一種實現環境的方式，希望它能夠與您對作用域的非正式直覺相一致。我們傾向於認為一個塊中的所有代碼在同一個作用域中，所以我們的解釋器使用了一個環境來表示它。每個環境都是一個可變的hash表。當一個新的局部變量被聲明時，它會被加入該作用域的現有環境中。

> That intuition, like many in life, isn’t quite right. A block is not necessarily all the same scope. Consider:

就像生活中的很多直覺一樣，這種直覺並不完全正確。一個代碼塊並不一定都是同一個作用域。考慮一下：

```javascript
{
  var a;
  // 1.
  var b;
  // 2.
}
```

> At the first marked line, only `a` is in scope. At the second line, both `a` and `b` are. If you define a “scope” to be a set of declarations, then those are clearly not the same scope—they don’t contain the same declarations. It’s like each `var` statement splits the block into two separate scopes, the scope before the variable is declared and the one after, which includes the new variable.

在標記的第一行，作用域中只有`a`。在第二行時，`a`和`b`都在其中。如果將作用域定義為一組聲明，那麼它們顯然不是相同的作用域——它們不包含相同的聲明。這就好像是`var`語句將代碼塊分割成了兩個獨立的作用域，變量聲明前的作用域和包含新變量的作用域[^4]。

> But in our implementation, environments do act like the entire block is one scope, just a scope that changes over time. Closures do not like that. When a function is declared, it captures a reference to the current environment. The function *should* capture a frozen snapshot of the environment *as it existed at the moment the function was declared*. But instead, in the Java code, it has a reference to the actual mutable environment object. When a variable is later declared in the scope that environment corresponds to, the closure sees the new variable, even though the declaration does *not* precede the function.

但是在我們的實現中，環境確實表現得像整個代碼塊是一個作用域，只是這個作用域會隨時間變化。而閉包不是這樣的。當函數被聲明時，它會捕獲一個指向當前環境的引用。函數*應該*捕獲一個凍結的環境快照，就像它存在於函數被聲明的那一瞬間。但是事實上，在Java代碼中，它引用的是一個實際可變的環境對象。當後續在該環境所對應的作用域內聲明一個變量時，閉包會看到該變量，即使變量聲明*沒有*出現在函數之前。

> ### 11 . 1 . 2 Persistent environments

### 11.1.2 持久環境

> There is a style of programming that uses what are called **persistent data structures**. Unlike the squishy data structures you’re familiar with in imperative programming, a persistent data structure can never be directly modified. Instead, any “modification” to an existing structure produces a brand new object that contains all of the original data and the new modification. The original is left unchanged.

有一種編程風格，使用所謂的**持久性數據結構**。與你在命令式編程中所熟悉的模糊的數據結構不同，持久化數據結構永遠不能被直接修改。相應地，對現有結構的任何 "修改 "都會產生一個全新的對象，其中包含所有的原始數據和新的修改。而原有的對象則保持不變[^5]。

> If we were to apply that technique to Environment, then every time you declared a variable it would return a *new* environment that contained all of the previously declared variables along with the one new name. Declaring a variable would do the implicit “split” where you have an environment before the variable is declared and one after:

如果我們將這一技術應用於環境，那麼每次你聲明一個變量時，都會返回一個新的環境，其中包含所有先前聲明的變量和一個新名稱。聲明一個變量會執行隱式分割，在聲明變量之前與之後都有一個環境：

![Separate environments before and after the variable is declared.](11.解析和綁定/environment-6.png)

> A closure retains a reference to the Environment instance in play when the function was declared. Since any later declarations in that block would produce new Environment objects, the closure wouldn’t see the new variables and our bug would be fixed.

當函數被聲明時，閉包保留對正在運行的Environment實例的引用。由於該代碼塊中後續的任何聲明都會生成新的Environment對象，閉包就不會看到新的變量，我們的問題也得到修復。

> This is a legit way to solve the problem, and it’s the classic way to implement environments in Scheme interpreters. We could do that for Lox, but it would mean going back and changing a pile of existing code.

這是解決該問題的合法方式，也是在Scheme解釋器中實現變量環境的經典方式。對於Lox，我們可以這樣做，但是這意味着要回頭修改一大堆現有的代碼。

> I won’t drag you through that. We’ll keep the way we represent environments the same. Instead of making the data more statically structured, we’ll bake the static resolution into the access *operation* itself.

我不會把你拖下水的。我們將保持表示環境的方式不變。我們不會讓數據變得更加靜態結構化，而是將靜態解析嵌入訪問操作本身。

> ## 11 . 2 Semantic Analysis

## 11.2 語義分析

> Our interpreter **resolves** a variable—tracks down which declaration it refers to—each and every time the variable expression is evaluated. If that variable is swaddled inside a loop that runs a thousand times, that variable gets re-resolved a thousand times.

我們的解釋器每次對變量表達式求值時，都會**解析**變量——追蹤它所指向的聲明。如果這個變量被包在一個運行1000次的循環中，那麼該變量就會被重複解析1000次。

> We know static scope means that a variable usage always resolves to the same declaration, which can be determined just by looking at the text. Given that, why are we doing it dynamically every time? Doing so doesn’t just open the hole that leads to our annoying bug, it’s also needlessly slow.

我們知道靜態作用域意味着一個變量的使用總是解析到同一個聲明，而且可以通過查看文本來確定。既然如此，我們為什麼每次都要動態地解析呢？這樣做不僅僅導致了這個惱人的bug，而且也造成了不必要的低效。

> A better solution is to resolve each variable use *once*. Write a chunk of code that inspects the user’s program, finds every variable mentioned, and figures out which declaration each refers to. This process is an example of a **semantic analysis**. Where a parser tells only if a program is grammatically correct (a *syntactic* analysis), semantic analysis goes farther and starts to figure out what pieces of the program actually mean. In this case, our analysis will resolve variable bindings. We’ll know not just that an expression *is* a variable, but *which* variable it is.

一個更好的解決方案是一次性解析每個變量的使用。編寫一段代碼，檢查用户的程序，找到所提到的每個變量，並找出每個變量引用的是哪個聲明。這個過程是**語義分析**的一個例子。解析器只能分析程序在語法上是否正確(語法分析)，而語義分析則更進一步，開始弄清楚程序的各個部分的實際含義。在這種情況下，我們的分析將解決變量綁定的問題。我們不僅要知道一個表達式是一個變量，還要知道它是哪個變量。

> There are a lot of ways we could store the binding between a variable and its declaration. When we get to the C interpreter for Lox, we’ll have a *much* more efficient way of storing and accessing local variables. But for jlox, I want to minimize the collateral damage we inflict on our existing codebase. I’d hate to throw out a bunch of mostly fine code.

有很多方法可以存儲變量及其聲明直接的綁定關係。當我們使用Lox的C解釋器時，我們將有一種更有效的方式來存儲和訪問局部變量。但是對於jlox來説，我想盡量減少對現有代碼庫的附帶損害。我不希望扔掉一堆基本上都很好的代碼。

> Instead, we’ll store the resolution in a way that makes the most out of our existing Environment class. Recall how the accesses of `a` are interpreted in the problematic example.

相對地，我們將以最充分利用現有Environment類的方式來存儲解析結果。回想一下，在有問題的例子中，`a`的訪問是如何被解釋的。

![An empty environment for showA()'s body linking to the previous two. 'a' is resolved in the global environment.](11.解析和綁定/environment-3.png)

> In the first (correct) evaluation, we look at three environments in the chain before finding the global declaration of `a`. Then, when the inner `a` is later declared in a block scope, it shadows the global one.

在第一次（正確的）求值中，我們會檢查鏈中的環境，並找到`a`的全局聲明。然後，當內部的`a`在塊作用域中聲明時，它會遮蔽全局的變量`a`。

![An empty environment for showA()'s body linking to the previous two. 'a' is resolved in the block environment.](11.解析和綁定/environment-5.png)

> The next lookup walks the chain, finds `a` in the *second* environment and stops there. Each environment corresponds to a single lexical scope where variables are declared. If we could ensure a variable lookup always walked the *same* number of links in the environment chain, that would ensure that it found the same variable in the same scope every time.

下一次查找會遍歷環境鏈，在第二個環境中找到`a`並停止。每個環境都對應於一個聲明變量的詞法作用域。如果我們能夠保證變量查找總是在環境鏈上遍歷相同數量的鏈接，也就可以保證每次都可以在相同的作用域中找到相同的變量。

> To “resolve” a variable usage, we only need to calculate how many “hops” away the declared variable will be in the environment chain. The interesting question is *when* to do this calculation—or, put differently, where in our interpreter’s implementation do we stuff the code for it?

要“解析”一個變量使用，我們只需要計算聲明的變量在環境鏈中有多少“跳”。有趣的問題是在什麼時候進行這個計算——或者換句話説，在解釋器的實現中，這段代碼要添加到什麼地方？

> Since we’re calculating a static property based on the structure of the source code, the obvious answer is in the parser. That is the traditional home, and is where we’ll put it later in clox. It would work here too, but I want an excuse to show you another technique. We’ll write our resolver as a separate pass.

因為我們是根據源代碼的結構來計算一個靜態屬性，所以答案顯然是在解析器中。那是傳統的選擇，也是我們以後在 clox 中實現它的地方。在這裏同樣也適用，但是我想給你展示另一種技巧。我們會單獨寫一個解析器。

> ### 11 . 2 . 1 A variable resolution pass

### 11.2.1 變量解析過程

> After the parser produces the syntax tree, but before the interpreter starts executing it, we’ll do a single walk over the tree to resolve all of the variables it contains. Additional passes between parsing and execution are common. If Lox had static types, we could slide a type checker in there. Optimizations are often implemented in separate passes like this too. Basically, any work that doesn’t rely on state that’s only available at runtime can be done in this way.

在解析器生成語法樹之後，解釋器執行語法樹之前，我們會對語法樹再進行一次遍歷，以解析其中包含的變量。在解析和執行之間的額外遍歷是很常見的。如果Lox中有靜態類型，我們可以插入一個類型檢查器。優化也經常是在類似單獨的遍歷過程中實現的。基本上，任何不依賴於運行時狀態的工作都可以通過這種方式完成。

> Our variable resolution pass works like a sort of mini-interpreter. It walks the tree, visiting each node, but a static analysis is different from a dynamic execution:

我們的變量解析工作就像一個小型的解釋器。它會遍歷整棵樹，訪問每個節點，但是靜態分析與動態執行還是不同的：

- > **There are no side effects.** When the static analysis visits a print statement, it doesn’t actually print anything. Calls to native functions or other operations that reach out to the outside world are stubbed out and have no effect.

  **沒有副作用**。當靜態分析處理一個`print`語句時，它並不會打印任何東西。對本地函數或其它與外部世界聯繫的操作也會被終止，並且沒有任何影響。

- **There is no control flow.** Loops are visited only once. Both branches are visited in `if` statements. Logic operators are not short-circuited.

  **沒有控制流**。循環只會被處理一次，`if`語句中的兩個分支都會處理，邏輯操作符也不會做短路處理[^6]。

> ## 11 . 3 A Resolver Class

## 11.3 Resolver類

> Like everything in Java, our variable resolution pass is embodied in a class.

與Java中的所有內容一樣，我們將變量解析處理也放在一個類中。

*<u>lox/Resolver.java，創建新文件：</u>*

```java
package com.craftinginterpreters.lox;

import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Stack;

class Resolver implements Expr.Visitor<Void>, Stmt.Visitor<Void> {
  private final Interpreter interpreter;

  Resolver(Interpreter interpreter) {
    this.interpreter = interpreter;
  }
}
```

> Since the resolver needs to visit every node in the syntax tree, it implements the visitor abstraction we already have in place. Only a few kinds of nodes are interesting when it comes to resolving variables:

因為解析器需要處理語法樹中的每個節點，所以它實現了我們已有的訪問者抽象。在解析變量時，有幾個節點是比較特殊的：

- > A block statement introduces a new scope for the statements it contains.

  塊語句為它所包含的語句引入了一個新的作用域。

- > A function declaration introduces a new scope for its body and binds its parameters in that scope.

  函數聲明為其函數體引入了一個新的作用域，並在該作用域中綁定了它的形參。

- > A variable declaration adds a new variable to the current scope.

  變量聲明將一個新變量加入到當前作用域中。

- > Variable and assignment expressions need to have their variables resolved.

  變量定義和賦值表達式需要解析它們的變量值。

> The rest of the nodes don’t do anything special, but we still need to implement visit methods for them that traverse into their subtrees. Even though a `+` expression doesn’t *itself* have any variables to resolve, either of its operands might.

其餘的節點不做任何特別的事情，但是我們仍然需要為它們實現visit方法，以遍歷其子樹。儘管`+`表達式本身沒有任何變量需要解析，但是它的任一操作數都可能需要。

> ### 11 . 3 . 1 Resolving blocks
>

### 11.3.1 解析代碼塊

> We start with blocks since they create the local scopes where all the magic happens.

我們從塊語法開始，因為它們創建了局部作用域——魔法出現的地方。

*<u>lox/Resolver.java，在 Resolver()方法後添加：</u>*

```java
  @Override
  public Void visitBlockStmt(Stmt.Block stmt) {
    beginScope();
    resolve(stmt.statements);
    endScope();
    return null;
  }
```

> This begins a new scope, traverses into the statements inside the block, and then discards the scope. The fun stuff lives in those helper methods. We start with the simple one.

這裏會開始一個新的作用域，遍歷塊中的語句，然後丟棄該作用域。有趣的部分都在這些輔助方法中。我們先看一個簡單的。

*<u>lox/Resolver.java，在 Resolver()方法後添加：</u>*

```java
  void resolve(List<Stmt> statements) {
    for (Stmt statement : statements) {
      resolve(statement);
    }
  }
```

> This walks a list of statements and resolves each one. It in turn calls:

它會遍歷語句列表，並解析其中每一條語句。它會進一步調用：

*<u>lox/Resolver.java，在 visitBlockStmt()方法後添加：</u>*

```java
  private void resolve(Stmt stmt) {
    stmt.accept(this);
  }
```

> While we’re at it, let’s add another overload that we’ll need later for resolving an expression.

在此過程中，讓我們添加一個後續解析表達式時會用到的重載方法。

*<u>lox/Resolver.java，在 resolve(Stmt stmt)方法後添加：</u>*

```java
  private void resolve(Expr expr) {
    expr.accept(this);
  }
```

> These methods are similar to the `evaluate()` and `execute()` methods in Interpreter—they turn around and apply the Visitor pattern to the given syntax tree node.

這些方法與解釋器中的 `evaluate()`和`execute()`方法類似——它們會反過來將訪問者模式應用到語法樹節點。

> The real interesting behavior is around scopes. A new block scope is created like so:

真正有趣的部分是圍繞作用域的。一個新的塊作用域是這樣創建的：

*<u>lox/Resolver.java，在 resolve()方法後添加：</u>*

```java
  private void beginScope() {
    scopes.push(new HashMap<String, Boolean>());
  }
```

> Lexical scopes nest in both the interpreter and the resolver. They behave like a stack. The interpreter implements that stack using a linked list—the chain of Environment objects. In the resolver, we use an actual Java Stack.

詞法作用域在解釋器和解析器中都有使用。它們的行為像一個棧。解釋器是使用鏈表（Environment對象組成的鏈）來實現棧的，在解析器中，我們使用一個真正的Java Stack。

*<u>lox/Resolver.java，在 Resolver類中添加：</u>*

```java
  private final Interpreter interpreter;
  // 新增部分開始
  private final Stack<Map<String, Boolean>> scopes = new Stack<>();
  // 新增部分結束
  Resolver(Interpreter interpreter) {
```

> This field keeps track of the stack of scopes currently, uh, in scope. Each element in the stack is a Map representing a single block scope. Keys, as in Environment, are variable names. The values are Booleans, for a reason I’ll explain soon.

這個字段會記錄當前作用域內的棧。棧中的每個元素是代表一個塊作用域的Map。與Environment中一樣，鍵是變量名。值是布爾值，原因我很快會解釋。

> The scope stack is only used for local block scopes. Variables declared at the top level in the global scope are not tracked by the resolver since they are more dynamic in Lox. When resolving a variable, if we can’t find it in the stack of local scopes, we assume it must be global.

作用域棧只用於局部塊作用域。解析器不會跟蹤在全局作用域的頂層聲明的變量，因為它們在Lox中是更動態的。當解析一個變量時，如果我們在本地作用域棧中找不到它，我們就認為它一定是全局的。

> Since scopes are stored in an explicit stack, exiting one is straightforward.

由於作用域被存儲在一個顯式的棧中，退出作用域很簡單。

<u>*lox/Resolver.java，在 beginScope()方法後添加：*</u>

```java
  private void endScope() {
    scopes.pop();
  }
```

> Now we can push and pop a stack of empty scopes. Let’s put some things in them.

現在我們可以在一個棧中壓入和彈出一個空作用域，接下來我們往裏面放些內容。

> ### 11 . 3 . 2 Resolving variable declarations

### 11.3.2 解析變量聲明

> Resolving a variable declaration adds a new entry to the current innermost scope’s map. That seems simple, but there’s a little dance we need to do.

解析一個變量聲明，會在當前最內層的作用域map中添加一個新的條目。這看起來很簡單，但是我們需要做一些小動作。

*<u>lox/Resolver.java，在 visitBlockStmt()方法後添加：</u>*

```java
  @Override
  public Void visitVarStmt(Stmt.Var stmt) {
    declare(stmt.name);
    if (stmt.initializer != null) {
      resolve(stmt.initializer);
    }
    define(stmt.name);
    return null;
  }
```

> We split binding into two steps, declaring then defining, in order to handle funny edge cases like this:

我們將綁定分為兩個步驟，先聲明，然後定義，以便處理類似下面這樣的邊界情況：

```javascript
var a = "outer";
{
  var a = a;
}
```

> What happens when the initializer for a local variable refers to a variable with the same name as the variable being declared? We have a few options:

當局部變量的初始化式指向一個與當前聲明變量名稱相同的變量時，會發生什麼？我們有幾個選擇：

1. > **Run the initializer, then put the new variable in scope.** Here, the new local `a` would be initialized with “outer”, the value of the *global* one. In other words, the previous declaration would desugar to:

   1 **運行初始化式，然後將新的變量放入作用域中。** 在這個例子中，新的局部變量`a`會使用“outer”（全局變量`a`的值）初始化。換句話説，前面的聲明脱糖後如下：

   ```javascript
   var temp = a; // Run the initializer.
   var a;        // Declare the variable.
   a = temp;     // Initialize it.
   ```

2. > **Put the new variable in scope, then run the initializer.** This means you could observe a variable before it’s initialized, so we would need to figure out what value it would have then. Probably `nil`. That means the new local `a` would be re-initialized to its own implicitly initialized value, `nil`. Now the desugaring would look like:

   2 **將新的變量放入作用域中，然後運行初始化式。** 這意味着你可以在變量被初始化之前觀察到它，所以當我們需要計算出它的值時，這個值其實是`nil`。這意味着新的局部變量`a`將被重新初始化為它自己的隱式初始化值`nil`。現在，脱糖後的結果如下：

   ```javascript
   var a; // Define the variable.
   a = a; // Run the initializer.
   ```

3. > **Make it an error to reference a variable in its initializer.** Have the interpreter fail either at compile time or runtime if an initializer mentions the variable being initialized.

   3 **在初始化式中引用一個變量是錯誤的。** 如果初始化式使用了要初始化的變量，則解釋器在編譯時或運行時都會失敗。

> Do either of those first two options look like something a user actually *wants*? Shadowing is rare and often an error, so initializing a shadowing variable based on the value of the shadowed one seems unlikely to be deliberate.

前兩個選項中是否有用户真正*想要*的？變量遮蔽很少見，而且通常是一個錯誤，所以根據被遮蔽的變量值來初始化一個遮蔽的變量，似乎不太可能是有意為之。

> The second option is even less useful. The new variable will *always* have the value `nil`. There is never any point in mentioning it by name. You could use an explicit `nil` instead.

第二個選項就更沒用了。新變量的值總是`nil`。通過名稱來引用沒有任何意義。你可以使用一個顯式的`nil`來代替。

> Since the first two options are likely to mask user errors, we’ll take the third. Further, we’ll make it a compile error instead of a runtime one. That way, the user is alerted to the problem before any code is run.

由於前兩個選項可能會掩蓋用户的錯誤，我們將採用第三個選項。此外，我們要將其作為一個編譯錯誤而不是運行時錯誤。這樣一來，在代碼運行之前，用户就會收到該問題的警報。

> In order to do that, as we visit expressions, we need to know if we’re inside the initializer for some variable. We do that by splitting binding into two steps. The first is **declaring** it.

要做到這一點，當我們訪問表達式時，我們需要知道當前是否在某個變量的初始化式中。我們通過將綁定拆分為兩步來實現。首先是**聲明**。

*<u>lox/Resolver.java，在 endScope()方法後添加：</u>*

```java
  private void declare(Token name) {
    if (scopes.isEmpty()) return;

    Map<String, Boolean> scope = scopes.peek();
    scope.put(name.lexeme, false);
  }
```

> Declaration adds the variable to the innermost scope so that it shadows any outer one and so that we know the variable exists. We mark it as “not ready yet” by binding its name to `false` in the scope map. The value associated with a key in the scope map represents whether or not we have finished resolving that variable’s initializer.

聲明將變量添加到最內層的作用域，這樣它就會遮蔽任何外層作用域，我們也就知道了這個變量的存在。我們通過在作用域map中將其名稱綁定到`false`來表明該變量“尚未就緒”。作用域map中與key相關聯的值代表的是我們是否已經結束了對變量初始化式的解析。

> After declaring the variable, we resolve its initializer expression in that same scope where the new variable now exists but is unavailable. Once the initializer expression is done, the variable is ready for prime time. We do that by **defining** it.

在聲明完變量後，我們在變量當前存在但是不可用的作用域中解析變量的初始化表達式。一旦初始化表達式完成，變量也就緒了。我們通過**define**來實現。

*<u>lox/Resolver.java，在 declare()方法後添加：</u>*

```java
  private void define(Token name) {
    if (scopes.isEmpty()) return;
    scopes.peek().put(name.lexeme, true);
  }
```

> We set the variable’s value in the scope map to `true` to mark it as fully initialized and available for use. It’s alive!

我們在作用域map中將變量的值置為`true`，以標記它已完全初始化並可使用。它有了生命！

> ### 11 . 3 . 3 Resolving variable expressions

### 11.3.3 解析變量表達式

> Variable declarations—and function declarations, which we’ll get to—write to the scope maps. Those maps are read when we resolve variable expressions.

變量聲明——以及我們即將討論的函數聲明——會向作用域map中寫數據。在我們解析變量表達式時，需要讀取這些map。

*<u>lox/Resolver.java，在 visitVarStmt()方法後添加：</u>*

```java
  @Override
  public Void visitVariableExpr(Expr.Variable expr) {
    if (!scopes.isEmpty() &&
        scopes.peek().get(expr.name.lexeme) == Boolean.FALSE) {
      Lox.error(expr.name,
          "Can't read local variable in its own initializer.");
    }

    resolveLocal(expr, expr.name);
    return null;
  }
```

> First, we check to see if the variable is being accessed inside its own initializer. This is where the values in the scope map come into play. If the variable exists in the current scope but its value is `false`, that means we have declared it but not yet defined it. We report that error.

首先，我們要檢查變量是否在其自身的初始化式中被訪問。這也就是作用域map中的值發揮作用的地方。如果當前作用域中存在該變量，但是它的值是`false`，意味着我們已經聲明瞭它，但是還沒有定義它。我們會報告一個錯誤出來。

> After that check, we actually resolve the variable itself using this helper:

在檢查之後，我們實際上使用了這個輔助方法來解析變量：

*<u>lox/Resolver.java，在 define()方法後添加：</u>*

```java
  private void resolveLocal(Expr expr, Token name) {
    for (int i = scopes.size() - 1; i >= 0; i--) {
      if (scopes.get(i).containsKey(name.lexeme)) {
        interpreter.resolve(expr, scopes.size() - 1 - i);
        return;
      }
    }
  }
```

> This looks, for good reason, a lot like the code in Environment for evaluating a variable. We start at the innermost scope and work outwards, looking in each map for a matching name. If we find the variable, we resolve it, passing in the number of scopes between the current innermost scope and the scope where the variable was found. So, if the variable was found in the current scope, we pass in 0. If it’s in the immediately enclosing scope, 1. You get the idea.

這看起來很像是Environment中對變量求值的代碼。我們從最內層的作用域開始，向外擴展，在每個map中尋找一個可以匹配的名稱。如果我們找到了這個變量，我們就對其解析，傳入當前最內層作用域和變量所在作用域之間的作用域的數量。所以，如果變量在當前作用域中找到該變量，則傳入0；如果在緊鄰的外網作用域中找到，則傳1。明白了吧。

> If we walk through all of the block scopes and never find the variable, we leave it unresolved and assume it’s global. We’ll get to the implementation of that `resolve()` method a little later. For now, let’s keep on cranking through the other syntax nodes.

如果我們遍歷了所有的作用域也沒有找到這個變量，我們就不解析它，並假定它是一個全局變量。稍後我們將討論`resolve()`方法的實現。現在，讓我們繼續瀏覽其他語法節點。

> ### 11 . 3 . 4 Resolving assignment expressions

### 11.3.4 解析賦值表達式

> The other expression that references a variable is assignment. Resolving one looks like this:

另一個引用變量的表達式就是賦值表達式。解析方法如下：

*<u>lox/Resolver.java，在 visitVarStmt()方法後添加：</u>*

```
  @Override
  public Void visitAssignExpr(Expr.Assign expr) {
    resolve(expr.value);
    resolveLocal(expr, expr.name);
    return null;
  }
```

> First, we resolve the expression for the assigned value in case it also contains references to other variables. Then we use our existing `resolveLocal()` method to resolve the variable that’s being assigned to.

首先，我們解析右值的表達式，以防它還包含對其它變量的引用。然後使用現有的 `resolveLocal()` 方法解析待賦值的變量。

> ### 11 . 3 . 5 Resolving function declarations

### 11.3.5 解析函數聲明

> Finally, functions. Functions both bind names and introduce a scope. The name of the function itself is bound in the surrounding scope where the function is declared. When we step into the function’s body, we also bind its parameters into that inner function scope.

最後是函數。函數既綁定名稱又引入了作用域。函數本身的名稱被綁定在函數聲明時所在的作用域中。當我們進入函數體時，我們還需要將其參數綁定到函數內部作用域中。

*<u>lox/Resolver.java，在 visitBlockStmt()方法後添加：</u>*

```java
  @Override
  public Void visitFunctionStmt(Stmt.Function stmt) {
    declare(stmt.name);
    define(stmt.name);

    resolveFunction(stmt);
    return null;
  }
```

> Similar to `visitVariableStmt()`, we declare and define the name of the function in the current scope. Unlike variables, though, we define the name eagerly, before resolving the function’s body. This lets a function recursively refer to itself inside its own body.

與`visitVariableStmt()`類似，我們在當前作用域中聲明並定義函數的名稱。與變量不同的是，我們在解析函數體之前，就急切地定義了這個名稱。這樣函數就可以在自己的函數體中遞歸地使用自身。

> Then we resolve the function’s body using this:

那麼我們可以使用下面的方法來解析函數體：

*<u>lox/Resolver.java，在 resolve()方法後添加：</u>*

```java
  private void resolveFunction(Stmt.Function function) {
    beginScope();
    for (Token param : function.params) {
      declare(param);
      define(param);
    }
    resolve(function.body);
    endScope();
  }
```

> It’s a separate method since we will also use it for resolving Lox methods when we add classes later. It creates a new scope for the body and then binds variables for each of the function’s parameters.

這是一個單獨的方法，因為我們以後添加類時，還需要使用它來解析Lox方法。它為函數體創建一個新的作用域，然後為函數的每個參數綁定變量。

> Once that’s ready, it resolves the function body in that scope. This is different from how the interpreter handles function declarations. At *runtime*, declaring a function doesn’t do anything with the function’s body. The body doesn’t get touched until later when the function is called. In a *static* analysis, we immediately traverse into the body right then and there.

一旦就緒，它就會在這個作用域中解析函數體。這與解釋器處理函數聲明的方式不同。在*運行時*，聲明一個函數不會對函數體做任何處理。直到後續函數被調用時，才會觸及主體。在*靜態*分析中，我們會立即遍歷函數體。

> ### 11 . 3 . 6 Resolving the other syntax tree nodes

### 11.3.6 解析其它語法樹節點

> That covers the interesting corners of the grammars. We handle every place where a variable is declared, read, or written, and every place where a scope is created or destroyed. Even though they aren’t affected by variable resolution, we also need visit methods for all of the other syntax tree nodes in order to recurse into their subtrees. Sorry this bit is boring, but bear with me. We’ll go kind of “top down” and start with statements.

這涵蓋了語法中很多有趣的部分。我們處理了聲明、讀取、寫入遍歷，創建、銷燬作用域的部分。雖然其它部分不受遍歷解析的影響，我們也需要為其它語法樹節點提供visit方法，以便遞歸到它們的子樹。抱歉，這部分內容很枯燥，但請耐心聽我講。我們採用“自上而下”的方式，從語句開始。

> An expression statement contains a single expression to traverse.

一個表達式語句中包含一個需要遍歷的表達式。

*<u>lox/Resolver.java，在 visitBlockStmt()方法後添加：</u>*

```java
  @Override
  public Void visitExpressionStmt(Stmt.Expression stmt) {
    resolve(stmt.expression);
    return null;
  }
```

> An if statement has an expression for its condition and one or two statements for the branches.

`if`語句包含一個條件表達式，以及一個或兩個分支語句。

*<u>lox/Resolver.java，在 visitFunctionStmt()方法後添加：</u>*

```java
  @Override
  public Void visitIfStmt(Stmt.If stmt) {
    resolve(stmt.condition);
    resolve(stmt.thenBranch);
    if (stmt.elseBranch != null) resolve(stmt.elseBranch);
    return null;
  }
```

> Here, we see how resolution is different from interpretation. When we resolve an `if` statement, there is no control flow. We resolve the condition and *both* branches. Where a dynamic execution steps only into the branch that *is* run, a static analysis is conservative—it analyzes any branch that *could* be run. Since either one could be reached at runtime, we resolve both.

在這裏，我們可以看到解析與解釋是不同的。當我們解析`if`語句時，沒有控制流。我們會解析條件表達式和兩個分支表達式。動態執行則只會進入*正在執行*的分支，而靜態分析是保守的——它會分析所有*可能執行*的分支。因為任何一個分支在運行時都可能被觸及，所以我們要對兩者都進行解析。

> Like expression statements, a `print` statement contains a single subexpression.

與表達式語句類似，`print`語句也包含一個子表達式。

*<u>lox/Resolver.java，在 visitIfStmt()方法後添加：</u>*

```java
  @Override
  public Void visitPrintStmt(Stmt.Print stmt) {
    resolve(stmt.expression);
    return null;
  }
```

> Same deal for return.

`return`語句也是相同的。

*<u>lox/Resolver.java，在 visitPrintStmt()方法後添加：</u>*

```java
  @Override
  public Void visitReturnStmt(Stmt.Return stmt) {
    if (stmt.value != null) {
      resolve(stmt.value);
    }

    return null;
  }
```

> As in `if` statements, with a `while` statement, we resolve its condition and resolve the body exactly once.

與`if`語句一樣，對於`while`語句，我們會解析其條件，並解析一次循環體。

*<u>lox/Resolver.java，在 visitVarStmt()方法後添加：</u>*

```java
  @Override
  public Void visitWhileStmt(Stmt.While stmt) {
    resolve(stmt.condition);
    resolve(stmt.body);
    return null;
  }
```

> That covers all the statements. On to expressions . . . 

這樣就涵蓋了所有的語句。接下來是表達式……

> Our old friend the binary expression. We traverse into and resolve both operands.

我們的老朋友二元表達式。我們要遍歷並解析兩個操作數。

*<u>lox/Resolver.java，在 visitAssignExpr()方法後添加：</u>*

```java
  @Override
  public Void visitBinaryExpr(Expr.Binary expr) {
    resolve(expr.left);
    resolve(expr.right);
    return null;
  }
```

> Calls are similar—we walk the argument list and resolve them all. The thing being called is also an expression (usually a variable expression), so that gets resolved too.

調用也是類似的——我們遍歷參數列表並解析它們。被調用的對象也是一個表達式（通常是一個變量表達式），所以它也會被解析。

*<u>lox/Resolver.java，在 visitBinaryExpr()方法後添加：</u>*

```java
  @Override
  public Void visitCallExpr(Expr.Call expr) {
    resolve(expr.callee);

    for (Expr argument : expr.arguments) {
      resolve(argument);
    }

    return null;
  }
```

> Parentheses are easy.

括號表達式比較簡單。

*<u>lox/Resolver.java，在 visitCallExpr()方法後添加：</u>*

```java
  @Override
  public Void visitGroupingExpr(Expr.Grouping expr) {
    resolve(expr.expression);
    return null;
  }
```

> Literals are easiest of all.

字面量表達式是最簡單的。

*<u>lox/Resolver.java，在 visitGroupingExpr()方法後添加：</u>*

```java
  @Override
  public Void visitLiteralExpr(Expr.Literal expr) {
    return null;
  }
```

> A literal expression doesn’t mention any variables and doesn’t contain any subexpressions so there is no work to do.

字面表達式中沒有使用任何變量，也不包含任何子表達式，所以也不需要做任何事情。

> Since a static analysis does no control flow or short-circuiting, logical expressions are exactly the same as other binary operators.

因為靜態分析沒有控制流或短路處理，邏輯表達式與其它的二元運算符是一樣的。

*<u>lox/Resolver.java，在 visitLiteralExpr()方法後添加：</u>*

```java
  @Override
  public Void visitLogicalExpr(Expr.Logical expr) {
    resolve(expr.left);
    resolve(expr.right);
    return null;
  }
```

> And, finally, the last node. We resolve its one operand.

接下來是最後一個節點，我們解析它的一個操作數。

*<u>lox/Resolver.java，在 visitLogicalExpr()方法後添加：</u>*

```java
  @Override
  public Void visitUnaryExpr(Expr.Unary expr) {
    resolve(expr.right);
    return null;
  }
```

> With all of these visit methods, the Java compiler should be satisfied that Resolver fully implements Stmt.Visitor and Expr.Visitor. Now is a good time to take a break, have a snack, maybe a little nap.

有了這些visit方法，Java編譯器應該會認為Resolver完全實現了Stmt.Visitor 和 Expr.Visitor。現在是時候休息一下了。

> ## 11 . 4 Interpreting Resolved Variables
>

## 11.4 解釋已解析的變量

> Let’s see what our resolver is good for. Each time it visits a variable, it tells the interpreter how many scopes there are between the current scope and the scope where the variable is defined. At runtime, this corresponds exactly to the number of *environments* between the current one and the enclosing one where the interpreter can find the variable’s value. The resolver hands that number to the interpreter by calling this:

讓我們看看解析器有什麼用處。每次訪問一個變量時，它都會告訴解釋器，在當前作用域和變量定義的作用域之間隔着多少層作用域。在運行時，這正好對應於當前環境與解釋器可以找到變量值的外圍環境之間的*environments*數量。解析器通過調用下面的方法將這個數字傳遞給解釋器：

*<u>lox/Interpreter.java，在 execute()方法後添加：</u>*

```java
  void resolve(Expr expr, int depth) {
    locals.put(expr, depth);
  }
```

> We want to store the resolution information somewhere so we can use it when the variable or assignment expression is later executed, but where? One obvious place is right in the syntax tree node itself. That’s a fine approach, and that’s where many compilers store the results of analyses like this.

我們要把解析信息存儲在某個地方，這樣在執行變量表達式和賦值表達式時就可以使用它，但是要存在哪裏呢？一個明顯的位置就是語法樹節點本身。這是一個很好的方法，許多編譯器都是在這裏存儲類似的分析結果的。

> We could do that, but it would require mucking around with our syntax tree generator. Instead, we’ll take another common approach and store it off to the side in a map that associates each syntax tree node with its resolved data.

我們可以這樣做，但是需要對我們的語法樹生成器進行修改。相反，我們會採用另一種常見的方法，將其存儲在一個map中，將每個語法樹節點與其解析的數據關聯起來。

> Interactive tools like IDEs often incrementally reparse and re-resolve parts of the user’s program. It may be hard to find all of the bits of state that need recalculating when they’re hiding in the foliage of the syntax tree. A benefit of storing this data outside of the nodes is that it makes it easy to *discard* it—simply clear the map.

像IDE這種的交互式工具經常會增量地對用户的部分代碼進行重新分析和解析。當這些狀態隱藏在語法樹的枝葉中時，可能很難找到所有需要重新計算的狀態。將這些數據存儲在節點之外的好處之一就是，可以很容易地丟棄這部分數據——只需要清除map即可。

*lox/Interpreter.java*，在 *Interpreter*類中添加

```java
  private Environment environment = globals;
  // 新增部分開始
  private final Map<Expr, Integer> locals = new HashMap<>();
  // 新增部分結束
  Interpreter() {
```

> You might think we’d need some sort of nested tree structure to avoid getting confused when there are multiple expressions that reference the same variable, but each expression node is its own Java object with its own unique identity. A single monolithic map doesn’t have any trouble keeping them separated.

你可能認為我們需要某種嵌套的樹狀結構，以避免在有多個表達式引用同一個變量時出現混亂，但是每個表達式節點都有其對應的Java對象，具有唯一性標識。一個簡單的map就足以將它們全部區分開來。

> As usual, using a collection requires us to import a couple of names.

與之前一樣，使用集合需要先引入一些包名稱。

*<u>lox/Interpreter.java，添加：</u>*

```java
import java.util.ArrayList;
// 新增部分開始
import java.util.HashMap;
// 新增部分結束
import java.util.List;
```

> And:

還有：

*<u>lox/Interpreter.java，添加：</u>*

```java
import java.util.List;
// 新增部分開始
import java.util.Map;
// 新增部分結束
class Interpreter implements Expr.Visitor<Object>,
```

> ### 11 . 4 . 1Accessing a resolved variable

### 11.4.1 訪問已解析的變量

> Our interpreter now has access to each variable’s resolved location. Finally, we get to make use of that. We replace the visit method for variable expressions with this:

我們的解釋器現在可以訪問每個變量的解析位置。最後，我們可以利用這一點了，將變量表達式的visit方法替換如下：

*<u>lox/Interpreter.java，在 visitVariableExpr()方法中替換一行：</u>*

```java
  public Object visitVariableExpr(Expr.Variable expr) {
    // 替換部分開始
    return lookUpVariable(expr.name, expr);
    // 替換部分結束
  }
```

> That delegates to:

這裏引用了：

*<u>lox/Interpreter.java，在 visitVariableExpr()方法後添加：</u>*

```java
  private Object lookUpVariable(Token name, Expr expr) {
    Integer distance = locals.get(expr);
    if (distance != null) {
      return environment.getAt(distance, name.lexeme);
    } else {
      return globals.get(name);
    }
  }
```

> There are a couple of things going on here. First, we look up the resolved distance in the map. Remember that we resolved only *local* variables. Globals are treated specially and don’t end up in the map (hence the name `locals`). So, if we don’t find a distance in the map, it must be global. In that case, we look it up, dynamically, directly in the global environment. That throws a runtime error if the variable isn’t defined.

這裏有幾件事要做。首先，我們在map中查找已解析的距離值。要記住，我們只解析了本地變量。全局變量被特殊處理了，不會出現了map中（所以它的名字叫`locals`）。所以，如果我們沒有在map中找到變量對應的距離值，它一定是全局變量。在這種情況下，我們直接在全局environment中查找。如果變量沒有被定義，就會產生一個運行時錯誤。

> If we *do* get a distance, we have a local variable, and we get to take advantage of the results of our static analysis. Instead of calling `get()`, we call this new method on Environment:

如果我們*確實*查到了一個距離值，那這就是個局部變量，我們可以利用靜態分析的結果。我們不會調用`get()`方法，而是調用下面這個Environment中的新方法：

*<u>lox/Environment.java，在 define()方法後添加：</u>*

```java
  Object getAt(int distance, String name) {
    return ancestor(distance).values.get(name);
  }
```

> The old `get()` method dynamically walks the chain of enclosing environments, scouring each one to see if the variable might be hiding in there somewhere. But now we know exactly which environment in the chain will have the variable. We reach it using this helper method:

原先的`get()`方法會動態遍歷外圍的環境鏈，搜索每一個環境，查看變量是否包含在其中。但是現在我們明確知道鏈路中的哪個環境中會包含該變量。我們使用下面的輔助方法直達這個環境：

*<u>lox/Environment.java，在 define()方法後添加：</u>*

```java
  Environment ancestor(int distance) {
    Environment environment = this;
    for (int i = 0; i < distance; i++) {
      environment = environment.enclosing; 
    }

    return environment;
  }
```

> This walks a fixed number of hops up the parent chain and returns the environment there. Once we have that, `getAt()` simply returns the value of the variable in that environment’s map. It doesn’t even have to check to see if the variable is there—we know it will be because the resolver already found it before.

該方法在環境鏈中經過確定的跳數之後，返回對應的環境。一旦我們有了環境，`getAt()`方法就可以直接返回對應環境map中的變量值。甚至不需要檢查變量是否存在——我們知道它是存在的，因為解析器之前已經確認過了[^7]。

> ### 11 . 4 . 2 Assigning to a resolved variable

### 11.4.2 賦值已解析的變量

> We can also use a variable by assigning to it. The changes to visiting an assignment epression are similar.

我們也可以通過賦值來使用一個變量。賦值表達式對應的visit方法的修改也是類似的。

*<u>lox/Interpreter.java，在 visitAssignExpr()方法中替換一行：</u>*

```java
  public Object visitAssignExpr(Expr.Assign expr) {
    Object value = evaluate(expr.value);  
    // 替換部分開始
    Integer distance = locals.get(expr);
    if (distance != null) {
      environment.assignAt(distance, expr.name, value);
    } else {
      globals.assign(expr.name, value);
    }
    // 替換部分結束
    return value;
```

> Again, we look up the variable’s scope distance. If not found, we assume it’s global and handle it the same way as before. Otherwise, we call this new method:

又一次，我們要查找變量的作用域距離。如果沒有找到，我們就假定它是全局變量並採用跟之前一樣的方式來處理；否則，我們使用下面的新方法：

*<u>lox/Environment.java，在 getAt()方法後添加：</u>*

```java
  void assignAt(int distance, Token name, Object value) {
    ancestor(distance).values.put(name.lexeme, value);
  }
```

> As `getAt()` is to `get()`, `assignAt()` is to `assign()`. It walks a fixed number of environments, and then stuffs the new value in that map.

正如`getAt()` 與`get()`的關係，`assignAt()` 對應於`assign()`。它會遍歷固定數量的環境，然後在其map中塞入新的值。

> Those are the only changes to Interpreter. This is why I chose a representation for our resolved data that was minimally invasive. All of the rest of the nodes continue working as they did before. Even the code for modifying environments is unchanged.

解釋器就只需要做這些調整。這也就是為什麼我為解析數據選擇了一種侵入性最小的表示方法。其餘所有節點都跟之前一樣，甚至連修改環境的代碼也沒有改動。

> ### 11 . 4 . 3 Running the resolver

### 11.4.3 運行解析器

> We do need to actually *run* the resolver, though. We insert the new pass after the parser does its magic.

不過，我們確實需要*運行*解析器。我們在解析器完成工作之後插入一次解析器處理。

*<u>lox/Lox.java，在 run()方法中添加代碼：</u>*

```java
    // Stop if there was a syntax error.
    if (hadError) return;
    // 新增部分開始
    Resolver resolver = new Resolver(interpreter);
    resolver.resolve(statements);
    // 新增部分結束
    interpreter.interpret(statements);
```

> We don’t run the resolver if there are any parse errors. If the code has a syntax error, it’s never going to run, so there’s little value in resolving it. If the syntax is clean, we tell the resolver to do its thing. The resolver has a reference to the interpreter and pokes the resolution data directly into it as it walks over variables. When the interpreter runs next, it has everything it needs.

如果前面的分析中存在任何錯誤，我們都不會運行解析器。如果代碼有語法錯誤，它就不會運行，所以解析它的價值不大。如果語法是乾淨的，我們就告訴解析器做該做的事。解析器中有一個對解釋器的引用，當它遍歷變量時，會將解析數據直接放入解釋器中。解釋器後續運行時，它就具備了所需的一切數據。

> At least, that’s true if the resolver *succeeds*. But what about errors during resolution?

退一步講，如果解析器成功了，這麼説就是對的。但是如果解析過程中出現錯誤會怎麼辦？

> ## 11 . 5 Resolution Errors

## 11.5 解析錯誤

> Since we are doing a semantic analysis pass, we have an opportunity to make Lox’s semantics more precise, and to help users catch bugs early before running their code. Take a look at this bad boy:

由於我們正在進行語義分析，因此我們有機會使Lox 的語義更加精確，以幫助用户在執行代碼之前及早發現錯誤。看一下下面這個壞代碼：

```javascript
fun bad() {
  var a = "first";
  var a = "second";
}
```

> We do allow declaring multiple variables with the same name in the *global* scope, but doing so in a local scope is probably a mistake. If they knew the variable already existed, they would have assigned to it instead of using `var`. And if they *didn’t* know it existed, they probably didn’t intend to overwrite the previous one.

我們確實允許在*全局*作用域內聲明多個同名的變量，但在局部作用域內這樣做可能是錯誤的。如果用户知道變量已經存在，就應該使用賦值操作而不是`var`。如果他們不知道變量的存在，他們可能並不想覆蓋之前的變量。

> We can detect this mistake statically while resolving.

我們可以在解析的時候靜態地檢測到這個錯誤。

*<u>lox/Resolver.java，在 declare()方法中添加：</u>*

```java
    Map<String, Boolean> scope = scopes.peek();
    // 新增部分開始
    if (scope.containsKey(name.lexeme)) {
      Lox.error(name,
          "Already variable with this name in this scope.");
    }
    // 新增部分結束
    scope.put(name.lexeme, false);
```

> When we declare a variable in a local scope, we already know the names of every variable previously declared in that same scope. If we see a collision, we report an error.

當我們在局部作用域中聲明一個變量時，我們已經知道了之前在同一作用域中聲明的每個變量的名字。如果我們看到有衝突，我們就報告一個錯誤。

> ### 11 . 5 . 1 Invalid return errors

### 11.5.1 無效返回錯誤

> Here’s another nasty little script:

這是另一個討人厭的小腳本：

```java
return "at top level";
```

> This executes a `return` statement, but it’s not even inside a function at all. It’s top-level code. I don’t know what the user *thinks* is going to happen, but I don’t think we want Lox to allow this.

這裏執行了一個`return`語句，但它甚至根本不在函數內部。這是一個頂層代碼。我不知道用户認為會發生什麼，但是我認為我們不希望Lox允許這種做法。

> We can extend the resolver to detect this statically. Much like we track scopes as we walk the tree, we can track whether or not the code we are currently visiting is inside a function declaration.

我們可以對解析器進行擴展來靜態檢測這種錯誤。就像我們遍歷語法樹時跟蹤作用域一樣，我們也可以跟蹤當前訪問的代碼是否在一個函數聲明內部。

*<u>lox/Resolver.java，在 Resolver類中添加代碼：</u>*

```java
  private final Stack<Map<String, Boolean>> scopes = new Stack<>();
  // 新增部分開始
  private FunctionType currentFunction = FunctionType.NONE;
  // 新增部分結束
  Resolver(Interpreter interpreter) {
```

> Instead of a bare Boolean, we use this funny enum:

我們不是使用一個簡單的Boolean值，而是使用下面這個有趣的枚舉：

*<u>lox/Resolver.java，在 Resolver()方法後添加：</u>*

```
  private enum FunctionType {
    NONE,
    FUNCTION
  }
```

> It seems kind of dumb now, but we’ll add a couple more cases to it later and then it will make more sense. When we resolve a function declaration, we pass that in.

現在看來又點蠢，但是我們稍後會添加更多案例，到時候它將更有意義。當我們解析函數聲明時，將其作為參數傳入。

*<u>lox/Resolver.java，在 visitFunctionStmt()方法中，替換一行：</u>*

```java
    define(stmt.name);
    // 替換部分開始
    resolveFunction(stmt, FunctionType.FUNCTION);
    // 替換部分結束
    return null;
```

> Over in `resolveFunction()`, we take that parameter and store it in the field before resolving the body.

在`resolveFunction()`中，我們接受該參數，並在解析函數體之前將其保存在字段中。

*<u>lox/Resolver.java，在 resolveFunction()方法中替換一行：</u>*

```java
  // 替換部分開始
	private void resolveFunction(
      Stmt.Function function, FunctionType type) {
    FunctionType enclosingFunction = currentFunction;
    currentFunction = type;
    // 替換部分結束
    beginScope();
```

> We stash the previous value of the field in a local variable first. Remember, Lox has local functions, so you can nest function declarations arbitrarily deeply. We need to track not just that we’re in a function, but *how many* we’re in.

我們先把該字段的舊值存在一個局部變量中。記住，Lox中有局部函數，所以你可以任意深度地嵌套函數聲明。我們不僅需要跟蹤是否在一個函數內部，還要記錄我們在*多少*函數內部。

> We could use an explicit stack of FunctionType values for that, but instead we’ll piggyback on the JVM. We store the previous value in a local on the Java stack. When we’re done resolving the function body, we restore the field to that value.

我們可以使用一個顯式的FunctionType值堆棧來進行記錄，但我們會藉助JVM的力量。我們將前一個值保存在Java堆棧中的一個局部變量。當我們完成函數體的解析之後，我們將該字段恢復為之前的值。

*<u>lox/Resolver.java，在 resolveFunction()方法中添加代碼：</u>*

```java
    endScope();
    // 新增部分開始
    currentFunction = enclosingFunction;
    // 新增部分結束
  }
```

> Now that we can always tell whether or not we’re inside a function declaration, we check that when resolving a `return` statement.

既然我們能知道是否在一個函數聲明中，那我們就可以在解析`return`語句時進行檢查。

*<u>lox/Resolver.java，在 visitReturnStmt()方法中添加代碼：</u>*

```java
  public Void visitReturnStmt(Stmt.Return stmt) {
    // 新增部分開始
    if (currentFunction == FunctionType.NONE) {
      Lox.error(stmt.keyword, "Can't return from top-level code.");
    }
    // 新增部分結束
    if (stmt.value != null) {
```

> Neat, right?

很簡潔，對吧？

> There’s one more piece. Back in the main Lox class that stitches everything together, we are careful to not run the interpreter if any parse errors are encountered. That check runs *before* the resolver so that we don’t try to resolve syntactically invalid code.

還有一件事。回到將所有部分整合到一起的主類Lox中，我們很小心，如果遇到任何解析錯誤就不會運行解釋器。這個檢查是在解析器*之前*運行的，這樣我們就不需要再去嘗試解析語法無效的代碼。

> But we also need to skip the interpreter if there are resolution errors, so we add *another* check.

但是如果在解析變量時存在錯誤，也需要跳過解釋器，所以我們添加*另一個*檢查。

*<u>lox/Lox.java，在 run()方法中添加代碼：</u>*

```java
    resolver.resolve(statements);
    // 新增部分開始
    // Stop if there was a resolution error.
    if (hadError) return;
    // 新增部分結束
    interpreter.interpret(statements);
```

> You could imagine doing lots of other analysis in here. For example, if we added `break` statements to Lox, we would probably want to ensure they are only used inside loops.

你可以想象在這裏做很多其它分析。例如，我們在Lox中添加了`break`語句，而我們可能想確保它只能在循環體中使用。

> We could go farther and report warnings for code that isn’t necessarily *wrong* but probably isn’t useful. For example, many IDEs will warn if you have unreachable code after a `return` statement, or a local variable whose value is never read. All of that would be pretty easy to add to our static visiting pass, or as separate passes.

我們還可以更進一步，對那些不一定是錯誤但可能沒有用的代碼提出警告。舉例來説，如果在`return`語句後有不可觸及的代碼，很多IDE都會發出警告，或者是一個局部變量的值從沒有被使用過。所有這些都可以很簡單地添加到我們的靜態分析過程中，或者作為單獨的分析過程[^8]。

> But, for now, we’ll stick with that limited amount of analysis. The important part is that we fixed that one weird annoying edge case bug, though it might be surprising that it took this much work to do it.

但是，就目前而言，我們會堅持這種有限的分析。重要的是，我們修復了一個奇怪又煩人的邊界情況bug，儘管花費了這麼多精力可能有些令人意外。



[^1]: 這還遠遠比不上真正的語言規範那麼精確。那些規範文檔必須非常明確，即使是一個火星人或一個完全惡意的程序員也會被迫執行正確的語義，只要他們遵循規範説明。有一些公司希望自己的產品與其它產品不兼容，從而將用户鎖定在自己的平台上，當一種語言由這類公司實現時，精確性就非常重要了。對於這本書來説，我們很慶幸可以忽略那些爾虞我詐。
[^2]: 在JavaScript中，使用var聲明的變量被隱式提升到塊的開頭，在代碼塊中對該名稱的任何使用都將指向該變量，即使變量使用出現在聲明之前。當你用JavaScript寫如下代碼時：`{  console.log(a);  var a = "value"; }`。它實際相當於：`{  var a; // Hoist.  console.log(a);  a = "value"; }`。這意味着在某些情況下，您可以在其初始化程序運行之前讀取一個變量——一個令人討厭的錯誤源。後來添加了用於聲明變量的備用`let`語法來解決這個問題。
[^3]: 我知道，這完全是一個病態的、人為的程序。這太奇怪了。沒有一個理性的人會寫這樣的代碼。唉，如果你長期從事編程語言的工作，你的生活中會有比你想象的更多的時間花在處理這種古怪的代碼片段上。
[^4]: 一些語言中明確進行了這種分割。在Scheme和ML中，當你用`let`聲明一個局部變量時，還描述了新變量在作用域內的後續代碼。不存在隱含的 “塊的其餘部分”。
[^5]: 為每個操作複製結構，這聽起來可能會浪費大量的內存和時間。在實踐中，持久性數據結構在不同的“副本”之間共享大部分的數據。
[^6]: 變量解析對每個節點只觸及一次，因此其性能是*O(n)*，其中n是語法樹中節點的個數。更復雜的分析可能會有更大的複雜性，但是大多數都被精心設計成線性或接近線性。如果編譯器隨着用户程序的增長而呈指數級變慢，那將是一個很尷尬的失禮。
[^7]: 解釋器假定變量在map中存在的做法有點像是盲飛。解釋器相信解析器完成了工作並正確地解析了變量。這意味着這兩個類之間存在深度耦合。在解析器中，涉及作用域的每一行代碼都必須與解釋器中修改環境的代碼完全匹配。我對這種耦合有切身體會，因為當我在為本書寫代碼時，我遇到了幾個微妙的錯誤，即解析器代碼和解釋器代碼有點不同步。跟蹤這些問題是很困難的。一個行之有效的方法就是，在解釋器中使用顯式的斷言——通過Java的assert或其它驗證工具——確認解析器已經具備它所期望的值。
[^8]: 要選擇將多少個不同的靜態分析納入單個處理過程中是很困難的。許多小的、孤立的過程（每個過程都有自己的職責）實現和維護都比較簡單。然而，遍歷語法樹本身是有實際運行時間成本的，所以將多個分析綁定到一個過程中通常會更快。



------

> ## CHALLENGES

## 習題

> 1、Why is it safe to eagerly define the variable bound to a function’s name when other variables must wait until after they are initialized before they can be used?

1、為什麼先定義與函數名稱綁定的變量是安全的，而其它變量必須等到初始化後才能使用？

> 2、How do other languages you know handle local variables that refer to the same name in their initializer, like:

2、你知道其它語言中是如何處理局部變量在初始化式中引用了相同名稱變量的情況？比如：

```javascript
var a = "outer";
{
  var a = a;
}
```

> Is it a runtime error? Compile error? Allowed? Do they treat global variables differently? Do you agree with their choices? Justify your answer.

這是一個運行時錯誤？編譯錯誤？還是允許這種操作？它們對待全局變量的方式有區別嗎？你是否認同它們的選擇？證明你的答案。

> 3、Extend the resolver to report an error if a local variable is never used.

3、對解析器進行擴展，如果局部變量沒有被使用就報告一個錯誤。

> 4、Our resolver calculates *which* environment the variable is found in, but it’s still looked up by name in that map. A more efficient environment representation would store local variables in an array and look them up by index.
>
> Extend the resolver to associate a unique index for each local variable declared in a scope. When resolving a variable access, look up both the scope the variable is in and its index and store that. In the interpreter, use that to quickly access a variable by its index instead of using a map.

4、我們的解析器會計算出變量是在哪個環境中找到的，但是它仍然需要根據名稱在對應的map中查找。一個更有效的環境表示形式是將局部變量保存在一個數組中，並通過索引來查找它們。

擴展解析器，為作用域中聲明的每個局部變量關聯一個唯一的索引。當解析一個變量的訪問時，查找變量所在的作用域及對應的索引，並保存起來。在解釋器中，使用這個索引快速的訪問一個變量。
