# 15. A Virtual Machine 虛擬機

> Magicians protect their secrets not because the secrets are large and important, but because they are so small and trivial. The wonderful effects created on stage are often the result of a secret so absurd that the magician would be embarrassed to admit that that was how it was done.
>
> ​																																	——Christopher Priest, *The Prestige*

魔術師們之所以保護他們的秘密，並不是因為秘密很大、很重要，而是它們是如此小而微不足道。在舞台上創造出的奇妙效果往往源自於一個荒謬的小秘密，以至於魔術師都不好意思承認這是如何完成的。

> We’ve spent a lot of time talking about how to represent a program as a sequence of bytecode instructions, but it feels like learning biology using only stuffed, dead animals. We know what instructions are in theory, but we’ve never seen them in action, so it’s hard to really understand what they *do*. It would be hard to write a compiler that outputs bytecode when we don’t have a good understanding of how that bytecode behaves.

我們已經花了很多時間討論如何將程序表示為字節碼指令序列，但是這感覺像是隻用填充的死動物來學習生物學。我們知道理論上的指令是什麼，但我們在實際操作中從未見過，因此很難真正理解指令的*作用*。如果我們不能很好地理解字節碼的行為方式，就很難編寫輸出字節碼的編譯器。

> So, before we go and build the front end of our new interpreter, we will begin with the back end—the virtual machine that executes instructions. It breathes life into the bytecode. Watching the instructions prance around gives us a clearer picture of how a compiler might translate the user’s source code into a series of them.

因此，在構建新解釋器的前端之前，我們先從後端開始——執行指令的虛擬機。它為字節碼注入了生命。通過觀察這些指令的運行，我們可以更清楚地瞭解編譯器如何將用户的源代碼轉換成一系列的指令。

> ## 15 . 1An Instruction Execution Machine

## 15.1 指令執行機器

> The virtual machine is one part of our interpreter’s internal architecture. You hand it a chunk of code—literally a Chunk—and it runs it. The code and data structures for the VM reside in a new module.

虛擬機是我們解釋器內部結構的一部分。你把一個代碼塊交給它，它就會運行這塊代碼。VM的代碼和數據結構放在一個新的模塊中。

*<u>vm.h，創建新文件：</u>*

```c
#ifndef clox_vm_h
#define clox_vm_h

#include "chunk.h"

typedef struct {
  Chunk* chunk;
} VM;

void initVM();
void freeVM();

#endif
```

> As usual, we start simple. The VM will gradually acquire a whole pile of state it needs to keep track of, so we define a struct now to stuff that all in. Currently, all we store is the chunk that it executes.

跟之前一樣，我們從簡單的部分開始。VM會逐步獲取到一大堆它需要跟蹤的狀態，所以我們現在定義一個結構，把這些狀態都塞進去。目前，我們只存儲它執行的代碼塊。

> Like we do with most of the data structures we create, we also define functions to create and tear down a VM. Here’s the implementation:

與我們創建的大多數數據結構類似，我們也會定義用來創建和釋放虛擬機的函數。下面是其對應實現：

*<u>vm.c，創建新文件：</u>*

```c
#include "common.h"
#include "vm.h"

VM vm;

void initVM() {
}

void freeVM() {
}
```

> OK, calling those functions “implementations” is a stretch. We don’t have any interesting state to initialize or free yet, so the functions are empty. Trust me, we’ll get there.

好吧，把這些函數稱為“實現”有點牽強了。我們目前還沒有任何感興趣的狀態需要初始化或釋放，所以這些函數是空的。相信我，我們終會實現它的。

> The slightly more interesting line here is that declaration of `vm`. This module is eventually going to have a slew of functions and it would be a chore to pass around a pointer to the VM to all of them. Instead, we declare a single global VM object. We need only one anyway, and this keeps the code in the book a little lighter on the page.

這裏稍微有趣的一行是`vm`的聲明。這個模塊最終會有一系列的函數，如果要將一個指向VM的指針傳遞給所有的函數，那就太麻煩了。相反，我們聲明瞭一個全局VM對象。反正我們只需要一個虛擬機對象，這樣可以讓本書中的代碼在頁面上更輕便[^1]。

> Before we start pumping fun code into our VM, let’s go ahead and wire it up to the interpreter’s main entrypoint.

在我們開始向虛擬機中添加有效代碼之前，我們先將其連接到解釋器的主入口點。

*<u>main.c，在 main()方法中新增代碼：</u>*

```c
int main(int argc, const char* argv[]) {
  // 新增部分開始
  initVM();
  // 新增部分結束
  Chunk chunk;
```

> We spin up the VM when the interpreter first starts. Then when we’re about to exit, we wind it down.

當解釋器第一次啓動時，我們也啓動虛擬機。然後當我們要退出時，我們將其關閉。

*<u>main.c，在 main()方法中添加代碼：</u>*

```c
  disassembleChunk(&chunk, "test chunk");
  // 新增部分開始
  freeVM();
  // 新增部分結束
  freeChunk(&chunk);
```

> One last ceremonial obligation:

最後一項儀式性任務：

*<u>main.c，添加代碼：</u>*

```c
#include "debug.h"
// 新增部分開始
#include "vm.h"
// 新增部分結束
int main(int argc, const char* argv[]) {
```

> Now when you run clox, it starts up the VM before it creates that hand-authored chunk from the [last chapter](http://craftinginterpreters.com/chunks-of-bytecode.html#disassembling-chunks). The VM is ready and waiting, so let’s teach it to do something.

現在如果你運行clox，它會先啓動虛擬機，再創建上一章中的手寫代碼塊。虛擬機已經就緒了，我們來教它一些事情吧。

> ### 15 . 1 . 1Executing instructions

### 15.1.1 執行指令

> The VM springs into action when we command it to interpret a chunk of bytecode.

當我們命令VM解釋一個字節碼塊時，它就會開始啓動了。

*<u>main.c，在 main()方法中添加代碼：</u>*

```c
  disassembleChunk(&chunk, "test chunk");
  // 新增部分開始
  interpret(&chunk);
  // 新增部分結束
  freeVM();
```

> This function is the main entrypoint into the VM. It’s declared like so:

這個函數是進入VM的主要入口。它的聲明如下：

*<u>vm.h，在 freeVM()方法後添加：</u>*

```c
void freeVM();
// 新增部分開始
InterpretResult interpret(Chunk* chunk);
// 新增部分結束
#endif
```

> The VM runs the chunk and then responds with a value from this enum:

VM會運行字節碼塊，然後返回下面枚舉中的一個值作為響應：

*<u>vm.h，在結構體 VM後添加：</u>*

```c
} VM;
// 新增部分開始
typedef enum {
  INTERPRET_OK,
  INTERPRET_COMPILE_ERROR,
  INTERPRET_RUNTIME_ERROR
} InterpretResult;
// 新增部分結束
void initVM();
void freeVM();
```

> We aren’t using the result yet, but when we have a compiler that reports static errors and a VM that detects runtime errors, the interpreter will use this to know how to set the exit code of the process.

我們現在還不會使用這個結果，但是當我們有一個報告靜態錯誤的編譯器和檢測運行時錯誤的VM時，解釋器會通過它來知道如何設置進程的退出代碼。

> We’re inching towards some actual implementation.

我們正逐步走向一些真正的實現。

*<u>vm.c，在 freeVM()方法後添加：</u>*

```c
InterpretResult interpret(Chunk* chunk) {
  vm.chunk = chunk;
  vm.ip = vm.chunk->code;
  return run();
}
```

> First, we store the chunk being executed in the VM. Then we call `run()`, an internal helper function that actually runs the bytecode instructions. Between those two parts is an intriguing line. What is this `ip` business?

首先，我們在虛擬機中存儲正在執行的塊。然後我們調用`run()`，這是一個內部輔助函數，實際運行字節碼指令。在這兩部分之間，有一條耐人尋味的線。這個`ip`作用是什麼？

> As the VM works its way through the bytecode, it keeps track of where it is—the location of the instruction currently being executed. We don’t use a local variable inside `run()` for this because eventually other functions will need to access it. Instead, we store it as a field in VM.

當虛擬機運行字節碼時，它會記錄它在哪裏——即當前執行的指令所在的位置。我們沒有在`run()`方法中使用局部變量來進行記錄，因為最終其它函數也會訪問該值。相對地，我們將其作為一個字段存儲在VM中[^2]。

*<u>vm.h，在結構體VM中添加代碼：</u>*

```c
typedef struct {
  Chunk* chunk;
  // 新增部分開始
  uint8_t* ip;
  // 新增部分結束
} VM;
```

> Its type is a byte pointer. We use an actual real C pointer pointing right into the middle of the bytecode array instead of something like an integer index because it’s faster to dereference a pointer than look up an element in an array by index.

它的類型是一個字節指針。我們使用一個真正的C指針指向字節碼數組的中間，而不是使用類似整數索引這種方式，這是因為對指針的引用比通過索引查找數組中的一個元素要更快。

> The name “IP” is traditional, and—unlike many traditional names in CS—actually makes sense: it’s an **[instruction pointer](https://en.wikipedia.org/wiki/Program_counter)**. Almost every instruction set in the world, real and virtual, has a register or variable like this.

“IP”這個名字很傳統，而且與CS中的很多傳統名稱不同的是，它是有實際意義的：它是一個[指令指針](https://en.wikipedia.org/wiki/Program_counter)。幾乎世界上所有的指令集，不管是真實的還是虛擬的，都有一個類似的寄存器或變量[^3]。

> We initialize `ip` by pointing it at the first byte of code in the chunk. We haven’t executed that instruction yet, so `ip` points to the instruction *about to be executed*. This will be true during the entire time the VM is running: the IP always points to the next instruction, not the one currently being handled.

我們通過將`ip`指向塊中的第一個字節碼來對其初始化。我們還沒有執行該指令，所以`ip`指向*即將執行*的指令。在虛擬機執行的整個過程中都是如此：IP總是指向下一條指令，而不是當前正在處理的指令。

> The real fun happens in `run`().

真正有趣的部分在`run()`中。

*<u>vm.c，在 freeVM()方法後添加：</u>*

```c
static InterpretResult run() {
#define READ_BYTE() (*vm.ip++)

  for (;;) {
    uint8_t instruction;
    switch (instruction = READ_BYTE()) {
      case OP_RETURN: {
        return INTERPRET_OK;
      }
    }
  }

#undef READ_BYTE
}
```

> This is the single most important function in all of clox, by far. When the interpreter executes a user’s program, it will spend something like 90% of its time inside `run()`. It is the beating heart of the VM.

到目前為止，這是clox中最重要的一個函數。當解釋器執行用户的程序時，它有大約90%的時間是在`run()`中。它是虛擬機跳動的心臟。

> Despite that dramatic intro, it’s conceptually pretty simple. We have an outer loop that goes and goes. Each turn through that loop, we read and execute a single bytecode instruction.

儘管這個介紹很戲劇性，但從概念上來説很簡單。我們有一個不斷進行的外層循環。每次循環中，我們會讀取並執行一條字節碼指令。

> To process an instruction, we first figure out what kind of instruction we’re dealing with. The `READ_BYTE` macro reads the byte currently pointed at by `ip` and then advances the instruction pointer. The first byte of any instruction is the opcode. Given a numeric opcode, we need to get to the right C code that implements that instruction’s semantics. This process is called **decoding** or **dispatching** the instruction.
>

為了處理一條指令，我們首先需要弄清楚要處理的是哪種指令。`READ_BYTE`這個宏會讀取`ip`當前指向字節，然後推進指令指針[^4]。任何指令的第一個字節都是操作碼。給定一個操作碼，我們需要找到實現該指令語義的正確的C代碼。這個過程被稱為**解碼**或指令**分派**。

> We do that process for every single instruction, every single time one is executed, so this is the most performance critical part of the entire virtual machine. Programming language lore is filled with clever techniques to do bytecode dispatch efficiently, going all the way back to the early days of computers.
>

每一條指令，每一次執行時，我們都會進行這個過程，所以這是整個虛擬機性能最關鍵的部分。編程語言的傳説中充滿了高效進行字節碼分派的各種奇技淫巧[^5]，一直可以追溯到計算機的早期。

> Alas, the fastest solutions require either non-standard extensions to C, or handwritten assembly code. For clox, we’ll keep it simple. Just like our disassembler, we have a single giant `switch` statement with a case for each opcode. The body of each case implements that opcode’s behavior.

可惜的是，最快的解決方案要麼需要對C進行非標準的擴展，要麼需要手寫彙編代碼。對於clox，我們要保持簡單。就像我們的反彙編程序一樣，我們寫一個巨大的`switch`語句，其中每個case對應一個操作碼。每個case代碼體實現了操作碼的行為。

> So far, we handle only a single instruction, `OP_RETURN`, and the only thing it does is exit the loop entirely. Eventually, that instruction will be used to return from the current Lox function, but we don’t have functions yet, so we’ll repurpose it temporarily to end the execution.
>

到目前為止，我們只處理了一條指令，`OP_RETURN`，而它做的唯一的事情就是完全退出循環。最終，該指令將被用於從當前的Lox函數返回，但是我們目前還沒有函數，所以我們暫時用它來結束代碼執行。

> Let’s go ahead and support our one other instruction.
>

讓我們繼續支持另一個指令。

*<u>vm.c，在 run()方法中增加代碼：</u>*

```c
    switch (instruction = READ_BYTE()) {
      // 新增部分開始
      case OP_CONSTANT: {
        Value constant = READ_CONSTANT();
        printValue(constant);
        printf("\n");
        break;
      }
      // 新增部分結束
      case OP_RETURN: {
```

> We don’t have enough machinery in place yet to do anything useful with a constant. For now, we’ll just print it out so we interpreter hackers can see what’s going on inside our VM. That call to `printf()` necessitates an include.

我們還沒有足夠的機制來使用常量做任何有用的事。現在，我們只是把它打印出來，這樣我們這些解釋器黑客就可以看到我們的VM內部發生了什麼。調用`printf()`方法需要進行include。

*<u>vm.c，在文件頂部添加：</u>*

```c
// 新增部分開始
#include <stdio.h>
// 新增部分結束
#include "common.h"
```

> We also have a new macro to define.

我們還需要定義一個新的宏。

<u>*vm.c，在 run()方法中添加代碼：*</u>

```c
#define READ_BYTE() (*vm.ip++)
// 新增部分開始
#define READ_CONSTANT() (vm.chunk->constants.values[READ_BYTE()])
// 新增部分結束
  for (;;) {
```

> `READ_CONSTANT()` reads the next byte from the bytecode, treats the resulting number as an index, and looks up the corresponding Value in the chunk’s constant table. In later chapters, we’ll add a few more instructions with operands that refer to constants, so we’re setting up this helper macro now.

`READ_CONTANT()`從字節碼中讀取下一個字節，將得到的數字作為索引，並在代碼塊的常量表中查找相應的Value。在後面的章節中，我們將添加一些操作數指向常量的指令，所以我們現在要設置這個輔助宏。

Like the previous `READ_BYTE` macro, `READ_CONSTANT` is only used inside `run()`. To make that scoping more explicit, the macro definitions themselves are confined to that function. We define them at the beginning and—because we care—undefine them at the end.

與之前的`READ_BYTE`宏類似，`READ_CONSTANT`只會在`run()`方法中使用。為了使作用域更明確，宏定義本身要被限制在該函數中。我們在開始時定義了它們，然後因為我們比較關心，在結束時取消它們的定義[^6]。

*<u>vm.c，在 run()方法中添加：</u>*

```c
#undef READ_BYTE
// 新增部分開始
#undef READ_CONSTANT
// 新增部分結束
}
```

> ### 15 . 1 . 2 Execution tracing

### 15.1.2 執行跟蹤

> If you run clox now, it executes the chunk we hand-authored in the last chapter and spits out `1.2` to your terminal. We can see that it’s working, but that’s only because our implementation of `OP_CONSTANT` has temporary code to log the value. Once that instruction is doing what it’s supposed to do and plumbing that constant along to other operations that want to consume it, the VM will become a black box. That makes our lives as VM implementers harder.

如果現在運行clox，它會執行我們在上一章中手工編寫的字節碼塊，並向終端輸出1.2。我們可以看到它在工作，但這是因為我們在`OP_CONSTANT`的實現中，使用臨時代碼記錄了這個值。一旦該指令執行了它應做的操作，並將取得的常量傳遞給其它想要使用該常量的操作，虛擬機就會變成一個黑盒子。這使得我們作為虛擬機實現者的工作更加艱難。

> To help ourselves out, now is a good time to add some diagnostic logging to the VM like we did with chunks themselves. In fact, we’ll even reuse the same code. We don’t want this logging enabled all the time—it’s just for us VM hackers, not Lox users—so first we create a flag to hide it behind.

為了幫助我們自己解脱這種困境，現在是給虛擬機添加一些診斷性日誌的好時機，就像我們對代碼塊本身所做的那樣。事實上，我們甚至會重用相同的代碼。我們不希望一直啓用這個日誌——它只針對我們這些虛擬機開發者，而不是Lox用户——所以我們首先創建一個標誌來隱藏它。

*<u>common.h，新增代碼：</u>*

```c
#include <stdint.h>
// 新增部分開始
#define DEBUG_TRACE_EXECUTION
// 新增部分結束
#endif
```

> When this flag is defined, the VM disassembles and prints each instruction right before executing it. Where our previous disassembler walked an entire chunk once, statically, this disassembles instructions dynamically, on the fly.

定義了這個標誌之後，虛擬機在執行每條指令之前都會反彙編並將其打印出來。我們之前的反彙編程序只是靜態地遍歷一次整個字節碼塊，而這個反編譯程序則是動態地、即時地對指令進行反彙編。

*<u>vm.c，在 run()方法中新增代碼：</u>*

```c
  for (;;) {
// 新增部分開始
#ifdef DEBUG_TRACE_EXECUTION
    disassembleInstruction(vm.chunk,
                           (int)(vm.ip - vm.chunk->code));
#endif
// 新增部分結束
    uint8_t instruction;
```

> Since `disassembleInstruction()` takes an integer byte *offset* and we store the current instruction reference as a direct pointer, we first do a little pointer math to convert `ip` back to a relative offset from the beginning of the bytecode. Then we disassemble the instruction that begins at that byte.

由於 `disassembleInstruction()` 方法接收一個整數`offset`作為字節偏移量，而我們將當前指令引用存儲為一個直接指針，所以我們首先要做一個小小的指針運算，將`ip`轉換成從字節碼開始的相對偏移量。然後，我們對從該字節開始的指令進行反彙編。

> As ever, we need to bring in the declaration of the function before we can call it.

跟之前一樣，我們需要在調用函數之前先引入函數的聲明。

*<u>vm.c，新增代碼：</u>*

```c
#include "common.h"
// 新增部分開始
#include "debug.h"
// 新增部分結束
#include "vm.h"
```

> I know this code isn’t super impressive so far—it’s literally a switch statement wrapped in a `for` loop but, believe it or not, this is one of the two major components of our VM. With this, we can imperatively execute instructions. Its simplicity is a virtue—the less work it does, the faster it can do it. Contrast this with all of the complexity and overhead we had in jlox with the Visitor pattern for walking the AST.
>

我知道這段代碼到目前為止還不是很令人印象深刻——它實際上只是一個封裝在`for`循環中的switch語句，但信不信由你，這就是我們虛擬機的兩個主要組成部分之一。有了它，我們就可以命令式地執行指令。它的簡單是一種優點——它做的工作越少，就能做得越快。作為對照，可以回想一下我們在jlox中使用Visitor模式遍歷AST的複雜度和開銷。

> ## 15 . 2 A Value Stack Manipulator

## 15.2 一個值棧操作器

> In addition to imperative side effects, Lox has expressions that produce, modify, and consume values. Thus, our compiled bytecode needs a way to shuttle values around between the different instructions that need them. For example:

除了命令式的副作用外，Lox還有產生、修改和使用值的表達式。因此，我們編譯的字節碼還需要一種方法在需要值的不同指令之間傳遞它們。例如：

```
print 3 - 2;
```

> We obviously need instructions for the constants 3 and 2, the `print` statement, and the subtraction. But how does the subtraction instruction know that 3 is the minuend and 2 is the subtrahend? How does the print instruction know to print the result of that?

顯然我們需要常數3和2、`print`語句和減法對應的指令。但是減法指令如何知道3是被減數而2是減數呢？打印指令怎麼知道要打印計算結果的呢？

> To put a finer point on it, look at this thing right here:

為了説得更清楚一點，看看下面的代碼：

```c
fun echo(n) {
  print n;
  return n;
}

print echo(echo(1) + echo(2)) + echo(echo(4) + echo(5));
```

> I wrapped each subexpression in a call to `echo()` that prints and returns its argument. That side effect means we can see the exact order of operations.

我將每個子表達都包裝在對`echo()`的調用中，這個調用會打印並返回其參數。這個副作用意味着我們可以看到操作的確切順序。

> Don’t worry about the VM for a minute. Think about just the semantics of Lox itself. The operands to an arithmetic operator obviously need to be evaluated before we can perform the operation itself. (It’s pretty hard to add `a + b` if you don’t know what `a` and `b` are.) Also, when we implemented expressions in jlox, we decided that the left operand must be evaluated before the right.

暫時不要擔心虛擬機的問題。只考慮Lox本身的語義。算術運算符的操作數顯然需要在執行運算操作之前求值（如果你不知道`a`和`b`是什麼，就很難計算`a+b`）。另外，當我們在jlox中實現表達式時，我們決定了左操作數必須在右操作數之前進行求值[^7]。

> Here is the syntax tree for the `print` statement:

下面是`print`語句的語法樹：

![The AST for the example statement, with numbers marking the order that the nodes are evaluated.](15.虛擬機/ast-16511998979731.png)

> Given left-to-right evaluation, and the way the expressions are nested, any correct Lox implementation *must* print these numbers in this order:

確定了從左到右的求值順序，以及表達式嵌套方式，任何一個正確的Lox實現都*必須*按照下面的順序打印這些數字：

```c
1  // from echo(1)
2  // from echo(2)
3  // from echo(1 + 2)
4  // from echo(4)
5  // from echo(5)
9  // from echo(4 + 5)
12 // from print 3 + 9
```

> Our old jlox interpreter accomplishes this by recursively traversing the AST. It does a postorder traversal. First it recurses down the left operand branch, then the right operand, then finally it evaluates the node itself.

我們的老式jlox解釋器通過遞歸遍歷AST來實現這一點。其中使用的是後序遍歷。首先，它向下遞歸左操作數分支，然後是右操作數分支，最後計算節點本身。

> After evaluating the left operand, jlox needs to store that result somewhere temporarily while it’s busy traversing down through the right operand tree. We use a local variable in Java for that. Our recursive tree-walk interpreter creates a unique Java call frame for each node being evaluated, so we could have as many of these local variables as we needed.

在對左操作數求值之後，jlox需要將結果臨時保存在某個地方，然後再向下遍歷右操作數。我們使用Java中的一個局部變量來實現。我們的遞歸樹遍歷解釋器會為每個正在求值的節點創建一個單獨的Java調用幀，所以我們可以根據需要維護很多這樣的局部變量。

> In clox, our `run()` function is not recursive—the nested expression tree is flattened out into a linear series of instructions. We don’t have the luxury of using C local variables, so how and where should we store these temporary values? You can probably guess already, but I want to really drill into this because it’s an aspect of programming that we take for granted, but we rarely learn *why* computers are architected this way.

在clox中，我們的`run()`函數不是遞歸的——嵌套的表達式被展開成一系列線性指令。我們沒有辦法使用C語言的局部變量，那我們應該如何存儲這些臨時值呢？你可能已經猜到了，但我想真正深入研究這個問題，因為這是編程中我們習以為常的一個方面，但我們很少了解為什麼計算機是這樣架構的。

> Let’s do a weird exercise. We’ll walk through the execution of the above program a step at a time:

讓我們做一個奇怪的練習。我們來一步一步地遍歷上述程序的執行過程：

![The series of instructions with bars showing which numbers need to be preserved across which instructions.](15.虛擬機/bars-16511999147933.png)

> On the left are the steps of code. On the right are the values we’re tracking. Each bar represents a number. It starts when the value is first produced—either a constant or the result of an addition. The length of the bar tracks when a previously produced value needs to be kept around, and it ends when that value finally gets consumed by an operation.

左邊是代碼的執行步驟。右邊是我們要追蹤的值。每條槓代表一個數字。起點是數值產生時——要麼是一個常數，要麼是一個加法計算結果；槓的長度表示之前產生的值需要保留的時間；當該值最終被某個操作消費後，槓就到終點了。

> As you step through, you see values appear and then later get eaten. The longest-lived ones are the values produced from the left-hand side of an addition. Those stick around while we work through the right-hand operand expression.

隨着你不斷執行，你會看到一些數值出現，然後被消費掉。壽命最長的是加法左側產生的值。當我們在處理右邊的操作數表達式時，這些值會一直存在。

> In the above diagram, I gave each unique number its own visual column. Let’s be a little more parsimonious. Once a number is consumed, we allow its column to be reused for another later value. In other words, we take all of those gaps up there and fill them in, pushing in numbers from the right:

在上圖中，我為每個數字提供了單獨的可視化列。讓我們更簡潔一些。一旦一個數字被消費了，我們就允許它的列被其它值重用。換句話説，我們將數字從右向左推入，把上面的空隙都填上：

![Like the previous diagram, but with number bars pushed to the left, forming a stack.](15.虛擬機/bars-stacked-16511999262195.png)

> There’s some interesting stuff going on here. When we shift everything over, each number still manages to stay in a single column for its entire life. Also, there are no gaps left. In other words, whenever a number appears earlier than another, then it will live at least as long as that second one. The first number to appear is the last to be consumed. Hmm . . . last-in, first-out . . . why, that’s a stack!
>

這裏有一些有趣的事情發生了。當我們把所有數字都移動以後，每個數字在整個生命週期中仍然能保持在一列。此外，也沒有留下任何空隙。換句話説，只要一個數字比另一個數字出現得早，那麼它的壽命至少和第二個數字一樣長。第一個出現的數字是最後一個消費掉的，嗯……後進先出……哎呀，這是一個棧！

> In the second diagram, each time we introduce a number, we push it onto the stack from the right. When numbers are consumed, they are always popped off from rightmost to left.
>

在第二張圖中，每次我們生成一個數字時，都會從右邊將它壓入棧。當數字被消費時，它們也是從右向左進行彈出。

> Since the temporary values we need to track naturally have stack-like behavior, our VM will use a stack to manage them. When an instruction “produces” a value, it pushes it onto the stack. When it needs to consume one or more values, it gets them by popping them off the stack.
>

由於我們需要跟蹤的臨時值天然具有類似棧的行為，我們的虛擬機將使用棧來管理它們。當一條指令“生成”一個值時，它會把這個值壓入棧中。當它需要消費一個或多個值時，通過從棧中彈出數據來獲得這些值。

> ### 15 . 2 . 1 The VM’s Stack

### 15.2.1 虛擬機的棧

> Maybe this doesn’t seem like a revelation, but I *love* stack-based VMs. When you first see a magic trick, it feels like something actually magical. But then you learn how it works—usually some mechanical gimmick or misdirection—and the sense of wonder evaporates. There are a couple of ideas in computer science where even after I pulled them apart and learned all the ins and outs, some of the initial sparkle remained. Stack-based VMs are one of those.

也許這看起來不像是什麼新發現，但我喜歡基於棧的虛擬機。當你第一次看到一個魔術時，你會覺得它真的很神奇。但是當你瞭解到它是如何工作的——通常是一些機械式花招或誤導——驚奇的感覺就消失了。在計算機科學中，有一些理念，即使我把它們拆開並瞭解了所有的來龍去脈之後，最初的閃光點仍然存在。基於堆棧的虛擬機就是其中之一[^8]。

> As you’ll see in this chapter, executing instructions in a stack-based VM is dead simple. In later chapters, you’ll also discover that compiling a source language to a stack-based instruction set is a piece of cake. And yet, this architecture is fast enough to be used by production language implementations. It almost feels like cheating at the programming language game.

你在本章中將會看到，在基於堆棧的虛擬機中執行指令是非常簡單的。在後面的章節中，你還會發現，將源語言編譯成基於棧的指令集是小菜一碟。但是，這種架構的速度快到足以在產生式語言的實現中使用。這感覺就像是在編程語言遊戲中作弊[^9]。

> Alrighty, it’s codin’ time! Here’s the stack:

好了，編碼時間到！下面是棧：

*<u>vm.h，在結構體VM中添加代碼：</u>*

```c
typedef struct {
  Chunk* chunk;
  uint8_t* ip;
  // 新增部分開始
  Value stack[STACK_MAX];
  Value* stackTop;
  // 新增部分結束
} VM;
```

> We implement the stack semantics ourselves on top of a raw C array. The bottom of the stack—the first value pushed and the last to be popped—is at element zero in the array, and later pushed values follow it. If we push the letters of “crepe”—my favorite stackable breakfast item—onto the stack, in order, the resulting C array looks like this:

我們在一個原生的C數組上自己實現了棧語義。棧的底部——第一個推入的值和最後一個被彈出的值——位於數組中的零號位置，後面推入的值跟在它後面。如果我們把“crepe”幾個字母按順序推入棧中，得到的C數組看起來像這樣：

![An array containing the letters in 'crepe' in order starting at element 0.](15.虛擬機/array.png)

> Since the stack grows and shrinks as values are pushed and popped, we need to track where the top of the stack is in the array. As with `ip`, we use a direct pointer instead of an integer index since it’s faster to dereference the pointer than calculate the offset from the index each time we need it.

由於棧會隨着值的壓入和彈出而伸縮，我們需要跟蹤棧的頂部在數組中的位置。和`ip`一樣，我們使用一個直接指針而不是整數索引，因為每次我們需要使用它時，解引用比計算索引的偏移量更快。

> The pointer points at the array element just *past* the element containing the top value on the stack. That seems a little odd, but almost every implementation does this. It means we can indicate that the stack is empty by pointing at element zero in the array.

指針指向數組中棧頂元素的下一個元素位置，這看起來有點奇怪，但幾乎每個實現都會這樣做。這意味着我們可以通過指向數組中的零號元素來表示棧是空的。

![An empty array with stackTop pointing at the first element.](15.虛擬機/stack-empty.png)

> If we pointed to the top element, then for an empty stack we’d need to point at element -1. That’s undefined in C. As we push values onto the stack . . .

如果我們指向棧頂元素，那麼對於空棧，我們就需要指向-1位置的元素[^10]。這在C語言中是沒有定義的。當我們把值壓入棧時：

![An array with 'c' at element zero.](15.虛擬機/stack-c.png)

>  . . . `stackTop` always points just past the last item.

`stackTop`一直會超過棧中的最後一個元素。

![An array with 'c', 'r', 'e', 'p', and 'e' in the first five elements.](15.虛擬機/stack-crepe.png)

> I remember it like this: `stackTop` points to where the next value to be pushed will go. The maximum number of values we can store on the stack (for now, at least) is:

我是這樣記的：`stackTop`指向下一個值要被壓入的位置。我們在棧中可以存儲的值的最大數量（至少目前是這樣）為：

*<u>vm.h，添加代碼：</u>*

```c
#include "chunk.h"
// 新增部分開始
#define STACK_MAX 256
// 新增部分結束
typedef struct {
```

> Giving our VM a fixed stack size means it’s possible for some sequence of instructions to push too many values and run out of stack space—the classic “stack overflow”. We could grow the stack dynamically as needed, but for now we’ll keep it simple. Since VM uses Value, we need to include its declaration.

給我們的虛擬機一個固定的棧大小，意味着某些指令系列可能會壓入太多的值並耗盡棧空間——典型的“堆棧溢出”。我們可以根據需要動態地增加棧，但是現在我們還是保持簡單。因為VM中會使用Value，我們需要包含它的聲明。

*<u>vm.h，添加代碼：</u>*

```c
#include "chunk.h"
// 新增部分開始
#include "value.h"
// 新增部分結束
#define STACK_MAX 256
```

> Now that VM has some interesting state, we get to initialize it.

現在，虛擬機中有了一些有趣的狀態，我們要對它進行初始化。

*<u>vm.c，在 initVM()中添加代碼：</u>*

```c
void initVM() {
  // 新增部分開始
  resetStack();
  // 新增部分結束
}
```

> That uses this helper function:

其中使用了這個輔助函數：

*<u>vm.c，在變量 vm後添加：</u>*

```c
static void resetStack() {
  vm.stackTop = vm.stack;
}
```

> Since the stack array is declared directly inline in the VM struct, we don’t need to allocate it. We don’t even need to clear the unused cells in the array—we simply won’t access them until after values have been stored in them. The only initialization we need is to set `stackTop` to point to the beginning of the array to indicate that the stack is empty.

因為棧數組是直接在VM結構體中內聯聲明的，所以我們不需要為其分配空間。我們甚至不需要清除數組中不使用的單元——我們只有在值存入之後才會訪問它們。我們需要的唯一的初始化操作就是將`stackTop`指向數組的起始位置，以表明棧是空的。

> The stack protocol supports two operations:

棧協議支持兩種操作：

*<u>vm.h，在 interpret()方法後添加：</u>*

```c
InterpretResult interpret(Chunk* chunk);
// 新增部分開始
void push(Value value);
Value pop();
// 新增部分結束
#endif
```

> You can push a new value onto the top of the stack, and you can pop the most recently pushed value back off. Here’s the first function:

你可以把一個新值壓入棧頂，你也可以把最近壓入的值彈出。下面是第一個函數：

*<u>vm.c，在 freeVM()方法後添加：</u>*

```c
void push(Value value) {
  *vm.stackTop = value;
  vm.stackTop++;
}
```

> If you’re rusty on your C pointer syntax and operations, this is a good warm-up. The first line stores `value` in the array element at the top of the stack. Remember, `stackTop` points just *past* the last used element, at the next available one. This stores the value in that slot. Then we increment the pointer itself to point to the next unused slot in the array now that the previous slot is occupied.

如果你對C指針的語法和操作感到生疏，這是一個很好的熟悉的機會。第一行在棧頂的數組元素中存儲`value`。記住，`stackTop`剛剛跳過上次使用的元素，即下一個可用的元素。這裏把值存儲在該元素槽中。接着，因為上一個槽被佔用了，我們增加指針本身，指向數組中下一個未使用的槽。

> Popping is the mirror image.

彈出正好是壓入的鏡像操作。

*<u>vm.c，在 push()方法後添加代碼：</u>*

```c
Value pop() {
  vm.stackTop--;
  return *vm.stackTop;
}
```

> First, we move the stack pointer *back* to get to the most recent used slot in the array. Then we look up the value at that index and return it. We don’t need to explicitly “remove” it from the array—moving `stackTop` down is enough to mark that slot as no longer in use.

首先，我們將棧指針回退到數組中最近使用的槽。然後，我們查找該索引處的值並將其返回。我們不需要顯式地將其從數組中“移除”——將`stackTop`下移就足以將該槽標記為不再使用了。

> ### 15 . 2 . 2 Stack tracing

### 15.2.2 棧跟蹤

> We have a working stack, but it’s hard to *see* that it’s working. When we start implementing more complex instructions and compiling and running larger pieces of code, we’ll end up with a lot of values crammed into that array. It would make our lives as VM hackers easier if we had some visibility into the stack.

我們有了一個工作的棧，但是很難看出它在工作。當我們開始實現更復雜的指令，編譯和運行更大的代碼片段時，最終會在這個數組中塞入很多值。如果我們對棧有一定的可見性，那麼作為虛擬機開發者，我們就會更輕鬆。

> To that end, whenever we’re tracing execution, we’ll also show the current contents of the stack before we interpret each instruction.

為此，每當我們追蹤執行情況時，我們也會在解釋每條指令之前展示棧中的當前內容。

*<u>vm.c，在 run()方法中添加代碼：</u>*

```c
#ifdef DEBUG_TRACE_EXECUTION
// 新增部分開始
    printf("          ");
    for (Value* slot = vm.stack; slot < vm.stackTop; slot++) {
      printf("[ ");
      printValue(*slot);
      printf(" ]");
    }
    printf("\n");
// 新增部分結束
    disassembleInstruction(vm.chunk,
```

> We loop, printing each value in the array, starting at the first (bottom of the stack) and ending when we reach the top. This lets us observe the effect of each instruction on the stack. The output is pretty verbose, but it’s useful when we’re surgically extracting a nasty bug from the bowels of the interpreter.

我們循環打印數組中的每個值，從第一個值開始（棧底），到棧頂結束。這樣我們可以觀察到每條指令對棧的影響。這個輸出會相當冗長，但是從我們在解釋器中遇到令人討厭的錯誤時，這就會很有用了。

> Stack in hand, let’s revisit our two instructions. First up:

堆棧在手，讓我們重新審視一下目前的兩條指令。首先是：

*<u>vm.c，在 run()方法中替換兩行：</u>*

```c
      case OP_CONSTANT: {
        Value constant = READ_CONSTANT();
        // 新增部分開始
        push(constant);
        // 新增部分結束
        break;
```

> In the last chapter, I was hand-wavey about how the `OP_CONSTANT` instruction “loads” a constant. Now that we have a stack you know what it means to actually produce a value: it gets pushed onto the stack.

在上一節中，我粗略介紹了`OP_CONSTANT`指令是如何“加載”一個常量的。現在我們有了一個堆棧，你就知道產生一個值實際上意味着什麼：將它壓入棧。

*<u>vm.c，在 run()方法中添加代碼：</u>*

```c
      case OP_RETURN: {
        // 新增部分開始
        printValue(pop());
        printf("\n");
        // 新增部分結束
        return INTERPRET_OK;
```

> Then we make `OP_RETURN` pop the stack and print the top value before exiting. When we add support for real functions to clox, we’ll change this code. But, for now, it gives us a way to get the VM executing simple instruction sequences and displaying the result.

接下來，我們讓`OP_RETURN`在退出之前彈出棧頂值並打印。等到我們在clox中添加對真正的函數的支持時，我們將會修改這段代碼。但是，目前來看，我們可以使用這種方法讓VM執行簡單的指令序列並顯示結果。

> ## 15 . 3 An Arithmetic Calculator

## 15.3 數學計算器

> The heart and soul of our VM are in place now. The bytecode loop dispatches and executes instructions. The stack grows and shrinks as values flow through it. The two halves work, but it’s hard to get a feel for how cleverly they interact with only the two rudimentary instructions we have so far. So let’s teach our interpreter to do arithmetic.

我們的虛擬機的核心和靈魂現在都已經就位了。字節碼循環分派和執行指令。棧堆隨着數值的流動而增長和收縮。這兩部分都在工作，但僅憑我們目前的兩條基本指令，很難感受到它們如何巧妙地互動。所以讓我們教解釋器如何做算術。

We’ll start with the simplest arithmetic operation, unary negation.

我們從最簡單的算術運算開始，即一元取負。

```c
var a = 1.2;
print -a; // -1.2.
```

> The prefix `-` operator takes one operand, the value to negate. It produces a single result. We aren’t fussing with a parser yet, but we can add the bytecode instruction that the above syntax will compile to.

前綴的`-`運算符接受一個操作數，也就是要取負的值。它只產生一個結果。我們還沒有對解析器進行處理，但可以添加上述語法編譯後對應的字節碼指令。

*<u>chunk.h，在枚舉 OpCode中添加代碼：</u>*

```c
  OP_CONSTANT,
  // 新增部分開始
  OP_NEGATE,
  // 新增部分結束
  OP_RETURN,
```

> We execute it like so:

我們這樣執行它：

*<u>vm.c，在 run()方法中添加代碼：</u>*

```c
      }
      // 新增部分開始
      case OP_NEGATE:   push(-pop()); break;
      // 新增部分結束
      case OP_RETURN: {
```

> The instruction needs a value to operate on, which it gets by popping from the stack. It negates that, then pushes the result back on for later instructions to use. Doesn’t get much easier than that. We can disassemble it too.

該指令需要操作一個值，該值通過彈出棧獲得。它對該值取負，然後把結果重新壓入棧，以便後面的指令使用。沒有什麼比這更簡單的了。我們也可以對其反彙編：

*<u>debug.c，在 disassembleInstruction()方法中添加代碼：</u>*

```c
    case OP_CONSTANT:
      return constantInstruction("OP_CONSTANT", chunk, offset);
    // 新增部分開始
    case OP_NEGATE:
      return simpleInstruction("OP_NEGATE", offset);
    // 新增部分結束
    case OP_RETURN:
```

> And we can try it out in our test chunk.

我們可以在測試代碼中試一試。

*<u>main.c，在 main()方法中添加代碼：</u>*

```c
  writeChunk(&chunk, constant, 123);
  // 新增部分開始
  writeChunk(&chunk, OP_NEGATE, 123);
  // 新增部分結束
  writeChunk(&chunk, OP_RETURN, 123);
```

> After loading the constant, but before returning, we execute the negate instruction. That replaces the constant on the stack with its negation. Then the return instruction prints that out:

在加載常量之後，返回之前，我們會執行取負指令。這條指令會將棧中的常量替換為其對應的負值。然後返回指令會打印出：

```c
-1.2
```

> Magical!

神奇！

> ### 15 . 3 . 1 Binary operators

### 15.3.1 二元操作符

> OK, unary operators aren’t *that* impressive. We still only ever have a single value on the stack. To really see some depth, we need binary operators. Lox has four binary arithmetic operators: addition, subtraction, multiplication, and division. We’ll go ahead and implement them all at the same time.

好吧，一元運算符並沒有那麼令人印象深刻。我們的棧中仍然只有一個值。要真正看到一些深度，我們需要二元運算符。Lox中有四個二進制算術運算符：加、減、乘、除。我們接下來會同時實現它們。

*<u>chunk.h，在枚舉OpCode中添加代碼：</u>*

```c
  OP_CONSTANT,
  // 新增部分開始
  OP_ADD,
  OP_SUBTRACT,
  OP_MULTIPLY,
  OP_DIVIDE,
  // 新增部分結束
  OP_NEGATE,
```

> Back in the bytecode loop, they are executed like this:

回到字節碼循環中，它們是這樣執行的：

*<u>vm.c，在run()方法中添加代碼：</u>*

```c
      }
      // 新增部分開始
      case OP_ADD:      BINARY_OP(+); break;
      case OP_SUBTRACT: BINARY_OP(-); break;
      case OP_MULTIPLY: BINARY_OP(*); break;
      case OP_DIVIDE:   BINARY_OP(/); break;
      // 新增部分結束
      case OP_NEGATE:   push(-pop()); break;
```

> The only difference between these four instructions is which underlying C operator they ultimately use to combine the two operands. Surrounding that core arithmetic expression is some boilerplate code to pull values off the stack and push the result. When we later add dynamic typing, that boilerplate will grow. To avoid repeating that code four times, I wrapped it up in a macro.

這四條指令之間唯一的區別是，它們最終使用哪一個底層C運算符來組合兩個操作數。圍繞這個核心算術表達式的是一些模板代碼，用於從棧中獲取數值，並將結果結果壓入棧中。等我們後面添加動態類型時，這些模板代碼會增加。為了避免這些代碼重複出現四次，我將它包裝在一個宏中。

*<u>vm.c，在 run()方法中添加代碼：</u>*

```c
#define READ_CONSTANT() (vm.chunk->constants.values[READ_BYTE()])
// 新增部分開始
#define BINARY_OP(op) \
    do { \
      double b = pop(); \
      double a = pop(); \
      push(a op b); \
    } while (false)
// 新增部分結束
  for (;;) {
```

> I admit this is a fairly adventurous use of the C preprocessor. I hesitated to do this, but you’ll be glad in later chapters when we need to add the type checking for each operand and stuff. It would be a chore to walk you through the same code four times.

我承認這是對C預處理器的一次相當大膽的使用[^11]。我曾猶豫過要不要這麼做，但在後面的章節中，等到我們需要為每個操作數和其它內容添加類型檢查時，你就會高興的。如果把相同的代碼遍歷四遍就太麻煩了。

> If you aren’t familiar with the trick already, that outer `do while` loop probably looks really weird. This macro needs to expand to a series of statements. To be careful macro authors, we want to ensure those statements all end up in the same scope when the macro is expanded. Imagine if you defined:

如果你對這個技巧還不熟悉，那麼外層的`do while`循環可能看起來非常奇怪。這個宏需要擴展為一系列語句。作為一個謹慎的宏作者，我們要確保當宏展開時，這些語句都在同一個作用域內。想象一下，如果你定義了：

```c
#define WAKE_UP() makeCoffee(); drinkCoffee();
```

> And then used it like:

然後這樣使用它：

```c
if (morning) WAKE_UP();
```

> The intent is to execute both statements of the macro body only if `morning` is true. But it expands to:

其本意是在`morning`為true時執行這兩個語句。但是宏展開結果為：

```c
if (morning) makeCoffee(); drinkCoffee();;
```

> Oops. The `if` attaches only to the *first* statement. You might think you could fix this using a block.

哎呀。`if`只關聯了第一條語句。您可能認為可以用代碼塊解決這個問題。

```c
#define WAKE_UP() { makeCoffee(); drinkCoffee(); }
```

> That’s better, but you still risk:

這樣好一點，但還是有風險：

```c
if (morning)
  WAKE_UP();
else
  sleepIn();
```

> Now you get a compile error on the `else` because of that trailing `;` after the macro’s block. Using a `do while` loop in the macro looks funny, but it gives you a way to contain multiple statements inside a block that *also* permits a semicolon at the end.

現在你會在`else`子句遇到編譯錯誤，因為在宏代碼塊後面有個`;`。在宏中使用`do while`循環看起來很滑稽，但它提供了一種方法，可以在一個代碼塊中包含多個語句，並且允許在末尾使用分號。

> Where were we? Right, so what the body of that macro does is straightforward. A binary operator takes two operands, so it pops twice. It performs the operation on those two values and then pushes the result.

我們説到哪裏了？對了，這個宏的主體所做的事情很直接。一個二元運算符接受兩個操作數，因此會彈出棧兩次，對這兩個值執行操作，然後將結果壓入棧。

> Pay close attention to the *order* of the two pops. Note that we assign the first popped operand to `b`, not `a`. It looks backwards. When the operands themselves are calculated, the left is evaluated first, then the right. That means the left operand gets pushed before the right operand. So the right operand will be on top of the stack. Thus, the first value we pop is `b`.

請密切注意這兩次彈出棧的順序。注意，我們將第一個彈出的操作數賦值給`b`，而不是`a`。在對操作數求值時，先計算左操作數，再計算右操作數。這意味着左操作數會在右操作數之前被壓入棧，所以右側的操作數在棧頂。因此，我們彈出的第一個值屬於`b`。

> For example, if we compile `3 - 1`, the data flow between the instructions looks like so:

舉例來説，如果我們編譯`3-1`，指令之間的數據流看起來是這樣的：

![A sequence of instructions with the stack for each showing how pushing and then popping values reverses their order.](15.虛擬機/reverse.png)

> As we did with the other macros inside `run()`, we clean up after ourselves at the end of the function.

正如我們在`run()`內的其它宏中做的那樣，我們在函數結束時自行清理。

*<u>vm.c，在run()方法中添加代碼：</u>*

```c
#undef READ_CONSTANT
// 新增部分開始
#undef BINARY_OP
// 新增部分結束
}
```

> Last is disassembler support.

最後是反彙編器的支持。

*<u>debug.c，在 disassembleInstruction()方法中添加代碼：</u>*

```c
    case OP_CONSTANT:
      return constantInstruction("OP_CONSTANT", chunk, offset);
    // 新增部分開始
    case OP_ADD:
      return simpleInstruction("OP_ADD", offset);
    case OP_SUBTRACT:
      return simpleInstruction("OP_SUBTRACT", offset);
    case OP_MULTIPLY:
      return simpleInstruction("OP_MULTIPLY", offset);
    case OP_DIVIDE:
      return simpleInstruction("OP_DIVIDE", offset);
    // 新增部分結束
    case OP_NEGATE:
```

> The arithmetic instruction formats are simple, like `OP_RETURN`. Even though the arithmetic *operators* take operands—which are found on the stack—the arithmetic *bytecode instructions* do not.

算術指令的格式很簡單，類似於`OP_RETURN`。即使算術運算符需要操作數（從堆棧中獲取），算術的*字節碼指令*也不需要。

> Let’s put some of our new instructions through their paces by evaluating a larger expression:

我們通過計算一個更大的表達式來檢驗一些新指令。

![The expression being evaluated: -((1.2 + 3.4) / 5.6)](15.虛擬機/chunk.png)

> Building on our existing example chunk, here’s the additional instructions we need to hand-compile that AST to bytecode.

在我們現有的示例代碼塊基礎上，下面是我們將AST手動編譯為字節碼後需要添加的指令。

*<u>main.c，在main()方法中添加代碼：</u>*

```c
  int constant = addConstant(&chunk, 1.2);
  writeChunk(&chunk, OP_CONSTANT, 123);
  writeChunk(&chunk, constant, 123);
  // 新增部分開始
  constant = addConstant(&chunk, 3.4);
  writeChunk(&chunk, OP_CONSTANT, 123);
  writeChunk(&chunk, constant, 123);

  writeChunk(&chunk, OP_ADD, 123);

  constant = addConstant(&chunk, 5.6);
  writeChunk(&chunk, OP_CONSTANT, 123);
  writeChunk(&chunk, constant, 123);

  writeChunk(&chunk, OP_DIVIDE, 123);
  // 新增部分結束
  writeChunk(&chunk, OP_NEGATE, 123);

  writeChunk(&chunk, OP_RETURN, 123);
```

> The addition goes first. The instruction for the left constant, 1.2, is already there, so we add another for 3.4. Then we add those two using `OP_ADD`, leaving it on the stack. That covers the left side of the division. Next we push the 5.6, and divide the result of the addition by it. Finally, we negate the result of that.

首先進行加法運算。左邊的常數1.2的指令已經存在了，所以我們再加一條3.4的指令。然後我們用`OP_ADD`把這兩個值加起來，將結果壓入堆棧中。這樣就完成了除法的左操作數。接下來，我們壓入5.6，並用加法的結果除以它。最後，我們對結果取負。

> Note how the output of the `OP_ADD` implicitly flows into being an operand of `OP_DIVIDE` without either instruction being directly coupled to each other. That’s the magic of the stack. It lets us freely compose instructions without them needing any complexity or awareness of the data flow. The stack acts like a shared workspace that they all read from and write to.

注意，`OP_ADD`的輸出如何隱式地變成了`OP_DIVIDE`的一個操作數，而這兩條指令都沒有直接耦合在一起。這就是堆棧的魔力。他讓我們可以自由地編寫指令，而無需任何複雜性或對於數據流的感知。堆棧就像一個共享工作區，它們都可以從中讀取和寫入。

> In this tiny example chunk, the stack still only gets two values tall, but when we start compiling Lox source to bytecode, we’ll have chunks that use much more of the stack. In the meantime, try playing around with this hand-authored chunk to calculate different nested arithmetic expressions and see how values flow through the instructions and stack.

在這個小示例中，堆棧仍然只有兩個值，但當我們開始將Lox源代碼編譯為字節碼時，我們的代碼塊將使用更多的堆棧。同時，你可以試着用這個手工編寫的字節碼塊來計算不同的嵌套算術表達式，看看數值是如何在指令和棧中流動的。

> You may as well get it out of your system now. This is the last chunk we’ll build by hand. When we next revisit bytecode, we will be writing a compiler to generate it for us.

你不妨現在就把這塊代碼從系統中拿出來。這是我們手工構建的最後一個字節碼塊。當我們下次使用字節碼時，我們將編寫一個編譯器來生成。



[^1]: 選擇使用靜態的VM實例是本書的一個讓步，但對於真正的語言實現來説，不一定是合理的工程選擇。如果你正在構建一個旨在嵌入其它主機應用程序中的虛擬機，那麼如果你顯式地獲取一個VM指針並傳遞該指針，則會為主機提供更大的靈活性。這樣，主機應用程序就可以控制何時何地為虛擬機分配內存，並行地運行多個虛擬機，等等。我在這裏使用的是一個全局變量，你所聽説過的關於全局變量的一切壞消息在大型編程中仍然是正確的。但是，當你想在一本書中保持代碼簡潔時，就另當別論了。
[^2]: 如果我們想要在字節碼解釋器中再壓榨出一點性能，我們可以將`ip`保存到一個局部變量中。該值在運行過程中會被頻繁修改，所以我們希望C編譯器將其放在寄存器中。
[^3]: x86、x64和CLR稱其為 "IP"。68k、PowerPC、ARM、p-code和JVM稱它為 "PC"，意為程序計數器。

[^4]: 請注意，一旦我們讀取了操作碼，`ip`就會推進了。所以，再次説一下，`ip`指向的是將要使用的操作碼的下一個字節。
[^5]: 如果你想了解其中一些技術，可以搜索“direct threaded code”、“jump table” 和 “computed goto”。
[^6]: 顯示地取消這些宏定義，可能會顯得毫無必要，但C語言往往會懲罰粗心的用户，而C語言的預處理器更是如此。
[^7]: 我們可以不指定計算順序，讓每個語言實現自行決定。這就為優化編譯器重新排列算術表達式以提高效率留下了餘地，即使是在操作數有明顯副作用的情況下也是如此。C和Scheme沒有指定求值順序。Java規定了從左到右進行求值，就跟我們在Lox中所做的一樣。</br>我認為指定這樣的內容通常對用户更好。當表達式沒有按照用户的直覺順序進行求值時——可能在不同的實現中會有不同的順序——要想弄清楚發生了什麼，可能是非常痛苦的。
[^8]: 堆——[數據結構](https://en.wikipedia.org/wiki/Heap_(data_structure))，不是[內存管理](https://en.wikipedia.org/wiki/Memory_management#HEAP)——是另一個。還有Vaughan Pratt自頂向下的運算符優先級解析方案，我們會在適當的時候學習。
[^9]: 稍微説明一下：基於堆棧的解釋器並不是銀彈。它們通常是夠用的，但是JVM、CLR和JavaScript的現代化實現中都使用了複雜的[即時編譯](https://en.wikipedia.org/wiki/Just-in-time_compilation)管道，在動態中生成*更快的*本地代碼。
[^10]: 聰明的讀者，你可能會問，那如果棧滿了怎麼辦？C標準比您領先一步。C語言中允許數組指針正好指向數組末尾的下一個位置。
[^11]: 你之前知道可以把操作符作為參數傳遞給宏嗎？現在你知道了。預處理器並不關心操作符是不是C語言中的類，在它看來，這一切都只是文本符號。我知道，你已經感受到濫用預處理器的誘惑了，不是嗎？

------

> ## CHALLENGES

## 習題

1. > What bytecode instruction sequences would you generate for the following expressions:

   你會為以下表達式生成什麼樣的*字節碼*指令序列：

   ```c
   1 * 2 + 3
   1 + 2 * 3
   3 - 2 - 1
   1 + 2 * 3 - 4 / -5
   ```

   > (Remember that Lox does not have a syntax for negative number literals, so the `-5` is negating the number 5.)

   （請記得，Lox語法中沒有負數字面量，所以`-5`是對數字5取負）

2. > If we really wanted a minimal instruction set, we could eliminate either `OP_NEGATE` or `OP_SUBTRACT`. Show the bytecode instruction sequence you would generate for:

   如果我們真的想要一個最小指令集，我們可以取消`OP_NEGATE`或`OP_SUBTRACT`。請寫出你為下面的表達式生成的字節碼指令序列：

   ```c
   4 - 3 * -2
   ```

   > First, without using `OP_NEGATE`. Then, without using `OP_SUBTRACT`.
   >
   > Given the above, do you think it makes sense to have both instructions? Why or why not? Are there any other redundant instructions you would consider including?

   首先是不能使用 `OP_NEGATE`。然後，試一下不使用`OP_SUBTRACT`。

   綜上所述，你認為同時擁有這兩條指令有意義嗎？為什麼呢？還有沒有其它指令可以考慮加入？

3. > Our VM’s stack has a fixed size, and we don’t check if pushing a value overflows it. This means the wrong series of instructions could cause our interpreter to crash or go into undefined behavior. Avoid that by dynamically growing the stack as needed.
   >
   > What are the costs and benefits of doing so?

   我們虛擬機的堆棧有一個固定大小，而且我們不會檢查壓入一個值是否會溢出。這意味着錯誤的指令序列可能會導致我們的解釋器崩潰或進入未定義的行為。通過根據需求動態增長堆棧來避免這種情況。

   這樣做的代價和好處是什麼？

4. > To interpret `OP_NEGATE`, we pop the operand, negate the value, and then push the result. That’s a simple implementation, but it increments and decrements `stackTop` unnecessarily, since the stack ends up the same height in the end. It might be faster to simply negate the value in place on the stack and leave `stackTop` alone. Try that and see if you can measure a performance difference.
   >
   > Are there other instructions where you can do a similar optimization?

   為了解釋`OP_NEGATE`，我們彈出操作數，對值取負，然後將結果壓入棧。這是一個簡單的實現，但它對`stackTop`進行了不必要的增減操作，因為棧最終的高度是相同的。簡單地對棧中的值取負而不處理`stackTop`可能會更快。試一下，看看你是否能測出性能差異。

   是否有其它指令可以做類似的優化？

---

> ## DESIGN NOTE: REGISTER-BASED BYTECODE

## 設計筆記：基於寄存器的字節碼

> For the remainder of this book, we’ll meticulously implement an interpreter around a stack-based bytecode instruction set. There’s another family of bytecode architectures out there—*register-based*. Despite the name, these bytecode instructions aren’t quite as difficult to work with as the registers in an actual chip like x64. With real hardware registers, you usually have only a handful for the entire program, so you spend a lot of effort [trying to use them efficiently and shuttling stuff in and out of them](https://en.wikipedia.org/wiki/Register_allocation).
>
> In a register-based VM, you still have a stack. Temporary values still get pushed onto it and popped when no longer needed. The main difference is that instructions can read their inputs from anywhere in the stack and can store their outputs into specific stack slots.
>
> Take this little Lox script:
>
> ```
> var a = 1;
> var b = 2;
> var c = a + b;
> ```
>
> In our stack-based VM, the last statement will get compiled to something like:
>
> ```
> load <a>  // Read local variable a and push onto stack.
> load <b>  // Read local variable b and push onto stack.
> add       // Pop two values, add, push result.
> store <c> // Pop value and store in local variable c.
> ```
>
> (Don’t worry if you don’t fully understand the load and store instructions yet. We’ll go over them in much greater detail [when we implement variables](http://www.craftinginterpreters.com/global-variables.html).) We have four separate instructions. That means four times through the bytecode interpret loop, four instructions to decode and dispatch. It’s at least seven bytes of code—four for the opcodes and another three for the operands identifying which locals to load and store. Three pushes and three pops. A lot of work!
>
> In a register-based instruction set, instructions can read from and store directly into local variables. The bytecode for the last statement above looks like:
>
> ```
> add <a> <b> <c> // Read values from a and b, add, store in c.
> ```
>
> The add instruction is bigger—it has three instruction operands that define where in the stack it reads its inputs from and writes the result to. But since local variables live on the stack, it can read directly from `a` and `b` and then store the result right into `c`.
>
> There’s only a single instruction to decode and dispatch, and the whole thing fits in four bytes. Decoding is more complex because of the additional operands, but it’s still a net win. There’s no pushing and popping or other stack manipulation.
>
> The main implementation of Lua used to be stack-based. For Lua 5.0, the implementers switched to a register instruction set and noted a speed improvement. The amount of improvement, naturally, depends heavily on the details of the language semantics, specific instruction set, and compiler sophistication, but that should get your attention.
>
> The Lua dev team—Roberto Ierusalimschy, Waldemar Celes, and Luiz Henrique de Figueiredo—wrote a *fantastic* paper on this, one of my all time favorite computer science papers, “[The Implementation of Lua 5.0](https://www.lua.org/doc/jucs05.pdf)” (PDF).
>
> That raises the obvious question of why I’m going to spend the rest of the book doing a stack-based bytecode. Register VMs are neat, but they are quite a bit harder to write a compiler for. For what is likely to be your very first compiler, I wanted to stick with an instruction set that’s easy to generate and easy to execute. Stack-based bytecode is marvelously simple.
>
> It’s also *much* better known in the literature and the community. Even though you may eventually move to something more advanced, it’s a good common ground to share with the rest of your language hacker peers.

在本書的其餘部分，我們將圍繞基於堆棧的字節碼指令集精心實現一個解釋器。此外還有另一種字節碼架構——基於寄存器。儘管名稱如此，但這些字節碼指令並不像x64這樣的真實芯片中的寄存器那樣難以操作。對於真正的硬件寄存器，整個程序通常只用少數幾個，所以你[要花很多精力來有效地使用它們，並把數據存入或取出](https://en.wikipedia.org/wiki/Register_allocation)。（基於寄存器的字節碼更接近於SPARC芯片支持的寄存器窗口）

在一個基於寄存器的虛擬機中，仍然有一個棧。臨時值還是被壓入棧中，當不再需要時再被彈出。主要的區別是，指令可以從棧的任意位置讀取它們的輸入值，並可以將它們的輸出值存儲到任一指定的槽中。

以Lox腳本為例：

```c
var a = 1;
var b = 2;
var c = a + b;
```

在我們基於堆棧的虛擬機中，最後一條指令的編譯結果類似於：

```c
load <a>  // 讀取局部變量a，並將其壓入棧
load <b>  // 讀取局部變量b，並將其壓入棧
add       // 彈出兩個值，相加，將結果壓入棧
store <c> // 彈出值，並存入局部變量c
```

（如果你還沒有完全理解加載load和存儲store指令，也不用擔心。我們會在實現變量時詳細地討論它們）我們有四條獨立的指令，這意味着會有四次字節碼解釋循環，四條指令需要解碼和調度。這至少包含7個字節的代碼——四個字節是操作碼，另外三個是操作數，用於標識要加載和存儲哪些局部變量。三次入棧，三次出棧，工作量很大！

在基於寄存器的指令集中，指令可以直接對局部變量進行讀取和存儲。上面最後一條語句的字節碼如下所示：

```c
add <a> <b> <c> // 從a和b中讀取值，相加，並存儲到c中
```

add指令比之前更大——有三個指令操作數，定義了從堆棧的哪個位置讀取輸入，並將結果寫入哪個位置。但由於局部變量在堆棧中，它可以直接從`a`和`b`中讀取數據，如何將結果存入`c`中。

只有一條指令需要解碼和調度，整個程序只需要四個字節。由於有了額外的操作數，解碼變得更加複雜，但相比之下它仍然是更優秀的。沒有壓入和彈出或其它堆棧操作。

Lua的實現曾經是基於堆棧的。到了Lua 5.0，實現切換到了寄存器指令集，並注意到速度有所提高。當然，提高的幅度很大程度上取決於語言語義的細節、特定指令集和編譯器複雜性，但這應該引起你的注意。

這就引出了一個顯而易見的問題：我為什麼要在本書的剩餘部分做一個基於堆棧的字節碼。寄存器虛擬機是很好的，但要為它們編寫編譯器卻相當困難。考慮到這可能是你寫的第一個編譯器，我想堅持使用一個易於生成和易於執行的指令集。基於堆棧的字節碼是非常簡單的。

它的文獻和社區中也更廣為人知。即使你最終可能會轉向更高級的東西，這也是一個你可以與其他語言開發者分享的很好的共同點。
