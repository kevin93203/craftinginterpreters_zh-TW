# 25. Closures 閉包

> As the man said, for every complex problem there’s a simple solution, and it’s wrong.
>
> ​													——Umberto Eco, *Foucault’s Pendulum*

正如那人所説，每一個複雜的問題都有一個簡單的解決方案，而且是錯誤的。（翁貝託·艾柯，《傅科擺》）

> Thanks to our diligent labor in [the last chapter](http://www.craftinginterpreters.com/calls-and-functions.html), we have a virtual machine with working functions. What it lacks is closures. Aside from global variables, which are their own breed of animal, a function has no way to reference a variable declared outside of its own body.

感謝我們在上一章的辛勤勞動，我們得到了一個擁有函數的虛擬機。現在虛擬機缺失的是閉包。除了全局變量（也就是函數的同類）之外，函數沒有辦法引用其函數體之外聲明的變量。

```javascript
var x = "global";
fun outer() {
  var x = "outer";
  fun inner() {
    print x;
  }
  inner();
}
outer();
```

> Run this example now and it prints “global”. It’s supposed to print “outer”. To fix this, we need to include the entire lexical scope of all surrounding functions when resolving a variable.

現在運行這個示例，它打印的是“global”。但它應該打印“outer”。為了解決這個問題，我們需要在解析變量時涵蓋所有外圍函數的整個詞法作用域。

> This problem is harder in clox than it was in jlox because our bytecode VM stores locals on a stack. We used a stack because I claimed locals have stack semantics—variables are discarded in the reverse order that they are created. But with closures, that’s only *mostly* true.

這個問題在clox中比在jlox中更難解決，因為我們的字節碼虛擬機將局部變量存儲在棧中。我們使用堆棧是因為，我聲稱局部變量具有棧語義——變量被丟棄的順序與創建的順序正好相反。但對於閉包來説，這隻在大部分情況下是正確的。

```javascript
fun makeClosure() {
  var local = "local";
  fun closure() {
    print local;
  }
  return closure;
}

var closure = makeClosure();
closure();
```

> The outer function `makeClosure()` declares a variable, `local`. It also creates an inner function, `closure()` that captures that variable. Then `makeClosure()` returns a reference to that function. Since the closure escapes while holding on to the local variable, `local` must outlive the function call where it was created.

外層函數`makeClosure()`聲明瞭一個變量`local`。它還創建了一個內層函數`closure()`，用於捕獲該變量。然後`makeClosure()`返回對該內層函數的引用。因為閉包要在保留局部變量的同時進行退出，所以`local`必須比創建它的函數調用存活更長的時間。

![A local variable flying away from the stack.](25.閉包/flying.png)

> We could solve this problem by dynamically allocating memory for all local variables. That’s what jlox does by putting everything in those Environment objects that float around in Java’s heap. But we don’t want to. Using a stack is *really* fast. Most local variables are *not* captured by closures and do have stack semantics. It would suck to make all of those slower for the benefit of the rare local that is captured.

我們可以通過為所有局部變量動態地分配內存來解決這個問題。這就是jlox所做的，它將所有對象都放在Java堆中漂浮的Environment對象中。但我們並不想這樣做。使用堆棧*非常*快。大多數局部變量都不會被閉包捕獲，並且具有棧語義。如果為了極少數被捕獲的局部變量而使所有變量的速度變慢，那就糟糕了[^1]。

> This means a more complex approach than we used in our Java interpreter. Because some locals have very different lifetimes, we will have two implementation strategies. For locals that aren’t used in closures, we’ll keep them just as they are on the stack. When a local is captured by a closure, we’ll adopt another solution that lifts them onto the heap where they can live as long as needed.

這意味着一種比我們在Java解釋器中所用的更復雜的方法。因為有些局部變量具有非常不同的生命週期，我們將有兩種實現策略。對於那些不在閉包中使用的局部變量，我們將保持它們在棧中的原樣。當某個局部變量被閉包捕獲時，我們將採用另一種解決方案，將它們提升到堆中，在那裏它們存活多久都可以。

> Closures have been around since the early Lisp days when bytes of memory and CPU cycles were more precious than emeralds. Over the intervening decades, hackers devised all manner of ways to compile closures to optimized runtime representations. Some are more efficient but require a more complex compilation process than we could easily retrofit into clox.

閉包早在Lisp時代就已經存在了，當時內存字節和CPU週期比祖母綠還要珍貴。在過去的幾十年裏，黑客們設計了各種各樣的方式來編譯閉包，以優化運行時表示[^2]。有些方法更有效，但也需要更復雜的編譯過程，我們無法輕易地在clox中加以改造。

> The technique I explain here comes from the design of the Lua VM. It is fast, parsimonious with memory, and implemented with relatively little code. Even more impressive, it fits naturally into the single-pass compilers clox and Lua both use. It is somewhat intricate, though. It might take a while before all the pieces click together in your mind. We’ll build them one step at a time, and I’ll try to introduce the concepts in stages.

我在這裏解釋的技術來自於Lua虛擬機的設計。它速度快，內存佔用少，並且只用相對較少的代碼就實現了。更令人印象深刻的是，它很自然地適用於clox和Lua都在使用的單遍編譯器。不過，它有些複雜，可能需要一段時間才能把所有的碎片在你的腦海中拼湊起來。我們將一步一步地構建它們，我將嘗試分階段介紹這些概念。

> ## 25 . 1 Closure Objects

## 25.1 閉包對象

> Our VM represents functions at runtime using ObjFunction. These objects are created by the front end during compilation. At runtime, all the VM does is load the function object from a constant table and bind it to a name. There is no operation to “create” a function at runtime. Much like string and number literals, they are constants instantiated purely at compile time.

我們的虛擬機在運行時使用ObjFunction表示函數。這些對象是由前端在編譯時創建的。在運行時，虛擬機所做的就是從一個常量表中加載函數對象，並將其與一個名稱綁定。在運行時，沒有“創建”函數的操作。與字符串和數字字面量一樣，它們是純粹在編譯時實例化的常量[^3]。

> That made sense because all of the data that composes a function is known at compile time: the chunk of bytecode compiled from the function’s body, and the constants used in the body. Once we introduce closures, though, that representation is no longer sufficient. Take a gander at:

這是有道理的，因為組成函數的所有數據在編譯時都是已知的：根據函數主體編譯的字節碼塊，以及函數主體中使用的常量。一旦我們引入閉包，這種表示形式就不夠了。請看一下：

```javascript
fun makeClosure(value) {
  fun closure() {
    print value;
  }
  return closure;
}

var doughnut = makeClosure("doughnut");
var bagel = makeClosure("bagel");
doughnut();
bagel();
```

> The `makeClosure()` function defines and returns a function. We call it twice and get two closures back. They are created by the same nested function declaration, `closure`, but close over different values. When we call the two closures, each prints a different string. That implies we need some runtime representation for a closure that captures the local variables surrounding the function as they exist when the function declaration is *executed*, not just when it is compiled.

`makeClosure()`函數會定義並返回一個函數。我們調用它兩次，得到兩個閉包。它們都是由相同的嵌套函數聲明`closure`創建的，但關閉在不同的值上。當我們調用這兩個閉包時，每個閉包都打印出不同的字符串。這意味着我們需要一些閉包運行時表示，以捕獲函數外圍的局部變量，因為這些變量要在函數聲明被*執行*時存在，而不僅僅是在編譯時存在。

> We’ll work our way up to capturing variables, but a good first step is defining that object representation. Our existing ObjFunction type represents the “raw” compile-time state of a function declaration, since all closures created from a single declaration share the same code and constants. At runtime, when we execute a function declaration, we wrap the ObjFunction in a new ObjClosure structure. The latter has a reference to the underlying bare function along with runtime state for the variables the function closes over.

我們會逐步來捕獲變量，但良好的第一步是定義對象表示形式。我們現有的ObjFunction類型表示了函數聲明的“原始”編譯時狀態，因為從同一個聲明中創建的所有閉包都共享相同的代碼和常量。在運行時，當我們執行函數聲明時，我們將ObjFunction包裝進一個新的ObjClosure結構體中。後者有一個對底層裸函數的引用，以及該函數關閉的變量的運行時狀態[^4]。

![An ObjClosure with a reference to an ObjFunction.](25.閉包/obj-closure.png)

> We’ll wrap every function in an ObjClosure, even if the function doesn’t actually close over and capture any surrounding local variables. This is a little wasteful, but it simplifies the VM because we can always assume that the function we’re calling is an ObjClosure. That new struct starts out like this:

我們將用ObjClosure包裝每個函數，即使該函數實際上並沒有關閉或捕獲任何外圍局部變量。這有點浪費，但它簡化了虛擬機，因為我們總是可以認為我們正在調用的函數是一個ObjClosure。這個新結構體是這樣開始的：

*<u>object.h，在結構體ObjString後添加代碼：</u>*

```c
typedef struct {
  Obj obj;
  ObjFunction* function;
} ObjClosure;
```

> Right now, it simply points to an ObjFunction and adds the necessary object header stuff. Grinding through the usual ceremony for adding a new object type to clox, we declare a C function to create a new closure.

現在，它只是簡單地指向一個ObjFunction，並添加了必要的對象頭內容。遵循向clox中添加新對象類型的常規步驟，我們聲明一個C函數來創建新閉包。

*<u>object.h，在結構體ObjClosure後添加代碼：</u>*

```c
ObjFunction 
// 新增部分開始
ObjClosure* newClosure(ObjFunction* function);
// 新增部分結束
ObjFunction* newFunction();
```

> Then we implement it here:

然後我們在這裏實現它：

*<u>object.c，在allocateObject()方法後添加代碼：</u>*

```c
ObjClosure* newClosure(ObjFunction* function) {
  ObjClosure* closure = ALLOCATE_OBJ(ObjClosure, OBJ_CLOSURE);
  closure->function = function;
  return closure;
}
```

> It takes a pointer to the ObjFunction it wraps. It also initializes the type field to a new type.

它接受一個指向待包裝ObjFunction的指針。它還將類型字段初始為一個新類型。

*<u>object.h，在枚舉ObjType中添加代碼：</u>*

```c
typedef enum {
  // 新增部分開始
  OBJ_CLOSURE,
  // 新增部分結束
  OBJ_FUNCTION,
```

> And when we’re done with a closure, we release its memory.

以及，當我們用完閉包後，要釋放其內存。

*<u>memory.c，在freeObject()方法中添加代碼：</u>*

```c
  switch (object->type) {
    // 新增部分開始
    case OBJ_CLOSURE: {
      FREE(ObjClosure, object);
      break;
    }
    // 新增部分結束
    case OBJ_FUNCTION: {
```

> We free only the ObjClosure itself, not the ObjFunction. That’s because the closure doesn’t *own* the function. There may be multiple closures that all reference the same function, and none of them claims any special privilege over it. We can’t free the ObjFunction until *all* objects referencing it are gone—including even the surrounding function whose constant table contains it. Tracking that sounds tricky, and it is! That’s why we’ll write a garbage collector soon to manage it for us.

我們只釋放ObjClosure本身，而不釋放ObjFunction。這是因為閉包不*擁有*函數。可能會有多個閉包都引用了同一個函數，但沒有一個閉包聲稱對該函數有任何特殊的權限。我們不能釋放某個ObjFunction，直到引用它的*所有*對象全部消失——甚至包括那些常量表中包含該函數的外圍函數。要跟蹤這個信息聽起來很棘手，事實也的確如此！這就是我們很快就會寫一個垃圾收集器來管理它們的原因。

> We also have the usual macros for checking a value’s type.

我們還有用於檢查值類型的常用宏[^5]。

*<u>object.h，添加代碼：</u>*

```c
#define OBJ_TYPE(value)        (AS_OBJ(value)->type)
// 新增部分開始
#define IS_CLOSURE(value)      isObjType(value, OBJ_CLOSURE)
// 新增部分結束
#define IS_FUNCTION(value)     isObjType(value, OBJ_FUNCTION)
```

> And to cast a value:

還有值轉換：

*<u>object.h，添加代碼：</u>*

```c
#define IS_STRING(value)       isObjType(value, OBJ_STRING)
// 新增部分開始
#define AS_CLOSURE(value)      ((ObjClosure*)AS_OBJ(value))
// 新增部分結束
#define AS_FUNCTION(value)     ((ObjFunction*)AS_OBJ(value))
```

> Closures are first-class objects, so you can print them.

閉包是第一類對象，因此你可以打印它們。

*<u>object.c，在printObject()方法中添加代碼：</u>*

```c
  switch (OBJ_TYPE(value)) {
    // 新增部分開始
    case OBJ_CLOSURE:
      printFunction(AS_CLOSURE(value)->function);
      break;
    // 新增部分結束  
    case OBJ_FUNCTION:
```

> They display exactly as ObjFunction does. From the user’s perspective, the difference between ObjFunction and ObjClosure is purely a hidden implementation detail. With that out of the way, we have a working but empty representation for closures.

它們的顯示和ObjFunction一樣。從用户的角度來看，ObjFunction和ObjClosure之間的區別純粹是一個隱藏的實現細節。有了這些，我們就有了一個可用但空白的閉包表示形式。

> ### 25 . 1 . 1 Compiling to closure objects

### 25.1.1 編譯為閉包對象

> We have closure objects, but our VM never creates them. The next step is getting the compiler to emit instructions to tell the runtime when to create a new ObjClosure to wrap a given ObjFunction. This happens right at the end of a function declaration.

我們有了閉包對象，但是我們的VM還從未創建它們。下一步就是讓編譯器發出指令，告訴運行時何時創建一個新的ObjClosure來包裝指定的ObjFunction。這就發生在函數聲明的末尾。

*<u>compiler.c，在function()方法中替換1行：</u>*

```c
  ObjFunction* function = endCompiler();
  // 替換部分開始
  emitBytes(OP_CLOSURE, makeConstant(OBJ_VAL(function)));
  // 替換部分結束
}
```

> Before, the final bytecode for a function declaration was a single `OP_CONSTANT` instruction to load the compiled function from the surrounding function’s constant table and push it onto the stack. Now we have a new instruction.

之前，函數聲明的最後一個字節碼是一條`OP_CONSTANT`指令，用於從外圍函數的常量表中加載已編譯的函數，並將其壓入堆棧。現在我們有了一個新指令。

*<u>chunk.h，在枚舉OpCode中添加代碼：</u>*

```c
  OP_CALL,
  // 新增部分開始
  OP_CLOSURE,
  // 新增部分結束
  OP_RETURN,
```

> Like `OP_CONSTANT`, it takes a single operand that represents a constant table index for the function. But when we get over to the runtime implementation, we do something more interesting.

和`OP_CONSTANT`一樣，它接受一個操作數，表示函數在常量表中的索引。但是等到進入運行時實現時，我們會做一些更有趣的事情。

> First, let’s be diligent VM hackers and slot in disassembler support for the instruction.

首先，讓我們做一個勤奮的虛擬機黑客，為該指令添加反彙編器支持。

*<u>debug.c，在disassembleInstruction()方法中添加代碼：</u>*

```c
    case OP_CALL:
      return byteInstruction("OP_CALL", chunk, offset);
    // 新增部分開始  
    case OP_CLOSURE: {
      offset++;
      uint8_t constant = chunk->code[offset++];
      printf("%-16s %4d ", "OP_CLOSURE", constant);
      printValue(chunk->constants.values[constant]);
      printf("\n");
      return offset;
    }
    // 新增部分結束
    case OP_RETURN:
```

> There’s more going on here than we usually have in the disassembler. By the end of the chapter, you’ll discover that `OP_CLOSURE` is quite an unusual instruction. It’s straightforward right now—just a single byte operand—but we’ll be adding to it. This code here anticipates that future.

這裏做的事情比我們通常在反彙編程序中看到的要多。在本章結束時，你會發現`OP_CLOSURE`是一個相當不尋常的指令。它現在很簡單——只有一個單字節的操作數——但我們會增加它的內容。這裏的代碼預示了未來。

> ### 25 . 1 . 2 Interpreting function declarations

### 25.1.2 解釋函數聲明

> Most of the work we need to do is in the runtime. We have to handle the new instruction, naturally. But we also need to touch every piece of code in the VM that works with ObjFunction and change it to use ObjClosure instead—function calls, call frames, etc. We’ll start with the instruction, though.

我們需要做的大部分工作是在運行時。我們必須處理新的指令，這是自然的。但是我們也需要觸及虛擬機中每一段使用ObjFunction的代碼，並將其改為使用ObjClosure——函數調用、調用幀，等等。不過，我們會從指令開始。

*<u>vm.c，在run()方法中添加代碼：</u>*

```c
      }
      // 新增部分開始
      case OP_CLOSURE: {
        ObjFunction* function = AS_FUNCTION(READ_CONSTANT());
        ObjClosure* closure = newClosure(function);
        push(OBJ_VAL(closure));
        break;
      }
      // 新增部分結束
      case OP_RETURN: {
```

> Like the `OP_CONSTANT` instruction we used before, first we load the compiled function from the constant table. The difference now is that we wrap that function in a new ObjClosure and push the result onto the stack.

與我們前面使用的`OP_CONSTANT`類似，首先從常量表中加載已編譯的函數。現在的不同之處在於，我們將該函數包裝在一個新的ObjClosure中，並將結果壓入堆棧。

> Once you have a closure, you’ll eventually want to call it.

一旦你有了一個閉包，你最終就會想要調用它。

*<u>vm.c，在callValue()方法中替換2行：</u>*

```c
    switch (OBJ_TYPE(callee)) {
      // 替換部分開始
      case OBJ_CLOSURE:
        return call(AS_CLOSURE(callee), argCount);
      // 替換部分結束  
      case OBJ_NATIVE: {
```

> We remove the code for calling objects whose type is `OBJ_FUNCTION`. Since we wrap all functions in ObjClosures, the runtime will never try to invoke a bare ObjFunction anymore. Those objects live only in constant tables and get immediately wrapped in closures before anything else sees them.

我們刪除了調用`OBJ_FUNCTION`類型對象的代碼。因為我們用ObjClosures包裝了所有的函數，運行時永遠不會再嘗試調用原生的ObjFunction。這些原生函數對象只存在於常量表中，並在其它部分看到它們之前立即被封裝在閉包中。

> We replace the old code with very similar code for calling a closure instead. The only difference is the type of object we pass to `call()`. The real changes are over in that function. First, we update its signature.

我們用非常相似的調用閉包的代碼來代替舊代碼。唯一的區別是傳遞給`call()`的類型。真正的變化在這個函數中。首先，我們更新它的簽名。

*<u>vm.c，在函數call()中，替換1行：</u>*

```c
// 替換部分開始
static bool call(ObjClosure* closure, int argCount) {
// 替換部分結束
  if (argCount != function->arity) {
```

> Then, in the body, we need to fix everything that referenced the function to handle the fact that we’ve introduced a layer of indirection. We start with the arity checking:
>

然後，在主體中，我們需要修正所有引用該函數的內容，以便處理我們引入中間層的問題。首先從元數檢查開始：

*<u>vm.c，在call()方法中，替換3行：</u>*

```c
static bool call(ObjClosure* closure, int argCount) {
  // 替換部分開始
  if (argCount != closure->function->arity) {
    runtimeError("Expected %d arguments but got %d.",
        closure->function->arity, argCount);
    // 替換部分結束    
    return false;
```

> The only change is that we unwrap the closure to get to the underlying function. The next thing `call()` does is create a new CallFrame. We change that code to store the closure in the CallFrame and get the bytecode pointer from the closure’s function.

唯一的變化是，我們解開閉包獲得底層函數。`call()`做的下一件事是創建一個新的CallFrame。我們修改這段代碼，將閉包存儲在CallFrame中，並從閉包內的函數中獲取字節碼指針。

*<u>vm.c，在call()方法中，替換2行：</u>*

```c
  CallFrame* frame = &vm.frames[vm.frameCount++];
  // 替換部分開始
  frame->closure = closure;
  frame->ip = closure->function->chunk.code;
  // 替換部分結束
  frame->slots = vm.stackTop - argCount - 1;
```

> This necessitates changing the declaration of CallFrame too.

這就需要修改CallFrame的聲明。

*<u>vm.h，在結構體CallFrame中，替換1行：</u>*

```c
typedef struct {
  // 替換部分開始
  ObjClosure* closure;
  // 替換部分結束
  uint8_t* ip;
```

> That change triggers a few other cascading changes. Every place in the VM that accessed CallFrame’s function needs to use a closure instead. First, the macro for reading a constant from the current function’s constant table:

這一更改觸發了其它一些級聯更改。VM中所有訪問CallFrame中函數的地方都需要使用閉包來代替。首先，是從當前函數常量表中讀取常量的宏：

*<u>vm.c，在run()方法中，替換2行：</u>*

```c
    (uint16_t)((frame->ip[-2] << 8) | frame->ip[-1]))
// 替換部分開始    
#define READ_CONSTANT() \
    (frame->closure->function->chunk.constants.values[READ_BYTE()])
// 替換部分結束    
#define READ_STRING() AS_STRING(READ_CONSTANT())
```

> When `DEBUG_TRACE_EXECUTION` is enabled, it needs to get to the chunk from the closure.

當`DEBUG_TRACE_EXECUTION`被啓用時，它需要從閉包中獲取字節碼塊。

*<u>vm.c，在run()方法中，替換2行：</u>*

```c
    printf("\n");
    // 替換部分開始
    disassembleInstruction(&frame->closure->function->chunk,
        (int)(frame->ip - frame->closure->function->chunk.code));
    // 替換部分結束    
#endif
```

> Likewise when reporting a runtime error:

同樣地，在報告運行時錯誤時也是如此：

*<u>vm.c，在runtimeError()方法中，替換1行：</u>*

```c
    CallFrame* frame = &vm.frames[i];
    // 替換部分開始
    ObjFunction* function = frame->closure->function;
    // 替換部分結束
    size_t instruction = frame->ip - function->chunk.code - 1;
```

> Almost there. The last piece is the blob of code that sets up the very first CallFrame to begin executing the top-level code for a Lox script.

差不多完成了。最後一部分是用來設置第一個CallFrame以開始執行Lox腳本頂層程序的代碼塊。

*<u>vm.c，在interpret()方法中，替換1行[^6]：</u>*

```c
  push(OBJ_VAL(function));
  // 替換部分開始
  ObjClosure* closure = newClosure(function);
  pop();
  push(OBJ_VAL(closure));
  call(closure, 0);
  // 替換部分結束
  return run();
```

> The compiler still returns a raw ObjFunction when compiling a script. That’s fine, but it means we need to wrap it in an ObjClosure here, before the VM can execute it.

編譯腳本時，編譯器仍然返回一個原始的ObjFunction。這是可以的，但這意味着我們現在（也就是在VM能夠執行它之前），需要將其包裝在一個ObjClosure中。

> We are back to a working interpreter. The *user* can’t tell any difference, but the compiler now generates code telling the VM to create a closure for each function declaration. Every time the VM executes a function declaration, it wraps the ObjFunction in a new ObjClosure. The rest of the VM now handles those ObjClosures floating around. That’s the boring stuff out of the way. Now we’re ready to make these closures actually *do* something.

我們又得到了一個可以工作的解釋器。*用户*看不出有什麼不同，但是編譯器現在生成的代碼會告訴虛擬機，為每一個函數聲明創建一個閉包。每當VM執行一個函數聲明時，它都會將ObjFunction包裝在一個新的ObjClosure中。VM的其餘部分會處理那些四處漂浮的ObjClosures。無聊的事情就到此為止吧。現在，我們準備讓這些閉包實際*做*一些事情。

> ## 25 . 2 Upvalues

## 25.2 上值

> Our existing instructions for reading and writing local variables are limited to a single function’s stack window. Locals from a surrounding function are outside of the inner function’s window. We’re going to need some new instructions.

我們現有的讀寫局部變量的指令只限於單個函數的棧窗口。來自外圍函數的局部變量是在內部函數的窗口之外。我們需要一些新的指令。

> The easiest approach might be an instruction that takes a relative stack slot offset that can reach *before* the current function’s window. That would work if closed-over variables were always on the stack. But as we saw earlier, these variables sometimes outlive the function where they are declared. That means they won’t always be on the stack.

最簡單的方法可能是一條指令，接受一個棧槽相對偏移量，可以訪問當前函數窗口*之前*的位置。如果閉包變量始終在棧上，這是有效的。但正如我們前面看到的，這些變量的生存時間有時會比聲明它們的函數更長。這意味着它們不會一直在棧中。

> The next easiest approach, then, would be to take any local variable that gets closed over and have it always live on the heap. When the local variable declaration in the surrounding function is executed, the VM would allocate memory for it dynamically. That way it could live as long as needed.

然後，次簡單的方法是獲取閉包使用的任意局部變量，並讓它始終存活在堆中。當執行外圍函數中的局部變量聲明時，虛擬機會為其動態分配內存。這樣一來，它就可以根據需要長期存活。

> This would be a fine approach if clox didn’t have a single-pass compiler. But that restriction we chose in our implementation makes things harder. Take a look at this example:

如果clox不是單遍編譯器，這會是一種很好的方法。但是我們在實現中所選擇的這種限制使事情變得更加困難。看看這個例子：

```javascript
fun outer() {
  var x = 1;    // (1)
  x = 2;        // (2)
  fun inner() { // (3)
    print x;
  }
  inner();
}
```

> Here, the compiler compiles the declaration of `x` at `(1)` and emits code for the assignment at `(2)`. It does that before reaching the declaration of `inner()` at `(3)` and discovering that `x` is in fact closed over. We don’t have an easy way to go back and fix that already-emitted code to treat `x` specially. Instead, we want a solution that allows a closed-over variable to live on the stack exactly like a normal local variable *until the point that it is closed over*.

在這裏，編譯器在`(1)`處編譯了`x`的聲明，並在`(2)`處生成了賦值代碼。這些發生在編譯器到達在`(3)`處的`inner()`聲明並發現`x`實際上被閉包引用之前。我們沒有一種簡單的方法來回溯並修復已生成的代碼，以特殊處理`x`。相反，我們想要的解決方案是，在*變量被關閉之前*，允許它像常規的局部變量一樣存在於棧中。

> Fortunately, thanks to the Lua dev team, we have a solution. We use a level of indirection that they call an **upvalue**. An upvalue refers to a local variable in an enclosing function. Every closure maintains an array of upvalues, one for each surrounding local variable that the closure uses.

幸運的是，感謝Lua開發團隊，我們有了一個解決方案。我們使用一種他們稱之為**上值**的中間層。上值指的是一個閉包函數中的局部變量。每個閉包都維護一個上值數組，每個上值對應閉包使用的外圍局部變量。

> The upvalue points back into the stack to where the variable it captured lives. When the closure needs to access a closed-over variable, it goes through the corresponding upvalue to reach it. When a function declaration is first executed and we create a closure for it, the VM creates the array of upvalues and wires them up to “capture” the surrounding local variables that the closure needs.

上值指向棧中它所捕獲的變量所在的位置。當閉包需要訪問一個封閉的變量時，它會通過相應的上值(`upvalues`)得到該變量。當某個函數聲明第一次被執行，而且我們為其創建閉包時，虛擬機會創建一個上值數組，並將其與閉包連接起來，以“捕獲”閉包需要的外圍局部變量。

> For example, if we throw this program at clox,

舉個例子，如果我們把這個程序扔給clox

```javascript
{
  var a = 3;
  fun f() {
    print a;
  }
}
```

> the compiler and runtime will conspire together to build up a set of objects in memory like this:

編譯器和運行時會合力在內存中構建一組這樣的對象：

![The object graph of the stack, ObjClosure, ObjFunction, and upvalue array.](25.閉包/open-upvalue.png)

> That might look overwhelming, but fear not. We’ll work our way through it. The important part is that upvalues serve as the layer of indirection needed to continue to find a captured local variable even after it moves off the stack. But before we get to all that, let’s focus on compiling captured variables.

這可能看起來讓人不知所措，但不要害怕。我們會用自己的方式來完成的。重要的部分是，上值充當了中間層，以便在被捕獲的局部變量離開堆棧後能繼續找到它。但在此之前，讓我們先關注一下編譯捕獲的變量。

> ### 25 . 2 . 1 Compiling upvalues

### 25.2.1 編譯上值

> As usual, we want to do as much work as possible during compilation to keep execution simple and fast. Since local variables are lexically scoped in Lox, we have enough knowledge at compile time to resolve which surrounding local variables a function accesses and where those locals are declared. That, in turn, means we know *how many* upvalues a closure needs, *which* variables they capture, and *which stack slots* contain those variables in the declaring function’s stack window.

像往常一樣，我們希望在編譯期間做盡可能多的工作，從而保持執行的簡單快速。由於局部變量在Lox是具有詞法作用域的，我們在編譯時有足夠的信息來確定某個函數訪問了哪些外圍的局部變量，以及這些局部變量是在哪裏聲明的。反過來，這意味着我們知道閉包需要*多少個*上值，它們捕獲了*哪個*變量，以及在聲明函數的棧窗口中的*哪個棧槽*中包含這些變量。

> Currently, when the compiler resolves an identifier, it walks the block scopes for the current function from innermost to outermost. If we don’t find the variable in that function, we assume the variable must be a global. We don’t consider the local scopes of enclosing functions—they get skipped right over. The first change, then, is inserting a resolution step for those outer local scopes.

目前，當編譯器解析一個標識符時，它會從最內層到最外層遍歷當前函數的塊作用域。如果我們沒有在函數中找到該變量，我們就假定該變量一定是一個全局變量。我們不考慮封閉函數的局部作用域——它們會被直接跳過。那麼，第一個變化就是為這些外圍局部作用域插入一個解析步驟。

*<u>compiler.c，在namedVariable()方法中添加代碼：</u>*

```c
  if (arg != -1) {
    getOp = OP_GET_LOCAL;
    setOp = OP_SET_LOCAL;
  // 新增部分開始  
  } else if ((arg = resolveUpvalue(current, &name)) != -1) {
    getOp = OP_GET_UPVALUE;
    setOp = OP_SET_UPVALUE;
  // 新增部分結束  
  } else {
```

> This new `resolveUpvalue()` function looks for a local variable declared in any of the surrounding functions. If it finds one, it returns an “upvalue index” for that variable. (We’ll get into what that means later.) Otherwise, it returns -1 to indicate the variable wasn’t found. If it was found, we use these two new instructions for reading or writing to the variable through its upvalue:

這個新的`resolveUpvalue()`函數會查找在任何外圍函數中聲明的局部變量。如果找到了，就會返回該變量的“上值索引”。（我們稍後會解釋這是什麼意思）否則，它會返回`-1`，表示沒有找到該變量。如果找到變量，我們就使用這兩條新指令，通過其上值對變量進行讀寫：

*<u>chunk.h，在枚舉OpCode中添加代碼：</u>*

```c
  OP_SET_GLOBAL,
  // 新增部分開始
  OP_GET_UPVALUE,
  OP_SET_UPVALUE,
  // 新增部分結束
  OP_EQUAL,
```

> We’re implementing this sort of top-down, so I’ll show you how these work at runtime soon. The part to focus on now is how the compiler actually resolves the identifier.

我們是自上而下實現的，所以我們很快會向你展示這些在運行時是如何工作的。現在要關注的部分是編譯器實際上是如何解析標識符的。

*<u>compiler.c，在resolveLocal()方法後添加代碼：</u>*

```c
static int resolveUpvalue(Compiler* compiler, Token* name) {
  if (compiler->enclosing == NULL) return -1;

  int local = resolveLocal(compiler->enclosing, name);
  if (local != -1) {
    return addUpvalue(compiler, (uint8_t)local, true);
  }

  return -1;
}
```

> We call this after failing to resolve a local variable in the current function’s scope, so we know the variable isn’t in the current compiler. Recall that Compiler stores a pointer to the Compiler for the enclosing function, and these pointers form a linked chain that goes all the way to the root Compiler for the top-level code. Thus, if the enclosing Compiler is `NULL`, we know we’ve reached the outermost function without finding a local variable. The variable must be global, so we return -1.

在當前函數作用域中解析局部變量失敗後，我們才會調用這個方法，因此我們知道該變量不在當前編譯器中。回顧一下，Compiler中存儲了一個指向外層函數Compiler的指針，這些指針形成了一個鏈，一直到頂層代碼的根Compiler。因此，如果外圍的Compiler是`NULL`，我們就知道已經到達最外層的函數，而且沒有找到局部變量。那麼該變量一定是全局的[^7]，所以我們返回`-1`。

> Otherwise, we try to resolve the identifier as a *local* variable in the *enclosing* compiler. In other words, we look for it right outside the current function. For example:

否則，我們嘗試將標識符解析為一個在*外圍*編譯器中的*局部*變量。換句話説，我們在當前函數外面尋找它。舉例來説：

```javascript
fun outer() {
  var x = 1;
  fun inner() {
    print x; // (1)
  }
  inner();
}
```

> When compiling the identifier expression at `(1)`, `resolveUpvalue()` looks for a local variable `x` declared in `outer()`. If found—like it is in this example—then we’ve successfully resolved the variable. We create an upvalue so that the inner function can access the variable through that. The upvalue is created here:

當在`(1)`處編譯標識符表達式時，`resolveUpvalue()`會查找在`outer()`中定義的局部變量`x`。如果找到了（就像本例中這樣），那我們就成功解析了該變量。我們創建一個上值，以便內部函數可以通過它訪問變量。上值是在這裏創建的：

*<u>compiler.c，在resolveLocal()方法後添加代碼：</u>*

```c
static int addUpvalue(Compiler* compiler, uint8_t index,
                      bool isLocal) {
  int upvalueCount = compiler->function->upvalueCount;
  compiler->upvalues[upvalueCount].isLocal = isLocal;
  compiler->upvalues[upvalueCount].index = index;
  return compiler->function->upvalueCount++;
}
```

> The compiler keeps an array of upvalue structures to track the closed-over identifiers that it has resolved in the body of each function. Remember how the compiler’s Local array mirrors the stack slot indexes where locals live at runtime? This new upvalue array works the same way. The indexes in the compiler’s array match the indexes where upvalues will live in the ObjClosure at runtime.
>

編譯器保留了一個上值結構的數組，用以跟蹤每個函數主體中已解析的封閉標識符。還記得編譯器的Local數組是如何反映局部變量在運行時所在的棧槽索引的嗎？這個新的上值數組也使用相同的方式。編譯器數組中的索引，與運行時ObjClosure中上值所在的索引相匹配。

> This function adds a new upvalue to that array. It also keeps track of the number of upvalues the function uses. It stores that count directly in the ObjFunction itself because we’ll also need that number for use at runtime.
>

這個函數向數組中添加了一個新的上值。它還記錄了該函數所使用的上值的數量。它直接在ObjFunction中存儲了這個計數值，因為我們在運行時也需要使用這個數字[^8]。

> The `index` field tracks the closed-over local variable’s slot index. That way the compiler knows *which* variable in the enclosing function needs to be captured. We’ll circle back to what that `isLocal` field is for before too long. Finally, `addUpvalue()` returns the index of the created upvalue in the function’s upvalue list. That index becomes the operand to the `OP_GET_UPVALUE` and `OP_SET_UPVALUE` instructions.
>

`index`字段記錄了封閉局部變量的棧槽索引。這樣，編譯器就知道需要捕獲外部函數中的*哪個*變量。用不了多久，我們會回過頭來討論`isLocal`字段的用途。最後，`addUpvalue()`返回已創建的上值在函數的上值列表中的索引。這個索引會成為`OP_GET_UPVALUE`和`OP_SET_UPVALUE`指令的操作數。

> That’s the basic idea for resolving upvalues, but the function isn’t fully baked. A closure may reference the same variable in a surrounding function multiple times. In that case, we don’t want to waste time and memory creating a separate upvalue for each identifier expression. To fix that, before we add a new upvalue, we first check to see if the function already has an upvalue that closes over that variable.
>

這就是解析上值的基本思路，但是這個函數還沒有完全成熟。一個閉包可能會多次引用外圍函數中的同一個變量。在這種情況下，我們不想浪費時間和內存來為每個標識符表達式創建一個單獨的上值。為了解決這個問題，在我們添加新的上值之前，我們首先要檢查該函數是否已經有封閉該變量的上值。

*<u>compiler.c，在addUpvalue()方法中添加代碼：</u>*

```c
  int upvalueCount = compiler->function->upvalueCount;
  // 新增部分開始
  for (int i = 0; i < upvalueCount; i++) {
    Upvalue* upvalue = &compiler->upvalues[i];
    if (upvalue->index == index && upvalue->isLocal == isLocal) {
      return i;
    }
  }
  // 新增部分結束
  compiler->upvalues[upvalueCount].isLocal = isLocal;
```

> If we find an upvalue in the array whose slot index matches the one we’re adding, we just return that *upvalue* index and reuse it. Otherwise, we fall through and add the new upvalue.

如果我們在數組中找到與待添加的上值索引相匹配的上值，我們就返回該*上值*的索引並複用它。否則，我們就放棄，並添加新的上值。

> These two functions access and modify a bunch of new state, so let’s define that. First, we add the upvalue count to ObjFunction.

這兩個函數訪問並修改了一些新的狀態，所以我們來定義一下。首先，我們將上值計數添加到ObjFunction中。

*<u>object.h，在結構體ObjFunction中添加代碼：</u>*

```c
  int arity;
  // 新增部分開始
  int upvalueCount;
  // 新增部分結束
  Chunk chunk;
```

> We’re conscientious C programmers, so we zero-initialize that when an ObjFunction is first allocated.
>

我們是負責的C程序員，所以當ObjFunction第一次被分配時，我們將其初始化為0。

*<u>object.c，在newFunction()方法中添加代碼：</u>*

```c
  function->arity = 0;
  // 新增部分開始
  function->upvalueCount = 0;
  // 新增部分結束
  function->name = NULL;
```

> In the compiler, we add a field for the upvalue array.

在編譯器中，我們添加一個字段來存儲上值數組。

*<u>compiler.c，在結構體Compiler中添加代碼：</u>*

```c
  int localCount;
  // 新增部分開始
  Upvalue upvalues[UINT8_COUNT];
  // 新增部分結束
  int scopeDepth;
```

> For simplicity, I gave it a fixed size. The `OP_GET_UPVALUE` and `OP_SET_UPVALUE` instructions encode an upvalue index using a single byte operand, so there’s a restriction on how many upvalues a function can have—how many unique variables it can close over. Given that, we can afford a static array that large. We also need to make sure the compiler doesn’t overflow that limit.

為了簡單起見，我給了它一個固定的大小。`OP_GET_UPVALUE`和`OP_SET_UPVALUE`指令使用一個單字節操作數來編碼上值索引，所以一個函數可以有多少個上值（可以封閉多少個不同的變量）是有限制的。鑑於此，我們可以負擔得起這麼大的靜態數組。我們還需要確保編譯器不會超出這個限制。

*<u>compiler.c，在addUpvalue()方法中添加代碼：</u>*

```c
    if (upvalue->index == index && upvalue->isLocal == isLocal) {
      return i;
    }
  }
  // 新增部分開始
  if (upvalueCount == UINT8_COUNT) {
    error("Too many closure variables in function.");
    return 0;
  }
  // 新增部分結束
  compiler->upvalues[upvalueCount].isLocal = isLocal;
```

> Finally, the Upvalue struct type itself.

最後，是Upvalue結構體本身。

*<u>compiler.c，在結構體Local後添加代碼：</u>*

```c
typedef struct {
  uint8_t index;
  bool isLocal;
} Upvalue;
```

> The `index` field stores which local slot the upvalue is capturing. The `isLocal` field deserves its own section, which we’ll get to next.

`index`字段存儲了上值捕獲的是哪個局部變量槽。`isLocal`字段值得有自己的章節，我們接下來會講到。

> ### 25 . 2 . 2 Flattening upvalues

### 25.2.2 扁平化上值

> In the example I showed before, the closure is accessing a variable declared in the immediately enclosing function. Lox also supports accessing local variables declared in *any* enclosing scope, as in:

在我之前展示的例子中，閉包訪問的是在緊鄰的外圍函數中聲明的變量。Lox還支持訪問在*任何*外圍作用域中聲明的局部變量，如：

```c
fun outer() {
  var x = 1;
  fun middle() {
    fun inner() {
      print x;
    }
  }
}
```

> Here, we’re accessing `x` in `inner()`. That variable is defined not in `middle()`, but all the way out in `outer()`. We need to handle cases like this too. You *might* think that this isn’t much harder since the variable will simply be somewhere farther down on the stack. But consider this devious example:

這裏，我們在`inner()`中訪問`x`。這個變量不是在`middle()`中定義的，而是要一直追溯到`outer()`中。我們也需要處理這樣的情況。你*可能*認為這並不難，因為變量只是位於棧中更下面的某個位置。但是考慮一下這個複雜的例子：

> If you work on programming languages long enough, you will develop a finely honed skill at creating bizarre programs like this that are technically valid but likely to trip up an implementation written by someone with a less perverse imagination than you.

如果你在編程語言方面工作的時間足夠長，你就會開發出一種精細的技能，能夠創造出像這樣的怪異程序，這些程序在技術上是有效的，但很可能會在一個由想象力沒你那麼變態的人編寫的實現中出錯。

```javascript
fun outer() {
  var x = "value";
  fun middle() {
    fun inner() {
      print x;
    }

    print "create inner closure";
    return inner;
  }

  print "return from outer";
  return middle;
}

var mid = outer();
var in = mid();
in();
```

> When you run this, it should print:

當你運行這段代碼時，應該打印出來：

```
return from outer
create inner closure
value
```

> I know, it’s convoluted. The important part is that `outer()`—where `x` is declared—returns and pops all of its variables off the stack before the *declaration* of `inner()` executes. So, at the point in time that we create the closure for `inner()`, `x` is already off the stack.

我知道，這很複雜。重要的是，在`inner()`的聲明執行之前，`outer()`（`x`被聲明的地方）已經返回並彈出其所有變量。因此，在我們為`inner()`創建閉包時，`x`已經離開了堆棧。

> Here, I traced out the execution flow for you:

下面，我為你繪製了執行流程：

![Tracing through the previous example program.](25.閉包/execution-flow.png)

> See how `x` is popped before it is captured  and then later accessed ? We really have two problems:

看到了嗎，`x`在被捕獲②之前，先被彈出 ①，隨後又被訪問③？我們確實有兩個問題：

> 1. We need to resolve local variables that are declared in surrounding functions beyond the immediately enclosing one.
> 2. We need to be able to capture variables that have already left the stack.

1. 我們需要解析在緊鄰的函數之外的外圍函數中聲明的局部變量。
2. 我們需要能夠捕獲已經離開堆棧的變量。

> Fortunately, we’re in the middle of adding upvalues to the VM, and upvalues are explicitly designed for tracking variables that have escaped the stack. So, in a clever bit of self-reference, we can use upvalues to allow upvalues to capture variables declared outside of the immediately surrounding function.

幸運的是，我們正在向虛擬機中添加上值，而上值是明確為跟蹤已退出棧的變量而設計的。因此，通過一個巧妙的自我引用，我們可以使用上值來允許上值捕獲緊鄰函數之外聲明的變量。

> The solution is to allow a closure to capture either a local variable or *an existing upvalue* in the immediately enclosing function. If a deeply nested function references a local variable declared several hops away, we’ll thread it through all of the intermediate functions by having each function capture an upvalue for the next function to grab.

解決方案是允許閉包捕獲局部變量或緊鄰函數中*已有的上值*。如果一個深度嵌套的函數引用了幾跳之外聲明的局部變量，我們讓每個函數捕獲一個上值，供下一個函數抓取，從而穿透所有的中間函數。

![An upvalue in inner() points to an upvalue in middle(), which points to a local variable in outer().](25.閉包/linked-upvalues.png)

> In the above example, `middle()` captures the local variable `x` in the immediately enclosing function `outer()` and stores it in its own upvalue. It does this even though `middle()` itself doesn’t reference `x`. Then, when the declaration of `inner()` executes, its closure grabs the *upvalue* from the ObjClosure for `middle()` that captured `x`. A function captures—either a local or upvalue—*only* from the immediately surrounding function, which is guaranteed to still be around at the point that the inner function declaration executes.

在上面的例子中，`middle()`捕獲了緊鄰的外層函數`outer()`中的局部變量`x`，並將其存儲在自己的上值中。即使`middle()`本身不引用`x`，它也會這樣做。然後，當`inner()`的聲明執行時，它的閉包會從已捕獲`x`的`middle()`對應的ObjClosure中抓取*上值*。函數只會從緊鄰的外層函數中捕獲局部變量或上值，因為這些值在內部函數聲明執行時仍然能夠確保存在。

> In order to implement this, `resolveUpvalue()` becomes recursive.

為了實現這一點，`resolveUpvalue()`變成遞歸的。

*<u>compiler.c，在resolveUpvalue()方法中添加代碼：</u>*

```c
  if (local != -1) {
    return addUpvalue(compiler, (uint8_t)local, true);
  }
  // 新增部分開始
  int upvalue = resolveUpvalue(compiler->enclosing, name);
  if (upvalue != -1) {
    return addUpvalue(compiler, (uint8_t)upvalue, false);
  }
  // 新增部分結束
  return -1;
```

> It’s only another three lines of code, but I found this function really challenging to get right the first time. This in spite of the fact that I wasn’t inventing anything new, just porting the concept over from Lua. Most recursive functions either do all their work before the recursive call (a **pre-order traversal**, or “on the way down”), or they do all the work after the recursive call (a **post-order traversal**, or “on the way back up”). This function does both. The recursive call is right in the middle.
>

這只是另外加了三行代碼，但我發現這個函數真的很難一次就正確完成。儘管我並沒有發明什麼新東西，只是從Lua中移植了這個概念。大多數遞歸函數要麼在遞歸調用之前完成所有工作（**先序遍歷**，或“下行”），要麼在遞歸調用之後完成所有工作（**後續遍歷**，或“回退”）。這個函數兩者都是，遞歸調用就在中間。

> We’ll walk through it slowly. First, we look for a matching local variable in the enclosing function. If we find one, we capture that local and return. That’s the base case.
>

我們來慢慢看一下。首先，我們在外部函數中查找匹配的局部變量。如果我們找到了，就捕獲該局部變量並返回。這就是基本情況[^9]。

> Otherwise, we look for a local variable beyond the immediately enclosing function. We do that by recursively calling `resolveUpvalue()` on the *enclosing* compiler, not the current one. This series of `resolveUpvalue()` calls works its way along the chain of nested compilers until it hits one of the base cases—either it finds an actual local variable to capture or it runs out of compilers.
>

否則，我們會在緊鄰的函數之外尋找局部變量。我們通過遞歸地對外層編譯器（而不是當前編譯器）調用`resolveUpvalue()`來實現這一點。這一系列的`resolveUpvalue()`調用沿着嵌套的編譯器鏈運行，直到遇見基本情況——要麼找到一個事件的局部變量來捕獲，要麼是遍歷完了所有編譯器。

> When a local variable is found, the most deeply nested call to `resolveUpvalue()` captures it and returns the upvalue index. That returns to the next call for the inner function declaration. That call captures the *upvalue* from the surrounding function, and so on. As each nested call to `resolveUpvalue()` returns, we drill back down into the innermost function declaration where the identifier we are resolving appears. At each step along the way, we add an upvalue to the intervening function and pass the resulting upvalue index down to the next call.
>

當找到局部變量時，嵌套最深的`resolveUpvalue()`調用會捕獲它並返回上值的索引。這就會返回到內層函數聲明對應的下一級調用。該調用會捕獲外層函數中的*上值*，以此類推。隨着對`resolveUpvalue()`的每個嵌套調用的返回，我們會往下鑽到最內層函數聲明，即我們正在解析的標識符出現的地方。在這一過程中的每一步，我們都向中間函數添加一個上值，並將得到的上值索引向下傳遞給下一個調用[^10]。

> It might help to walk through the original example when resolving `x`:
>

在解析`x`的時候，走一遍原始的例子可能會有幫助：

![Tracing through a recursive call to resolveUpvalue().](25.閉包/recursion.png)

> Note that the new call to `addUpvalue()` passes `false` for the `isLocal` parameter. Now you see that that flag controls whether the closure captures a local variable or an upvalue from the surrounding function.
>

請注意，對`addUpvalue()`的新調用為`isLocal`參數傳遞了`false`。現在你可以看到，該標誌控制着閉包捕獲的是局部變量還是來自外圍函數的上值。

> By the time the compiler reaches the end of a function declaration, every variable reference has been resolved as either a local, an upvalue, or a global. Each upvalue may in turn capture a local variable from the surrounding function, or an upvalue in the case of transitive closures. We finally have enough data to emit bytecode which creates a closure at runtime that captures all of the correct variables.
>

當編譯器到達函數聲明的結尾時，每個變量的引用都已經被解析為局部變量、上值或全局變量。每個上值可以依次從外圍函數中捕獲一個局部變量，或者在傳遞閉包的情況下捕獲一個上值。我們終於有了足夠的數據來生成字節碼，該字節碼在運行時創建一個捕獲所有正確變量的閉包。

*<u>compiler.c，在function()方法中添加代碼：</u>*

```c
  emitBytes(OP_CLOSURE, makeConstant(OBJ_VAL(function)));
  // 新增部分開始
  for (int i = 0; i < function->upvalueCount; i++) {
    emitByte(compiler.upvalues[i].isLocal ? 1 : 0);
    emitByte(compiler.upvalues[i].index);
  }
  // 新增部分結束
}
```

> The `OP_CLOSURE` instruction is unique in that it has a variably sized encoding. For each upvalue the closure captures, there are two single-byte operands. Each pair of operands specifies what that upvalue captures. If the first byte is one, it captures a local variable in the enclosing function. If zero, it captures one of the function’s upvalues. The next byte is the local slot or upvalue index to capture.

`OP_CLOSURE`指令的獨特之處在於，它是不定長編碼的。對於閉包捕獲的每個上值，都有兩個單字節的操作數。每一對操作數都指定了上值捕獲的內容。如果第一個字節是1，它捕獲的就是外層函數中的一個局部變量。如果是0，它捕獲的是函數的一個上值。下一個字節是要捕獲局部變量插槽或上值索引。

> This odd encoding means we need some bespoke support in the disassembly code for `OP_CLOSURE`.

這種奇怪的編碼意味着我們需要在反彙編程序中對`OP_CLOSURE`提供一些定製化的支持。

*<u>debug.c，在disassembleInstruction()方法中添加代碼：</u>*

```c
      printf("\n");
      // 新增部分開始
      ObjFunction* function = AS_FUNCTION(
          chunk->constants.values[constant]);
      for (int j = 0; j < function->upvalueCount; j++) {
        int isLocal = chunk->code[offset++];
        int index = chunk->code[offset++];
        printf("%04d      |                     %s %d\n",
               offset - 2, isLocal ? "local" : "upvalue", index);
      }
      // 新增部分結束
      return offset;
```

> For example, take this script:

舉例來説，請看這個腳本：

```javascript
fun outer() {
  var a = 1;
  var b = 2;
  fun middle() {
    var c = 3;
    var d = 4;
    fun inner() {
      print a + c + b + d;
    }
  }
}
```

> If we disassemble the instruction that creates the closure for `inner()`, it prints this:

如果我們反彙編為`inner()`創建閉包的指令，它會打印如下內容：

```
0004    9 OP_CLOSURE          2 <fn inner>
0006      |                     upvalue 0
0008      |                     local 1
0010      |                     upvalue 1
0012      |                     local 2
```

> We have two other, simpler instructions to add disassembler support for.

我們還有兩條更簡單的指令需要添加反彙編支持。

*<u>debug.c，在disassembleInstruction()方法中添加代碼：</u>*

```c
    case OP_SET_GLOBAL:
      return constantInstruction("OP_SET_GLOBAL", chunk, offset);
    // 新增部分開始  
    case OP_GET_UPVALUE:
      return byteInstruction("OP_GET_UPVALUE", chunk, offset);
    case OP_SET_UPVALUE:
      return byteInstruction("OP_SET_UPVALUE", chunk, offset);
    // 新增部分結束  
    case OP_EQUAL:
```

> These both have a single-byte operand, so there’s nothing exciting going on. We do need to add an include so the debug module can get to `AS_FUNCTION()`.

這兩條指令都是單字節操作數，所有沒有什麼有趣的內容。我們確實需要添加一個頭文件引入，以便調試模塊能夠訪問`AS_FUNCTION()`。

*<u>debug.c，添加代碼：</u>*

```c
#include "debug.h"
// 新增部分開始
#include "object.h"
// 新增部分結束
#include "value.h"
```

> With that, our compiler is where we want it. For each function declaration, it outputs an `OP_CLOSURE` instruction followed by a series of operand byte pairs for each upvalue it needs to capture at runtime. It’s time to hop over to that side of the VM and get things running.

有了這些，我們的編譯器就達到了我們想要的效果。對於每個函數聲明，它都會輸出一條`OP_CLOSURE`指令，後跟一系列操作數字節對，對應需要在運行時捕獲的每個上值。現在是時候跳到虛擬機那邊，讓整個程序運轉起來。

> ## 25 . 3 Upvalue Objects

## 25.3 Upvalue對象

> Each `OP_CLOSURE` instruction is now followed by the series of bytes that specify the upvalues the ObjClosure should own. Before we process those operands, we need a runtime representation for upvalues.

現在每條`OP_CLOSURE`指令後面都跟着一系列字節，這些字節指定了ObjClosure應該擁有的上值。在處理這些操作數之前，我們需要一個上值的運行時表示。

*<u>object.h，在結構體ObjString後添加代碼：</u>*

```c
typedef struct ObjUpvalue {
  Obj obj;
  Value* location;
} ObjUpvalue;
```

> We know upvalues must manage closed-over variables that no longer live on the stack, which implies some amount of dynamic allocation. The easiest way to do that in our VM is by building on the object system we already have. That way, when we implement a garbage collector in [the next chapter](http://www.craftinginterpreters.com/garbage-collection.html), the GC can manage memory for upvalues too.

我們知道上值必須管理已關閉的變量，這些變量不再存活於棧上，這意味着需要一些動態分配。在我們的虛擬機中，最簡單的方法就是在已有的對象系統上進行構建。這樣，當我們在下一章中實現垃圾收集器時，GC也可以管理上值的內存。

> Thus, our runtime upvalue structure is an ObjUpvalue with the typical Obj header field. Following that is a `location` field that points to the closed-over variable. Note that this is a *pointer* to a Value, not a Value itself. It’s a reference to a *variable*, not a *value*. This is important because it means that when we assign to the variable the upvalue captures, we’re assigning to the actual variable, not a copy. For example:

因此，我們的運行時上值結構是一個具有典型Obj頭字段的ObjUpvalue。之後是一個指向關閉變量的`location`字段。注意，這是一個指向Value的指針，而不是Value本身。它是一個*變量*的引用，而不是一個*值*。這一點很重要，因為它意味着當我們向上值捕獲的變量賦值時，我們是在給實際的變量賦值，而不是對一個副本賦值。舉例來説：

```javascript
fun outer() {
  var x = "before";
  fun inner() {
    x = "assigned";
  }
  inner();
  print x;
}
outer();
```

> This program should print “assigned” even though the closure assigns to `x` and the surrounding function accesses it.

這個程序應該打印“assigned”，儘管是在閉包中對`x`賦值，而在外圍函數中訪問它。

> Because upvalues are objects, we’ve got all the usual object machinery, starting with a constructor-like function:

因為上值是對象，我們已經有了所有常見的對象機制，首先是類似構造器的函數：

*<u>object.h，在copyString()方法後添加代碼：</u>*

```c
ObjString* copyString(const char* chars, int length);
// 新增部分開始
ObjUpvalue* newUpvalue(Value* slot);
// 新增部分結束
void printObject(Value value);
```

> It takes the address of the slot where the closed-over variable lives. Here is the implementation:

它接受的是封閉變量所在的槽的地址。下面是其實現：

*<u>object.c，在copyString()方法後添加代碼：</u>*

```c
ObjUpvalue* newUpvalue(Value* slot) {
  ObjUpvalue* upvalue = ALLOCATE_OBJ(ObjUpvalue, OBJ_UPVALUE);
  upvalue->location = slot;
  return upvalue;
}
```

> We simply initialize the object and store the pointer. That requires a new object type.

我們簡單地初始化對象並存儲指針。這需要一個新的對象類型。

*<u>object.h，在枚舉ObjType中添加代碼：</u>*

```c
  OBJ_STRING,
  // 新增部分開始
  OBJ_UPVALUE
  // 新增部分結束
} ObjType;
```

> And on the back side, a destructor-like function:

在後面，還有一個類似析構函數的方法：

*<u>memory.c，在freeObject()方法中添加代碼：</u>*

```c
      FREE(ObjString, object);
      break;
    }
    // 新增部分開始
    case OBJ_UPVALUE:
      FREE(ObjUpvalue, object);
      break;
    // 新增部分結束  
  }
```

> Multiple closures can close over the same variable, so ObjUpvalue does not own the variable it references. Thus, the only thing to free is the ObjUpvalue itself.

多個閉包可以關閉同一個變量，所以ObjUpvalue並不擁有它引用的變量。因此，唯一需要釋放的就是ObjUpvalue本身。

> And, finally, to print:

最後，是打印：

*<u>object.c，在printObject()方法中添加代碼：</u>*

```c
    case OBJ_STRING:
      printf("%s", AS_CSTRING(value));
      break;
    // 新增部分開始   
    case OBJ_UPVALUE:
      printf("upvalue");
      break;
    // 新增部分結束  
  }
```

> Printing isn’t useful to end users. Upvalues are objects only so that we can take advantage of the VM’s memory management. They aren’t first-class values that a Lox user can directly access in a program. So this code will never actually execute . . . but it keeps the compiler from yelling at us about an unhandled switch case, so here we are.

打印對終端用户沒有用。上值是對象，只是為了讓我們能夠利用虛擬機的內存管理。它們並不是Lox用户可以在程序中直接訪問的一等公民。因此，這段代碼實際上永遠不會執行……但它使得編譯器不會因為未處理的case分支而對我們大喊大叫，所以我們這樣做了。

> ### 25 . 3 . 1 Upvalues in closures

### 25.3.1 閉包中的上值

> When I first introduced upvalues, I said each closure has an array of them. We’ve finally worked our way back to implementing that.

我在第一次介紹上值時，説過每個閉包中都有一個上值數組。我們終於回到了實現它的道路上。

*<u>object.h，在結構體ObjClosure中添加代碼：</u>*

```c
  ObjFunction* function;
  // 新增部分開始
  ObjUpvalue** upvalues;
  int upvalueCount;
  // 新增部分結束
} ObjClosure;
```

> Different closures may have different numbers of upvalues, so we need a dynamic array. The upvalues themselves are dynamically allocated too, so we end up with a double pointer—a pointer to a dynamically allocated array of pointers to upvalues. We also store the number of elements in the array.

不同的閉包可能會有不同數量的上值，所以我們需要一個動態數組。上值本身也是動態分配的，因此我們最終需要一個二級指針——一個指向動態分配的上值指針數組的指針。我們還會存儲數組中的元素數量[^11]。

> When we create an ObjClosure, we allocate an upvalue array of the proper size, which we determined at compile time and stored in the ObjFunction.

當我們創建ObjClosure時，會分配一個適當大小的上值數組，這個大小在編譯時就已經確定並存儲在ObjFunction中。

*<u>object.c，在newClosure()方法中添加代碼：</u>*

```c
ObjClosure* newClosure(ObjFunction* function) {
  // 新增部分開始
  ObjUpvalue** upvalues = ALLOCATE(ObjUpvalue*,
                                   function->upvalueCount);
  for (int i = 0; i < function->upvalueCount; i++) {
    upvalues[i] = NULL;
  }
  // 新增部分結束
  ObjClosure* closure = ALLOCATE_OBJ(ObjClosure, OBJ_CLOSURE);
```

> Before creating the closure object itself, we allocate the array of upvalues and initialize them all to `NULL`. This weird ceremony around memory is a careful dance to please the (forthcoming) garbage collection deities. It ensures the memory manager never sees uninitialized memory.

在創建閉包對象本身之前，我們分配了上值數組，並將其初始化為`NULL`。這種圍繞內存的奇怪儀式是一場精心的舞蹈，為了取悦（即將到來的）垃圾收集器神靈。它可以確保內存管理器永遠不會看到未初始化的內存。

> Then we store the array in the new closure, as well as copy the count over from the ObjFunction.

然後，我們將數組存儲在新的閉包中，並將計數值從ObjFunction中複製過來。

*<u>object.c，在newClosure()方法中添加代碼：</u>*

```c
  closure->function = function;
  // 新增部分開始
  closure->upvalues = upvalues;
  closure->upvalueCount = function->upvalueCount;
  // 新增部分結束
  return closure;
```

> When we free an ObjClosure, we also free the upvalue array.

當我們釋放ObjClosure時，也需要釋放上值數組。

*<u>memory.c，在freeObject()方法中添加代碼：</u>*

```c
    case OBJ_CLOSURE: {
      // 新增部分開始
      ObjClosure* closure = (ObjClosure*)object;
      FREE_ARRAY(ObjUpvalue*, closure->upvalues,
                 closure->upvalueCount);
      // 新增部分結束           
      FREE(ObjClosure, object);
```

> ObjClosure does not own the ObjUpvalue objects themselves, but it does own *the array* containing pointers to those upvalues.

ObjClosure並不擁有ObjUpvalue本身，但它確實擁有包含指向這些上值的指針的數組。

> We fill the upvalue array over in the interpreter when it creates a closure. This is where we walk through all of the operands after `OP_CLOSURE` to see what kind of upvalue each slot captures.

當解釋器創建閉包時，我們會填充上值數組。在這裏，我們會遍歷`OP_CLOSURE`之後的所有操作數，以查看每個槽捕獲了什麼樣的上值。

*<u>vm.c，在run()方法中添加代碼：</u>*

```c
        push(OBJ_VAL(closure));
        // 新增部分開始
        for (int i = 0; i < closure->upvalueCount; i++) {
          uint8_t isLocal = READ_BYTE();
          uint8_t index = READ_BYTE();
          if (isLocal) {
            closure->upvalues[i] =
                captureUpvalue(frame->slots + index);
          } else {
            closure->upvalues[i] = frame->closure->upvalues[index];
          }
        }
        // 新增部分結束
        break;
```

> This code is the magic moment when a closure comes to life. We iterate over each upvalue the closure expects. For each one, we read a pair of operand bytes. If the upvalue closes over a local variable in the enclosing function, we let `captureUpvalue()` do the work.

這段代碼是閉包誕生的神奇時刻。我們遍歷了閉包所期望的每個上值。對於每個上值，我們讀取一對操作數字節。如果上值在外層函數的一個局部變量上關閉，我們就讓`captureUpvalue()`完成這項工作。

> Otherwise, we capture an upvalue from the surrounding function. An `OP_CLOSURE` instruction is emitted at the end of a function declaration. At the moment that we are executing that declaration, the *current* function is the surrounding one. That means the current function’s closure is stored in the CallFrame at the top of the callstack. So, to grab an upvalue from the enclosing function, we can read it right from the `frame` local variable, which caches a reference to that CallFrame.

否則，我們從外圍函數中捕獲一個上值。`OP_CLOSURE`指令是在函數聲明的末尾生成。在我們執行該聲明時，*當前*函數就是外圍的函數。這意味着當前函數的閉包存儲在調用棧頂部的CallFrame中。因此，要從外層函數中抓取上值，我們可以直接從局部變量`frame`中讀取，該變量緩存了一個對CallFrame的引用。

> Closing over a local variable is more interesting. Most of the work happens in a separate function, but first we calculate the argument to pass to it. We need to grab a pointer to the captured local’s slot in the surrounding function’s stack window. That window begins at `frame->slots`, which points to slot zero. Adding `index` offsets that to the local slot we want to capture. We pass that pointer here:

關閉局部變量更有趣。大部分工作發生在一個單獨的函數中，但首先我們要計算傳遞給它的參數。我們需要在外圍函數的棧窗口中抓取一個指向捕獲的局部變量槽的指針。該窗口起點在`frame->slots`，指向槽0。在其上添加`index`偏移量，以指向我們想要捕獲的局部變量槽。我們將該指針傳入這裏：

*<u>vm.c，在callValue()方法後添加代碼：</u>*

```c
static ObjUpvalue* captureUpvalue(Value* local) {
  ObjUpvalue* createdUpvalue = newUpvalue(local);
  return createdUpvalue;
}
```

> This seems a little silly. All it does is create a new ObjUpvalue that captures the given stack slot and returns it. Did we need a separate function for this? Well, no, not *yet*. But you know we are going to end up sticking more code in here.

這看起來有點傻。它所做的就是創建一個新的捕獲給定棧槽的ObjUpvalue，並將其返回。我們需要為此建一個單獨的函數嗎？嗯，不，*現在還*不用。但你懂的，我們最終會在這裏插入更多代碼。

> First, let’s wrap up what we’re working on. Back in the interpreter code for handling `OP_CLOSURE`, we eventually finish iterating through the upvalue array and initialize each one. When that completes, we have a new closure with an array full of upvalues pointing to variables.

首先，來總結一下我們的工作。回到處理`OP_CLOSURE`的解釋器代碼中，我們最終完成了對上值數組的迭代，並初始化了每個值。完成後，我們就有了一個新的閉包，它的數組中充滿了指向變量的上值。

> With that in hand, we can implement the instructions that work with those upvalues.

有了這個，我們就可以實現與這些上值相關的指令。

*<u>vm.c，在run()方法中添加代碼：</u>*

```c
      }
      // 新增部分開始
      case OP_GET_UPVALUE: {
        uint8_t slot = READ_BYTE();
        push(*frame->closure->upvalues[slot]->location);
        break;
      }
      // 新增部分結束
      case OP_EQUAL: {
```

> The operand is the index into the current function’s upvalue array. So we simply look up the corresponding upvalue and dereference its location pointer to read the value in that slot. Setting a variable is similar.

操作數是當前函數的上值數組的索引。因此，我們只需查找相應的上值，並對其位置指針解引用，以讀取該槽中的值。設置變量也是如此。

*<u>vm.c，在run()方法中添加代碼：</u>*

```c
      }
      // 新增部分開始
      case OP_SET_UPVALUE: {
        uint8_t slot = READ_BYTE();
        *frame->closure->upvalues[slot]->location = peek(0);
        break;
      }
      // 新增部分結束
      case OP_EQUAL: {
```

> We take the value on top of the stack and store it into the slot pointed to by the chosen upvalue. Just as with the instructions for local variables, it’s important that these instructions are fast. User programs are constantly reading and writing variables, so if that’s slow, everything is slow. And, as usual, the way we make them fast is by keeping them simple. These two new instructions are pretty good: no control flow, no complex arithmetic, just a couple of pointer indirections and a `push()`.

我們取棧頂的值，並將其存儲的選中的上值所指向的槽中。就像局部變量的指令一樣，這些指令的速度很重要。用户程序在不斷的讀寫變量，因此如果這個操作很慢，一切都會很慢。而且，像往常一樣，我們讓它變快的方法就是保持簡單。這兩條新指令非常好：沒有控制流，沒有複雜的算術，只有幾個指針間接引用和一個`push()`[^12]。

> This is a milestone. As long as all of the variables remain on the stack, we have working closures. Try this:

這是一個里程碑。只要所有的變量都留存在棧上，閉包就可以工作。試試這個：

```javascript
fun outer() {
  var x = "outside";
  fun inner() {
    print x;
  }
  inner();
}
outer();
```

> Run this, and it correctly prints “outside”.

運行這個，它就會正確地打印“outside”。

> ## 25 . 4 Closed Upvalues

## 25.4 關閉的上值

> Of course, a key feature of closures is that they hold on to the variable as long as needed, even after the function that declares the variable has returned. Here’s another example that *should* work:

當然，閉包的一個關鍵特性是，只要有需要，它們就會一直保留這個變量，即使聲明變量的函數已經返回。下面是另一個應該*有效*的例子：

```javascript
fun outer() {
  var x = "outside";
  fun inner() {
    print x;
  }

  return inner;
}

var closure = outer();
closure();
```

> But if you run it right now . . . who knows what it does? At runtime, it will end up reading from a stack slot that no longer contains the closed-over variable. Like I’ve mentioned a few times, the crux of the issue is that variables in closures don’t have stack semantics. That means we’ve got to hoist them off the stack when the function where they were declared returns. This final section of the chapter does that.

但是如果你現在運行它……天知道它會做什麼？在運行時，他會從不包含關閉變量的棧槽中讀取數據。正如我多次提到的，問題的關鍵在於閉包中的變量不具有棧語義。這意味着當聲明它們的函數返回時，我們必須將它們從棧中取出。本章的最後一節就是實現這一點的。

> ### 25 . 4 . 1 Values and variables

### 25.4.1 值與變量

> Before we get to writing code, I want to dig into an important semantic point. Does a closure close over a *value* or a *variable?* This isn’t purely an academic question. I’m not just splitting hairs. Consider:

在我們開始編寫代碼之前，我想深入探討一個重要的語義問題。閉包關閉的是一個*值*還是一個*變量*？這並不是一個純粹的學術問題[^13]。我並不是在胡攪蠻纏。考慮一下：

```javascript
var globalSet;
var globalGet;

fun main() {
  var a = "initial";

  fun set() { a = "updated"; }
  fun get() { print a; }

  globalSet = set;
  globalGet = get;
}

main();
globalSet();
globalGet();
```

> The outer `main()` function creates two closures and stores them in global variables so that they outlive the execution of `main()` itself. Both of those closures capture the same variable. The first closure assigns a new value to it and the second closure reads the variable.

外層的`main()`方法創建了兩個閉包，並將它們存儲在全局變量中，這樣它們的存活時間就比`main()`本身的執行時間更長。這兩個閉包都捕獲了相同的變量。第一個閉包為其賦值，第二個閉包則讀取該變量的值[^14]。

> What does the call to `globalGet()` print? If closures capture *values* then each closure gets its own copy of `a` with the value that `a` had at the point in time that the closure’s function declaration executed. The call to `globalSet()` will modify `set()`’s copy of `a`, but `get()`’s copy will be unaffected. Thus, the call to `globalGet()` will print “initial”.

調用`globalGet()`會打印什麼？如果閉包捕獲的是*值*，那麼每個閉包都會獲得自己的`a`副本，該副本的值為`a`在執行閉包函數聲明的時間點上的值。對`globalSet()`的調用會修改`set()`中的`a`副本，但是`get()`中的副本不受影響。因此，對`globalGet()`的調用會打印“initial”。

> If closures close over variables, then `get()` and `set()` will both capture—reference—the *same mutable variable*. When `set()` changes `a`, it changes the same `a` that `get()` reads from. There is only one `a`. That, in turn, implies the call to `globalGet()` will print “updated”.

如果閉包關閉的是變量，那麼`get()`和`set()`都會捕獲（引用）*同一個可變變量*。當`set()`修改`a`時，它改變的是`get()`所讀取的那個`a`。這裏只有一個`a`。這意味着對`globalGet()`的調用會打印“updated”。

> Which is it? The answer for Lox and most other languages I know with closures is the latter. Closures capture variables. You can think of them as capturing *the place the value lives*. This is important to keep in mind as we deal with closed-over variables that are no longer on the stack. When a variable moves to the heap, we need to ensure that all closures capturing that variable retain a reference to its *one* new location. That way, when the variable is mutated, all closures see the change.

到底是哪一個呢？對於Lox和我所知的其它大多數帶閉包的語言來説，答案是後者。閉包捕獲的是變量。你可以把它們看作是對*值所在位置*的捕獲。當我們處理不再留存於棧上的閉包變量時，這一點很重要，要牢牢記住。當一個變量移動到堆中時，我們需要確保所有捕獲該變量的閉包都保留對其新位置的引用。這樣一來，當變量發生變化時，所有閉包都能看到這個變化。

> ### 25 . 4 . 2 Closing upvalues

### 25.4.2 關閉上值

> We know that local variables always start out on the stack. This is faster, and lets our single-pass compiler emit code before it discovers the variable has been captured. We also know that closed-over variables need to move to the heap if the closure outlives the function where the captured variable is declared.

我們知道，局部變量總是從堆棧開始。這樣做更快，並且可以讓我們的單遍編譯器在發現變量被捕獲之前先生成字節碼。我們還知道，如果閉包的存活時間超過聲明被捕獲變量的函數，那麼封閉的變量就需要移動到堆中。

> Following Lua, we’ll use **open upvalue** to refer to an upvalue that points to a local variable still on the stack. When a variable moves to the heap, we are *closing* the upvalue and the result is, naturally, a **closed upvalue**. The two questions we need to answer are:

跟隨Lua，我們會使用**開放上值**來表示一個指向仍在棧中的局部變量的上值。當變量移動到堆中時，我們就*關閉*上值，而結果自然就是一個**關閉的上值**。我們需要回答兩個問題：

> 1. Where on the heap does the closed-over variable go?
> 2. When do we close the upvalue?

1. 被關閉的變量放在堆中的什麼位置？
2. 我們什麼時候關閉上值？

> The answer to the first question is easy. We already have a convenient object on the heap that represents a reference to a variable—ObjUpvalue itself. The closed-over variable will move into a new field right inside the ObjUpvalue struct. That way we don’t need to do any additional heap allocation to close an upvalue.

第一個問題的答案很簡單。我們在堆上已經有了一個便利的對象，它代表了對某個變量（ObjUpvalue本身）的引用。被關閉的變量將移動到ObjUpvalue結構體中的一個新字段中。這樣一來，我們不需要做任何額外的堆分配來關閉上值。

> The second question is straightforward too. As long as the variable is on the stack, there may be code that refers to it there, and that code must work correctly. So the logical time to hoist the variable to the heap is as late as possible. If we move the local variable right when it goes out of scope, we are certain that no code after that point will try to access it from the stack. After the variable is out of scope, the compiler will have reported an error if any code tried to use it.

第二個問題也很直截了當。只要變量在棧中，就可能存在引用它的代碼，而且這些代碼必須能夠正確工作。因此，將變量提取到堆上的邏輯時間越晚越好。如果我們在局部變量超出作用域時將其移出，我們可以肯定，在那之後沒有任何代碼會試圖從棧中訪問它。在變量超出作用域之後[^15]，如果有任何代碼試圖訪問它，編譯器就會報告一個錯誤。

> The compiler already emits an `OP_POP` instruction when a local variable goes out of scope. If a variable is captured by a closure, we will instead emit a different instruction to hoist that variable out of the stack and into its corresponding upvalue. To do that, the compiler needs to know which locals are closed over.

當局部變量超出作用域時，編譯器已經生成了`OP_POP`指令[^16]。如果變量被某個閉包捕獲，我們會發出一條不同的指令，將該變量從棧中提取到其對應的上值。為此，編譯器需要知道哪些局部變量被關閉了。

> The compiler already maintains an array of Upvalue structs for each local variable in the function to track exactly that state. That array is good for answering “Which variables does this closure use?” But it’s poorly suited for answering, “Does *any* function capture this local variable?” In particular, once the Compiler for some closure has finished, the Compiler for the enclosing function whose variable has been captured no longer has access to any of the upvalue state.

編譯器已經為函數中的每個局部變量維護了一個Upvalue結構體的數組，以便準確地跟蹤該狀態。這個數組很好地回答了“這個閉包使用了哪個變量”，但他不適合回答“是否有*任何*函數捕獲了這個局部變量？”特別是，一旦某個閉包的Compiler 執行完成，變量被捕獲的外層函數的Compiler就不能再訪問任何上值狀態了。

> In other words, the compiler maintains pointers from upvalues to the locals they capture, but not in the other direction. So we first need to add some extra tracking inside the existing Local struct so that we can tell if a given local is captured by a closure.

換句話説，編譯器保持着從上值指向它們捕獲的局部變量的指針，而沒有相反方向的指針。所以，我們首先需要在現有的Local結構體中添加額外的跟蹤信息，這樣我們就能夠判斷某個給定的局部變量是否被某個閉包捕獲。

*<u>compiler.c，在Local結構體中添加代碼：</u>*

```c
  int depth;
  // 新增部分開始
  bool isCaptured;
  // 新增部分結束
} Local;
```

> This field is `true` if the local is captured by any later nested function declaration. Initially, all locals are not captured.

如果局部變量被後面嵌套的任何函數聲明捕獲，字段則為`true`。最初，所有的局部數據都沒有被捕獲。

*<u>compiler.c，在addLocal()方法中添加代碼：</u>*

```c
  local->depth = -1;
  // 新增部分開始
  local->isCaptured = false;
  // 新增部分結束
}
```

> Likewise, the special “slot zero local” that the compiler implicitly declares is not captured.

同樣地，編譯器隱式聲明的特殊的“槽0中的局部變量”不會被捕獲[^17]。

*<u>compiler.c，在initCompiler()方法中添加代碼：</u>*

```c
  local->depth = 0;
  // 新增部分開始
  local->isCaptured = false;
  // 新增部分結束
  local->name.start = "";
```

> When resolving an identifier, if we end up creating an upvalue for a local variable, we mark it as captured.

在解析標識符時，如果我們最終為某個局部變量創建了一個上值，我們將其標記為已捕獲。

*<u>compiler.c，在resolveUpvalue()方法中添加代碼：</u>*

```c
  if (local != -1) {
    // 新增部分開始
    compiler->enclosing->locals[local].isCaptured = true;
    // 新增部分結束
    return addUpvalue(compiler, (uint8_t)local, true);
```

> Now, at the end of a block scope when the compiler emits code to free the stack slots for the locals, we can tell which ones need to get hoisted onto the heap. We’ll use a new instruction for that.

現在，在塊作用域的末尾，當編譯器生成字節碼來釋放局部變量的棧槽時，我們可以判斷哪些數據需要被提取到堆中。我們將使用一個新指令來實現這一點。

*<u>compiler.c，在endScope()方法中，替換1行：</u>*

```c
  while (current->localCount > 0 &&
         current->locals[current->localCount - 1].depth >
            current->scopeDepth) {  
    // 新增部分開始
    if (current->locals[current->localCount - 1].isCaptured) {
      emitByte(OP_CLOSE_UPVALUE);
    } else {
      emitByte(OP_POP);
    }
    // 新增部分結束
    current->localCount--;
  }
```

> The instruction requires no operand. We know that the variable will always be right on top of the stack at the point that this instruction executes. We declare the instruction.

這個指令不需要操作數。我們知道，在該指令執行時，變量一定在棧頂。我們來聲明這條指令。

*<u>chunk.h，在枚舉OpCode中添加代碼：</u>*

```c
  OP_CLOSURE,
  // 新增部分開始
  OP_CLOSE_UPVALUE,
  // 新增部分結束
  OP_RETURN,
```

> And add trivial disassembler support for it:

併為它添加簡單的反彙編支持：

*<u>debug.c，在disassembleInstruction()方法中添加代碼：</u>*

```c
    }
    // 新增部分開始
    case OP_CLOSE_UPVALUE:
      return simpleInstruction("OP_CLOSE_UPVALUE", offset);
    // 新增部分結束
    case OP_RETURN:
```

> Excellent. Now the generated bytecode tells the runtime exactly when each captured local variable must move to the heap. Better, it does so only for the locals that *are* used by a closure and need this special treatment. This aligns with our general performance goal that we want users to pay only for functionality that they use. Variables that aren’t used by closures live and die entirely on the stack just as they did before.

太好了。現在，生成的字節碼準確地告訴運行時，每個被捕獲的局部變量必須移動到堆中的確切時間。更好的是，它只對被閉包使用並需要這種特殊處理的局部變量才會這樣做。這與我們的總體性能目標是一致的，即我們希望用户只為他們使用的功能付費。那些不被閉包使用的變量只會出現於棧中，就像以前一樣。

> ### 25 . 4 . 3 Tracking open upvalues

### 25.4.3 跟蹤開放的上值

> Let’s move over to the runtime side. Before we can interpret `OP_CLOSE_UPVALUE` instructions, we have an issue to resolve. Earlier, when I talked about whether closures capture variables or values, I said it was important that if multiple closures access the same variable that they end up with a reference to the exact same storage location in memory. That way if one closure writes to the variable, the other closure sees the change.

讓我們轉到運行時方面。在解釋`OP_CLOSE_UPVALUE`指令之前，我們還有一個問題需要解決。之前，在談到閉包捕獲的是變量還是值時，我説過，如果多個閉包訪問同一個變量，它們最終將引用內存中完全相同的存儲位置，這一點很重要。這樣一來，如果某個閉包對變量進行寫入，另一個閉包就會看到這一變化。

> Right now, if two closures capture the same local variable, the VM creates a separate Upvalue for each one. The necessary sharing is missing. When we move the variable off the stack, if we move it into only one of the upvalues, the other upvalue will have an orphaned value.

現在，如果兩個閉包捕獲同一個局部變量，虛擬機就會為每個閉包創建一個單獨的Upvalue。必要的共享是缺失的[^18]。當我們把變量移出堆棧時，如果我們只是將它移入其中一個上值中，其它上值就會有一個孤兒值。

> To fix that, whenever the VM needs an upvalue that captures a particular local variable slot, we will first search for an existing upvalue pointing to that slot. If found, we reuse that. The challenge is that all of the previously created upvalues are squirreled away inside the upvalue arrays of the various closures. Those closures could be anywhere in the VM’s memory.

為了解決這個問題，每當虛擬機需要一個捕獲特定局部變量槽的上值時，我們會首先搜索指向該槽的現有上值。如果找到了，我們就重用它。難點在於，之前創建的所有上值都存儲在各個閉包的上值數組中。這些閉包可能位於虛擬機內存中的任何位置。

> The first step is to give the VM its own list of all open upvalues that point to variables still on the stack. Searching a list each time the VM needs an upvalue sounds like it might be slow, but in practice, it’s not bad. The number of variables on the stack that actually get closed over tends to be small. And function declarations that create closures are rarely on performance critical execution paths in the user’s program.

第一步是給虛擬機提供它自己的所有開放上值的列表，這些上值指向仍在棧中的變量。每次虛擬機需要一個上值時，都要搜索列表，這聽起來似乎很慢，但是實際上，這並沒有那麼壞。棧中真正被關閉的變量的數量往往很少。而且創建閉包的函數聲明很少出現在用户程序中的性能關鍵執行路徑上[^19]。

> Even better, we can order the list of open upvalues by the stack slot index they point to. The common case is that a slot has *not* already been captured—sharing variables between closures is uncommon—and closures tend to capture locals near the top of the stack. If we store the open upvalue array in stack slot order, as soon as we step past the slot where the local we’re capturing lives, we know it won’t be found. When that local is near the top of the stack, we can exit the loop pretty early.

更妙的是，我們可以根據開放上值所指向的棧槽索引對列表進行排序。常見的情況是，某個棧槽還*沒有*被捕獲（在閉包之間共享變量是不常見的），而閉包傾向於捕獲靠近棧頂的局部變量。如果我們按照棧槽的順序存儲開放上值數組，一旦我們越過正在捕獲的局部變量所在的槽，我們就知道它不會被找到。當這個局部變量在棧頂時，我們可以很早就退出循環。

> Maintaining a sorted list requires inserting elements in the middle efficiently. That suggests using a linked list instead of a dynamic array. Since we defined the ObjUpvalue struct ourselves, the easiest implementation is an intrusive list that puts the next pointer right inside the ObjUpvalue struct itself.

維護有序列表需要能高效地在中間插入元素。這一點建議我們使用鏈表而不是動態數組。因為我們自己定義了ObjUpvalue結構體，最簡單的實現是一個插入式列表，將指向下一元素的指針放在ObjUpvalue結構體本身中。

*<u>object.h，在結構體ObjUpvalue中添加代碼：</u>*

```c
  Value* location;
  // 新增部分開始
  struct ObjUpvalue* next;
  // 新增部分結束
} ObjUpvalue;
```

> When we allocate an upvalue, it is not attached to any list yet so the link is `NULL`.

當我們分配一個上值時，它還沒有附加到任何列表，因此鏈接是`NULL`。

*<u>object.c，在newUpvalue()方法中添加代碼：</u>*

```c
  upvalue->location = slot;
  // 新增部分開始
  upvalue->next = NULL;
  // 新增部分結束
  return upvalue;
```

> The VM owns the list, so the head pointer goes right inside the main VM struct.

VM擁有該列表，因此頭指針放在VM主結構體中。

*<u>vm.h，在結構體VM中添加代碼：</u>*

```c
  Table strings;
  // 新增部分開始
  ObjUpvalue* openUpvalues;
  // 新增部分結束
  Obj* objects;
```

> The list starts out empty.

列表在開始時為空。

*<u>vm.c，在resetStack()方法中添加代碼：</u>*

```c
  vm.frameCount = 0;
  // 新增部分開始
  vm.openUpvalues = NULL;
  // 新增部分結束
}
```

> Starting with the first upvalue pointed to by the VM, each open upvalue points to the next open upvalue that references a local variable farther down the stack. This script, for example,

從VM指向的第一個上值開始，每個開放上值都指向下一個引用了棧中靠下位置的局部變量的開放上值。以這個腳本為例

```javascript
{
  var a = 1;
  fun f() {
    print a;
  }
  var b = 2;
  fun g() {
    print b;
  }
  var c = 3;
  fun h() {
    print c;
  }
}
```

> should produce a series of linked upvalues like so:

它應該產生如下所示的一系列鏈接的上值：

![Three upvalues in a linked list.](25.閉包/linked-list.png)

> Whenever we close over a local variable, before creating a new upvalue, we look for an existing one in the list.

每當關閉一個局部變量時，在創建新的上值之前，先在該列表中查找現有的上值。

*<u>vm.c，在captureUpvalue()方法中添加代碼：</u>*

```c
static ObjUpvalue* captureUpvalue(Value* local) {
  // 新增部分開始
  ObjUpvalue* prevUpvalue = NULL;
  ObjUpvalue* upvalue = vm.openUpvalues;
  while (upvalue != NULL && upvalue->location > local) {
    prevUpvalue = upvalue;
    upvalue = upvalue->next;
  }

  if (upvalue != NULL && upvalue->location == local) {
    return upvalue;
  }
  // 新增部分結束
  ObjUpvalue* createdUpvalue = newUpvalue(local);
```

> We start at the head of the list, which is the upvalue closest to the top of the stack. We walk through the list, using a little pointer comparison to iterate past every upvalue pointing to slots above the one we’re looking for. While we do that, we keep track of the preceding upvalue on the list. We’ll need to update that node’s `next` pointer if we end up inserting a node after it.

我們從列表的頭部開始，它是最接近棧頂的上值。我們遍歷列表，使用一個小小的指針比較，對每一個指向的槽位高於當前查找的位置的上值進行迭代[^20]。當我們這樣做時，我們要跟蹤列表中前面的上值。如果我們在某個節點後面插入了一個節點，就需要更新該節點的`next`指針。

> There are three reasons we can exit the loop:

我們有三個原因可以退出循環：

1. > **The local slot we stopped at \*is\* the slot we’re looking for.** We found an existing upvalue capturing the variable, so we reuse that upvalue.

   **我們停止時的局部變量槽是我們要找的槽**。我在找到了一個現有的上值捕獲了這個變量，因此我們重用這個上值。

2. > **We ran out of upvalues to search.** When `upvalue` is `NULL`, it means every open upvalue in the list points to locals above the slot we’re looking for, or (more likely) the upvalue list is empty. Either way, we didn’t find an upvalue for our slot.

   **我們找不到需要搜索的上值了**。當`upvalue`為`NULL`時，這意味着列表中每個開放上值都指向位於我們要找的槽之上的局部變量，或者（更可能是）上值列表是空的。無論怎樣，我們都沒有找到對應該槽的上值。

3. > **We found an upvalue whose local slot is \*below\* the one we’re looking for.** Since the list is sorted, that means we’ve gone past the slot we are closing over, and thus there must not be an existing upvalue for it.

   **我們找到了一個上值，其局部變量槽低於我們正查找的槽位**。因為列表是有序的，這意味着我們已經超過了正在關閉的槽，因此肯定沒有對應該槽的已有上值。

> In the first case, we’re done and we’ve returned. Otherwise, we create a new upvalue for our local slot and insert it into the list at the right location.

在第一種情況下，我們已經完成並且返回了。其它情況下，我們為局部變量槽創建一個新的上值，並將其插入到列表中的正確位置。

*<u>vm.c，在captureUpvalue()方法中添加代碼：</u>*

```c
  ObjUpvalue* createdUpvalue = newUpvalue(local);
  // 新增部分開始
  createdUpvalue->next = upvalue;

  if (prevUpvalue == NULL) {
    vm.openUpvalues = createdUpvalue;
  } else {
    prevUpvalue->next = createdUpvalue;
  }
  // 新增部分結束
  return createdUpvalue;
```

> The current incarnation of this function already creates the upvalue, so we only need to add code to insert the upvalue into the list. We exited the list traversal by either going past the end of the list, or by stopping on the first upvalue whose stack slot is below the one we’re looking for. In either case, that means we need to insert the new upvalue *before* the object pointed at by `upvalue` (which may be `NULL` if we hit the end of the list).

這個函數的當前版本已經創建了上值，我們只需要添加代碼將上值插入到列表中。我們退出列表遍歷的原因，要麼是到達了列表末尾，要麼是停在了第一個棧槽低於待查找槽位的上值。無論哪種情況，這都意味着我們需要在`upvalue`指向的對象（如果到達列表的末尾，則該對象可能是`NULL`）之前插入新的上值。

> As you may have learned in Data Structures 101, to insert a node into a linked list, you set the `next` pointer of the previous node to point to your new one. We have been conveniently keeping track of that preceding node as we walked the list. We also need to handle the special case where we are inserting a new upvalue at the head of the list, in which case the “next” pointer is the VM’s head pointer.

正如你在《數據結構101》中所學到的，要將一個節點插入到鏈表中，你需要將前一個節點的`next`指針指向新的節點。當我們遍歷列表時，我們一直很方便地跟蹤着前面的節點。我們還需要處理一種特殊情況，即我們在列表頭部插入一個新的上值，在這種情況下，“next”指針是VM的頭指針[^21]。

> With this updated function, the VM now ensures that there is only ever a single ObjUpvalue for any given local slot. If two closures capture the same variable, they will get the same upvalue. We’re ready to move those upvalues off the stack now.

有了這個升級版函數，VM現在可以確保每個指定的局部變量槽都只有一個ObjUpvalue。如果兩個閉包捕獲了相同的變量，它們會得到相同的上值。現在，我們準備將這些上值從棧中移出。

> ### 25 . 4 . 4 Closing upvalues at runtime

### 25.4.4 在運行時關閉上值

> The compiler helpfully emits an `OP_CLOSE_UPVALUE` instruction to tell the VM exactly when a local variable should be hoisted onto the heap. Executing that instruction is the interpreter’s responsibility.

編譯器會生成一個有用的`OP_CLOSE_UPVALUE`指令，以準確地告知VM何時將局部變量提取到堆中。執行該指令是解釋器的責任。

*<u>vm.c，在run()方法中添加代碼：</u>*

```c
      }
      // 新增部分開始
      case OP_CLOSE_UPVALUE:
        closeUpvalues(vm.stackTop - 1);
        pop();
        break;
      // 新增部分結束  
      case OP_RETURN: {
```

> When we reach the instruction, the variable we are hoisting is right on top of the stack. We call a helper function, passing the address of that stack slot. That function is responsible for closing the upvalue and moving the local from the stack to the heap. After that, the VM is free to discard the stack slot, which it does by calling `pop()`.

當我們到達該指令時，我們要提取的變量就在棧頂。我們調用一個輔助函數，傳入棧槽的地址。該函數負責關閉上值，並將局部變量從棧中移動到堆上。之後，VM就可以自由地丟棄棧槽，這是通過調用`pop()`實現的。

> The fun stuff happens here:

有趣的事情發生在這裏：

*<u>vm.c，在captureUpvalue()方法後添加代碼：</u>*

```c
static void closeUpvalues(Value* last) {
  while (vm.openUpvalues != NULL &&
         vm.openUpvalues->location >= last) {
    ObjUpvalue* upvalue = vm.openUpvalues;
    upvalue->closed = *upvalue->location;
    upvalue->location = &upvalue->closed;
    vm.openUpvalues = upvalue->next;
  }
}
```

> This function takes a pointer to a stack slot. It closes every open upvalue it can find that points to that slot or any slot above it on the stack. Right now, we pass a pointer only to the top slot on the stack, so the “or above it” part doesn’t come into play, but it will soon.

這個函數接受一個指向棧槽的指針。它會關閉它能找到的指向該槽或棧上任何位於該槽上方的所有開放上值。現在，我們只傳遞了一個指向棧頂的指針，所以“或其上方”的部分沒有發揮作用，但它很快就會起作用了。

> To do this, we walk the VM’s list of open upvalues, again from top to bottom. If an upvalue’s location points into the range of slots we’re closing, we close the upvalue. Otherwise, once we reach an upvalue outside of the range, we know the rest will be too, so we stop iterating.

為此，我們再次從上到下遍歷VM的開放上值列表。如果某個上值的位置指向我們要關閉的槽位範圍，則關閉該上值。否則，一旦我們遇到範圍之外的上值，我們知道其它上值也在範圍之外，所以我們停止迭代。

> The way an upvalue gets closed is pretty cool. First, we copy the variable’s value into the `closed` field in the ObjUpvalue. That’s where closed-over variables live on the heap. The `OP_GET_UPVALUE` and `OP_SET_UPVALUE` instructions need to look for the variable there after it’s been moved. We could add some conditional logic in the interpreter code for those instructions to check some flag for whether the upvalue is open or closed.

關閉上值的方式非常酷[^22]。首先，我們將變量的值複製到ObjUpvalue的`closed`字段。這就是被關閉的變量在堆中的位置。在變量被移動之後，`OP_GET_UPVALUE`和`OP_SET_UPVALUE`指令需要在那裏查找它。我們可以在解釋器代碼中為這些指令添加一些條件邏輯，檢查一些標誌，以確定上值是開放的還是關閉的。

> But there is already a level of indirection in play—those instructions dereference the `location` pointer to get to the variable’s value. When the variable moves from the stack to the `closed` field, we simply update that `location` to the address of the ObjUpvalue’s *own* `closed` field.

但是已經有一箇中間層在起作用了——這些指令對`location`指針解引用以獲取變量的值。當變量從棧移動到`closed`字段時，我們只需將`location`更新為ObjUpvalue*自己的*`closed`字段。

![Moving a value from the stack to the upvalue's 'closed' field and then pointing the 'value' field to it.](25.閉包/closing.png)

> We don’t need to change how `OP_GET_UPVALUE` and `OP_SET_UPVALUE` are interpreted at all. That keeps them simple, which in turn keeps them fast. We do need to add the new field to ObjUpvalue, though.

我們根本不需要改變`OP_GET_UPVALUE`和`OP_SET_UPVALUE`的解釋方式。這使得它們保持簡單，反過來又使它們保持快速。不過，我們確實需要向ObjUpvalue添加新的字段。

*<u>object.h，在結構體ObjUpvalue中添加代碼：</u>*

```c
  Value* location;
  // 新增部分開始
  Value closed;
  // 新增部分結束
  struct ObjUpvalue* next;
```

> And we should zero it out when we create an ObjUpvalue so there’s no uninitialized memory floating around.

當我們創建一個ObjUpvalue時，應該將其置為0，這樣就不會有未初始化的內存了。

*<u>object.c，在newUpvalue()方法中添加代碼：</u>*

```c
  ObjUpvalue* upvalue = ALLOCATE_OBJ(ObjUpvalue, OBJ_UPVALUE);
  // 新增部分開始
  upvalue->closed = NIL_VAL;
  // 新增部分結束
  upvalue->location = slot;
```

> Whenever the compiler reaches the end of a block, it discards all local variables in that block and emits an `OP_CLOSE_UPVALUE` for each local variable that was closed over. The compiler does *not* emit any instructions at the end of the outermost block scope that defines a function body. That scope contains the function’s parameters and any locals declared immediately inside the function. Those need to get closed too.

每當編譯器到達一個塊的末尾時，它就會丟棄該代碼塊中的所有局部變量，併為每個關閉的局部變量生成一個`OP_CLOSE_UPVALUE`指令。編譯器*不會*在定義某個函數主體的最外層塊作用域的末尾生成任何指令[^23]。這個作用域包含函數的形參和函數內部聲明的任何局部變量。這些也需要被關閉。

> This is the reason `closeUpvalues()` accepts a pointer to a stack slot. When a function returns, we call that same helper and pass in the first stack slot owned by the function.

這就是`closeUpvalues()`接受一個指向棧槽的指針的原因。當函數返回時，我們調用相同的輔助函數，並傳入函數擁有的第一個棧槽。

*<u>vm.c，在run()方法中添加代碼：</u>*

```c
        Value result = pop();
        // 新增部分開始
        closeUpvalues(frame->slots);
        // 新增部分結束
        vm.frameCount--;
```

> By passing the first slot in the function’s stack window, we close every remaining open upvalue owned by the returning function. And with that, we now have a fully functioning closure implementation. Closed-over variables live as long as they are needed by the functions that capture them.

通過傳遞函數棧窗口中的第一個槽，我們關閉了正在返回的函數所擁有的所有剩餘的開放上值。有了這些，我們現在就有了一個功能齊全的閉包實現。只要捕獲變量的函數需要，被關閉的變量就一直存在。

> This was a lot of work! In jlox, closures fell out naturally from our environment representation. In clox, we had to add a lot of code—new bytecode instructions, more data structures in the compiler, and new runtime objects. The VM very much treats variables in closures as different from other variables.

這是一項艱鉅的工作！在jlox中，閉包很自然地從我們的環境表示形式中分離出來。在clox中，我們必須添加大量的代碼——新的字節碼指令、編譯器中的更多數據結構和新的運行時對象。VM在很大程度上將閉包中的變量與其它變量進行區別對待。

> There is a rationale for that. In terms of implementation complexity, jlox gave us closures “for free”. But in terms of *performance*, jlox’s closures are anything but. By allocating *all* environments on the heap, jlox pays a significant performance price for *all* local variables, even the majority which are never captured by closures.

這是有道理的。就實現複雜性而言，jlox“免費”為我們提供了閉包。但是就*性能*而言，jlox的閉包完全不是這樣。由於在堆上分配*所有*環境，jlox為*所有*局部變量付出了顯著的性能代價，甚至是未被閉包捕獲的大部分變量。

> With clox, we have a more complex system, but that allows us to tailor the implementation to fit the two use patterns we observe for local variables. For most variables which do have stack semantics, we allocate them entirely on the stack which is simple and fast. Then, for the few local variables where that doesn’t work, we have a second slower path we can opt in to as needed.

在clox中，我們有一個更復雜的系統，但這允許我們對實現進行調整以適應我們觀察到的局部變量的兩種使用模式。對於大多數具有堆棧語義的變量，我們完全可用在棧中分配，這既簡單又快速。然後，對於少數不適用的局部變量，我們可以根據需要選擇第二條較慢的路徑。

> Fortunately, users don’t perceive the complexity. From their perspective, local variables in Lox are simple and uniform. The *language itself* is as simple as jlox’s implementation. But under the hood, clox is watching what the user does and optimizing for their specific uses. As your language implementations grow in sophistication, you’ll find yourself doing this more. A large fraction of “optimization” is about adding special case code that detects certain uses and provides a custom-built, faster path for code that fits that pattern.

幸運的是，用户並不會察覺到這種複雜性。在他們看來，Lox中的局部變量簡單而統一。語言本身就像jlox一樣簡單。但在內部，clox會觀察用户的行為，並針對他們的具體用途進行優化。隨着你的語言實現越來越複雜，你會發現自己要做的事情越來越多。“優化”的很大一部分是關於添加特殊情況的代碼，以檢測特定的使用，併為符合該模式的代碼提供定製化的、更快速的路徑。

> We have lexical scoping fully working in clox now, which is a major milestone. And, now that we have functions and variables with complex lifetimes, we also have a *lot* of objects floating around in clox’s heap, with a web of pointers stringing them together. The [next step](http://www.craftinginterpreters.com/garbage-collection.html) is figuring out how to manage that memory so that we can free some of those objects when they’re no longer needed.

我們現在已經在clox中完全實現了詞法作用域，這是一個重要的里程碑。而且，現在我們有了具有複雜生命週期的函數和變量，我們也要了很多漂浮在clox堆中的對象，並有一個指針網絡將它們串聯起來。下一步是弄清楚如何管理這些內存，以便我們可以在不再需要這些對象的時候釋放它們。



[^1]: 畢竟，C和Java使用棧來存儲局部變量是有原因的。
[^2]: 搜索“閉包轉換 closure conversion”和“Lambda提升 lambda lifting”就可以開始探索了。
[^3]: 換句話説，Lox中的函數聲明是一種字面量——定義某個內置類型的常量值的一段語法。
[^4]: Lua實現中將包含字節碼的原始函數對象稱為“原型”，這個一個很好的形容詞，只不過這個詞也被重載以指代[原型繼承](https://en.wikipedia.org/wiki/Prototype-based_programming)。
[^5]: 或許我應該定義一個宏，以便更容易地生成這些宏。也許這有點太玄了。
[^6]: 這段代碼看起來有點傻，因為我們仍然把原始的ObjFunction壓入棧中，然後在創建完閉包之後彈出它，然後再將閉包壓入棧。為什麼要把ObjFunction放在這裏呢？像往常一樣，當你看到奇怪的堆棧操作發生時，它是為了讓即將到來的垃圾回收器知道一些堆分配的對象。
[^7]: 它最終可能會是一個完全未定義的變量，甚至不是全局變量。但是在Lox中，我們直到運行時才能檢測到這個錯誤，所以從編譯器的角度看，它是“期望是全局的”。
[^8]: 就像常量和函數元數一樣，上值計數也是連接編譯器與運行時的一些小數據。
[^9]: 當然，另一種基本情況是，沒有外層函數。在這種情況下，該變量不能在詞法上解析，並被當作全局變量處理。
[^10]: 每次遞歸調用`resolveUpvalue()`都會*走出*一層函數嵌套。因此，內部的*遞歸調用*指向的是*外部*的嵌套聲明。查找局部變量的最內層的`resolveUpvalue()`遞歸調用對應的將是*最外層*的函數，就是實際聲明該變量的外層函數的內部。
[^11]: 在閉包中存儲上值數量是多餘的，因為ObjClosure引用的ObjFunction也保存了這個數量。通常，這類奇怪的代碼是為了適應GC。在閉包對應的ObjFunction已經被釋放後，收集器可能也需要知道ObjClosure對應上值數組的大小。
[^12]: 設置指令不會從棧中*彈出*值，因為，請記住，賦值在Lox中是一個表達式。所以賦值的結果（所賦的值）需要保留在棧中，供外圍的表達式使用。
[^13]: 如果Lox不允許賦值，這就是一個學術問題。
[^14]: 我使用了多個全局變量的事實並不重要。我需要某種方式從一個函數中返回兩個值。而在Lox中沒有任何形式的聚合類型，我的選擇很有限。
[^15]: 這裏 的“之後”，指的是詞法或文本意義上的——在包含關閉變量的聲明語句的代碼塊的`}`之後的代碼。
[^16]: 編譯器不會彈出參數和在函數體中聲明的局部變量。這些我們也會在運行時處理。
[^17]: 在本書的後面部分，用户將有可能捕獲這個變量。這裏只是建立一些預期。
[^18]: 如果某個閉包從外圍函數中捕獲了一個*上值*，那麼虛擬機確實會共享上值。嵌套的情況下，工作正常。但是如果兩個同級閉包捕獲了同一個局部變量，它們會各自創建一個單獨的ObjUpvalue。
[^19]: 閉包經常在熱循環中被*調用*。想想傳遞給集合的典型高階函數，如`map()`和`filter()`。這應該是很快的。但是創建閉包的函數聲明只發生一次，而且通常是在循環之外。
[^20]: 這是個單鏈表。除了從頭指針開始遍歷，我們沒有其它選擇。
[^21]: 還有一種更簡短的實現，通過使用一個指向指針的指針，來統一處理更新頭部指針或前一個上值的`next`指針兩種情況，但這種代碼幾乎會讓所有未達到指針專業水平的人感到困惑。我選擇了基本的`if`語句的方法。
[^22]: 我並不是在自誇。這都是Lua開發團隊的創新。
[^23]: 沒有什麼*阻止*我們在編譯器中關閉最外層的函數作用域，並生成`OP_POP`和`OP_CLOSE_UPVALUE`指令。這樣做只是沒有必要，因為運行時在彈出調用幀時，隱式地丟棄了函數使用的所有棧槽。



---

## 習題

1. > Wrapping every ObjFunction in an ObjClosure introduces a level of indirection that has a performance cost. That cost isn’t necessary for functions that do not close over any variables, but it does let the runtime treat all calls uniformly.
   >
   > Change clox to only wrap functions in ObjClosures that need upvalues. How does the code complexity and performance compare to always wrapping functions? Take care to benchmark programs that do and do not use closures. How should you weight the importance of each benchmark? If one gets slower and one faster, how do you decide what trade-off to make to choose an implementation strategy?

   將每個ObjFunction 包裝在ObjClosure中，會引入一個有性能代價的中間層。這個代價對於那些沒有關閉任何變量的函數來説是不必要的，但它確實讓運行時能夠統一處理所有的調用。

   將clox改為只用ObjClosure包裝需要上值的函數。與包裝所有函數相比，代碼的複雜性與性能如何？請注意對使用閉包和不使用閉包的程序進行基準測試。你應該如何衡量每個基準的重要性？如果一個變慢了，另一個變快了，你決定通過什麼權衡來選擇實現策略？

2. > Read the design note below. I’ll wait. Now, how do you think Lox *should* behave? Change the implementation to create a new variable for each loop iteration.

   請閲讀下面的[設計筆記](#設計筆記：關閉循環變量)。我在這裏等着。現在，你覺得Lox應該怎麼做？改變實現方式，為每個循環迭代創建一個新的變量。

3. > A [famous koan](http://wiki.c2.com/?ClosuresAndObjectsAreEquivalent) teaches us that “objects are a poor man’s closure” (and vice versa). Our VM doesn’t support objects yet, but now that we have closures we can approximate them. Using closures, write a Lox program that models two-dimensional vector “objects”. It should:
   >
   > - Define a “constructor” function to create a new vector with the given *x* and *y* coordinates.
   > - Provide “methods” to access the *x* and *y* coordinates of values returned from that constructor.
   > - Define an addition “method” that adds two vectors and produces a third.

   一個[著名的公案](http://wiki.c2.com/?ClosuresAndObjectsAreEquivalent)告訴我們：“對象是簡化版的閉包”（反之亦然）。我們的虛擬機還不支持對象，但現在我們有了閉包，我們可以近似地使用它們。使用閉包，編寫一個Lox程序，建模一個二維矢量“對象”。它應該：

   * 定義一個“構造器”函數，創建一個具有給定x和y座標的新矢量。
   * 提供“方法”來訪問構造函數返回值的x和y座標。
   * 定義一個相加“方法”，將兩個向量相加併產生第三個向量。



---

## 設計筆記：關閉循環變量

> Closures capture variables. When two closures capture the same variable, they share a reference to the same underlying storage location. This fact is visible when new values are assigned to the variable. Obviously, if two closures capture *different* variables, there is no sharing.

閉包捕獲變量。當兩個閉包捕獲相同的變量時，它們共享對相同的底層存儲位置的引用。當將新值賦給該變量時，這一事實是可見的。顯然，如果兩個閉包捕獲*不同*的變量，就不存在共享。

```javascript
var globalOne;
var globalTwo;

fun main() {
  {
    var a = "one";
    fun one() {
      print a;
    }
    globalOne = one;
  }

  {
    var a = "two";
    fun two() {
      print a;
    }
    globalTwo = two;
  }
}

main();
globalOne();
globalTwo();
```

> This prints “one” then “two”. In this example, it’s pretty clear that the two `a` variables are different. But it’s not always so obvious. Consider:

這裏會打印“one”然後是“two”。在這個例子中，很明顯兩個`a`變量是不同的。但一點這並不總是那麼明顯。考慮一下：

```javascript
var globalOne;
var globalTwo;

fun main() {
  for (var a = 1; a <= 2; a = a + 1) {
    fun closure() {
      print a;
    }
    if (globalOne == nil) {
      globalOne = closure;
    } else {
      globalTwo = closure;
    }
  }
}

main();
globalOne();
globalTwo();
```

> The code is convoluted because Lox has no collection types. The important part is that the `main()` function does two iterations of a `for` loop. Each time through the loop, it creates a closure that captures the loop variable. It stores the first closure in `globalOne` and the second in `globalTwo`.

這段代碼很複雜，因為Lox沒有集合類型。重要的部分是，`main()`函數進行了`for`循環的兩次迭代。每次循環執行時，它都會創建一個捕獲循環變量的閉包。它將第一個閉包存儲在`globalOne`中，並將第二個閉包存儲在`globalTwo`中。

> There are definitely two different closures. Do they close over two different variables? Is there only one `a` for the entire duration of the loop, or does each iteration get its own distinct `a` variable?

這無疑是兩個不同的閉包。它們是在兩個不同的變量上閉合的嗎？在整個循環過程中只有一個`a`，還是每個迭代都有自己單獨的`a`變量？

> The script here is strange and contrived, but this does show up in real code in languages that aren’t as minimal as clox. Here’s a JavaScript example:

這裏的腳本很奇怪，而且是人為設計的，但它確實出現在實際的代碼中，而且這些代碼使用的語言並不是像clox這樣的小語言。下面是一個JavaScript的示例：

```javascript
var closures = [];
for (var i = 1; i <= 2; i++) {
  closures.push(function () { console.log(i); });
}

closures[0]();
closures[1]();
```

> Does this print “1” then “2”, or does it print “3” twice? You may be surprised to hear that it prints “3” twice. In this JavaScript program, there is only a single `i` variable whose lifetime includes all iterations of the loop, including the final exit.

這裏會打印“1”再打印“2”，還是打印兩次“3”？你可能會驚訝地發現，它打印了兩次“3”[^24]。在這個JavaScript程序中，只有一個`i`變量，它的生命週期包括循環的所有迭代，包括最後的退出。

> If you’re familiar with JavaScript, you probably know that variables declared using `var` are implicitly *hoisted* to the surrounding function or top-level scope. It’s as if you really wrote this:

如果你熟悉JavaScript，你可能知道，使用`var`聲明的變量會隱式地被提取到外圍函數或頂層作用域中。這就好像你是這樣寫的：

```javascript
var closures = [];
var i;
for (i = 1; i <= 2; i++) {
  closures.push(function () { console.log(i); });
}

closures[0]();
closures[1]();
```

> At that point, it’s clearer that there is only a single `i`. Now consider if you change the program to use the newer `let` keyword:

此時，很明顯只有一個`i`。現在考慮一下，如果你將程序改為使用更新的`let`關鍵字：

```javascript
var closures = [];
for (let i = 1; i <= 2; i++) {
  closures.push(function () { console.log(i); });
}

closures[0]();
closures[1]();
```

> Does this new program behave the same? Nope. In this case, it prints “1” then “2”. Each closure gets its own `i`. That’s sort of strange when you think about it. The increment clause is `i++`. That looks very much like it is assigning to and mutating an existing variable, not creating a new one.

這個新程序的行為是一樣的嗎？不是。在本例中，它會打印“1”然後打印“2”。每個閉包都有自己的`i`。仔細想想會覺得有點奇怪，增量子句是`i++`，這看起來很像是對現有變量進行賦值和修改，而不是創建一個新變量。

> Let’s try some other languages. Here’s Python:

讓我們試試其它語言。下面是Python：

```python
closures = []
for i in range(1, 3):
  closures.append(lambda: print(i))

closures[0]()
closures[1]()
```

> Python doesn’t really have block scope. Variables are implicitly declared and are automatically scoped to the surrounding function. Kind of like hoisting in JS, now that I think about it. So both closures capture the same variable. Unlike C, though, we don’t exit the loop by incrementing `i` *past* the last value, so this prints “2” twice.

Python並沒有真正的塊作用域。變量是隱式聲明的，並自動限定在外圍函數的作用域中。現在我想起來，這有點像JS中的“懸掛”。所以兩個閉包都捕獲了同一個變量。但與C不同的是，我們不會通過增加`i`超過最後一個值來退出循環，所以這裏會打印兩次“2”。

> What about Ruby? Ruby has two typical ways to iterate numerically. Here’s the classic imperative style:

那Ruby呢？Ruby有兩種典型的數值迭代方式。下面是典型的命令式風格：

```ruby
closures = []
for i in 1..2 do
  closures << lambda { puts i }
end

closures[0].call
closures[1].call
```

> This, like Python, prints “2” twice. But the more idiomatic Ruby style is using a higher-order `each()` method on range objects:

這有點像是Python，會打印兩次“2”。但是更慣用的Ruby風格是在範圍對象上使用高階的`each()`方法：

```ruby
closures = []
(1..2).each do |i|
  closures << lambda { puts i }
end

closures[0].call
closures[1].call
```

> If you’re not familiar with Ruby, the `do |i| ... end` part is basically a closure that gets created and passed to the `each()` method. The `|i|` is the parameter signature for the closure. The `each()` method invokes that closure twice, passing in 1 for `i` the first time and 2 the second time.

如果你不熟悉Ruby，`do |i| ... end`部分基本上就是一個閉包，它被創建並傳遞給`each()`方法。`|i|`是閉包的參數簽名。`each()`方法兩次調用該閉包，第一次傳入1，第二次傳入2。

> In this case, the “loop variable” is really a function parameter. And, since each iteration of the loop is a separate invocation of the function, those are definitely separate variables for each call. So this prints “1” then “2”.

在這種情況下，“循環變量”實際上是一個函數參數。而且，由於循環的每次迭代都是對函數的單獨調用，所以每次調用都是單獨的變量。因此，這裏先打印“1”然後打印“2”。

> If a language has a higher-level iterator-based looping structure like `foreach` in C#, Java’s “enhanced for”, `for-of` in JavaScript, `for-in` in Dart, etc., then I think it’s natural to the reader to have each iteration create a new variable. The code *looks* like a new variable because the loop header looks like a variable declaration. And there’s no increment expression that looks like it’s mutating that variable to advance to the next step.

如果一門語言具有基於迭代器的高級循環結果，比如C#中的`foreach`，Java中的“增強型for循環”，JavaScript中的`for-of`，Dart中的`for-in`等等，那我認為讀者很自然地會讓每次迭代都創建一個新變量。代碼*看起來*像一個新變量，是因為循環頭看起來像是一個變量聲明。看起來沒有任何增量表達式通過改變變量以推進到下一步。

> If you dig around StackOverflow and other places, you find evidence that this is what users expect, because they are very surprised when they *don’t* get it. In particular, C# originally did *not* create a new loop variable for each iteration of a `foreach` loop. This was such a frequent source of user confusion that they took the very rare step of shipping a breaking change to the language. In C# 5, each iteration creates a fresh variable.

如果你在StackOverflow和其它地方挖掘一下，你會發現這正是用户所期望的，因為當他們*沒有*看到這個結果時，他們會非常驚訝。特別是，C#最初並沒有為`foreach`循環的每次迭代創建一個新的循環變量。這一點經常引起用户的困惑，所以他們採用了非常罕見的措施，對語言進行了突破性的修改。在C# 5中，每個迭代都會創建一個新的變量。

> Old C-style `for` loops are harder. The increment clause really does look like mutation. That implies there is a single variable that’s getting updated each step. But it’s almost never *useful* for each iteration to share a loop variable. The only time you can even detect this is when closures capture it. And it’s rarely helpful to have a closure that references a variable whose value is whatever value caused you to exit the loop.

舊的C風格的`for`循環更難了。增量子句看起來像是修改。這意味着每一步更新的是同一個變量。但是每個迭代共享一個循環變量幾乎是*沒有用*的。只有在閉包捕獲它時，你才能檢測到這一現象。而且，如果閉包引用的變量的值是導致循環退出的值，那麼它也幾乎沒有幫助。

> The pragmatically useful answer is probably to do what JavaScript does with `let` in `for` loops. Make it look like mutation but actually create a new variable each time, because that’s what users want. It is kind of weird when you think about it, though.

實用的答案可能是像JavaScript在`for`循環中的`let`那樣。讓它看起來像修改，但實際上每次都創建一個新變量，因為這是用户想要的。不過，仔細想想，還是有點奇怪的。



[^24]: 你想知道“3”是怎麼出現的嗎？在第二次迭代後，執行`i++`，它將`i`增加到3。這就是導致`i<=2`的值為false並結束循環的原因。如果`i`永遠達不到3，循環就會一直運行下去。
