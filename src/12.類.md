# 12. Classes 類

> One has no right to love or hate anything if one has not acquired a thorough knowledge of its nature. Great love springs from great knowledge of the beloved object, and if you know it but little you will be able to love it only a little or not at all.
>
> ​																																					——Leonardo da Vinci

如果一個人沒有完全瞭解任何事物的本質，他就沒有權利去愛或恨它。偉大的愛來自於對所愛之物的深刻了解，如果你對它知之甚少，你就只能愛一點點，或者根本不愛它。（列奧納多·達·芬奇）

> We’re eleven chapters in, and the interpreter sitting on your machine is nearly a complete scripting language. It could use a couple of built-in data structures like lists and maps, and it certainly needs a core library for file I/O, user input, etc. But the language itself is sufficient. We’ve got a little procedural language in the same vein as BASIC, Tcl, Scheme (minus macros), and early versions of Python and Lua.

我們已經完成了11章，你機器上的解釋器幾乎是一個完整的腳本語言實現了。它可以使用一些內置的數據結構，如列表和map，當然還需要一個用於文件IO、用户輸入等的核心庫。但作為語言本身已經足夠了。我們有一個與BASIC、Tcl、Scheme（不包括宏）以及早期版本的Python和Lua相同的小程序語言。

> If this were the ’80s, we’d stop here. But today, many popular languages support “object-oriented programming”. Adding that to Lox will give users a familiar set of tools for writing larger programs. Even if you personally don’t like OOP, this chapter and [the next](http://craftinginterpreters.com/inheritance.html) will help you understand how others design and build object systems.

如果現在是80年代，我們就可以到此為止。但是現在，很多流行的語言都支持“面向對象編程”。在Lox中添加該功能，可以為用户提供一套熟悉的工具來編寫大型程序。即使你個人不喜歡OOP，這一章和下一章將幫助你理解別人是如何設計和構建對象系統的[^1]。

## 12.1 OOP and Classes

> There are three broad paths to object-oriented programming: classes, [prototypes](http://gameprogrammingpatterns.com/prototype.html), and [multimethods](https://en.wikipedia.org/wiki/Multiple_dispatch). Classes came first and are the most popular style. With the rise of JavaScript (and to a lesser extent [Lua](https://www.lua.org/pil/13.4.1.html)), prototypes are more widely known than they used to be. I’ll talk more about those [later](http://craftinginterpreters.com/classes.html#design-note). For Lox, we’re taking the, ahem, classic approach.

面向對象編程有三大途徑：類、[原型](http://gameprogrammingpatterns.com/prototype.html)和[多方法](https://en.wikipedia.org/wiki/Multiple_dispatch)[^2]。類排在第一位，是最流行的風格。隨着JavaScript（其次是[Lua](https://www.lua.org/pil/13.4.1.html)）的興起，原型也比以前更加廣為人知。稍後我們會更多地討論這些問題。對於Lox，我們採取的是經典的方法。

> Since you’ve written about a thousand lines of Java code with me already, I’m assuming you don’t need a detailed introduction to object orientation. The main goal is to bundle data with the code that acts on it. Users do that by declaring a *class* that:

既然你已經跟我一起編寫了大約1000行Java代碼，我假設你不需要對面向對象進行詳細介紹。OOP的主要目標就是將數據與作用於數據的代碼捆綁在一起。用户通過聲明一個類來實現這一點：

1. > Exposes a *constructor* to create and initialize new *instances* of the class

   暴露*構造函數*以創建和初始化該類的新實例

2. > Provides a way to store and access *fields* on instances

   提供在實例上存儲和訪問*字段*的方法。

3. > Defines a set of *methods* shared by all instances of the class that operate on each instances’ state.

   定義一組由類的所有實例共享的*方法*，這些方法對各個實例的狀態進行操作。

![The relationships between classes, methods, instances, constructors, and fields.](12.類/circle.png)

> That’s about as minimal as it gets. Most object-oriented languages, all the way back to Simula, also do inheritance to reuse behavior across classes. We’ll add that in the [next chapter](http://craftinginterpreters.com/inheritance.html). Even kicking that out, we still have a lot to get through. This is a big chapter and everything doesn’t quite come together until we have all of the above pieces, so gather your stamina.

這大概是最低要求。大多數面向對象的語言（一直追溯到Simula），也都是通過繼承來跨類重用行為。我們會在下一章中添加該功能。即使剔除了這些，我們仍然有很多東西需要完成。這是一個很大的章節，直到我們完成上述所有內容之後，才能把所有東西整合到一起。所以請集中精力。

## 12 . 2 Class Declarations

> Like we do, we’re gonna start with syntax. A `class` statement introduces a new name, so it lives in the `declaration` grammar rule.

跟之前一樣，我們從語法開始。`class`語句引入了一個新名稱，所以它應該在`declaration` 語法規則中。

```
declaration    → classDecl
               | funDecl
               | varDecl
               | statement ;

classDecl      → "class" IDENTIFIER "{" function* "}" ;
```

> The new `classDecl` rule relies on the `function` rule we defined [earlier](http://craftinginterpreters.com/functions.html#function-declarations). To refresh your memory:

新的`classDecl`規則依賴於前面定義的`function`規則。複習一下：

```
function       → IDENTIFIER "(" parameters? ")" block ;
parameters     → IDENTIFIER ( "," IDENTIFIER )* ;
```

> In plain English, a class declaration is the `class` keyword, followed by the class’s name, then a curly-braced body. Inside that body is a list of method declarations. Unlike function declarations, methods don’t have a leading `fun` keyword. Each method is a name, parameter list, and body. Here’s an example:

用簡單的英語來説，類聲明就是`class`關鍵字，後跟類的名稱，然後是一對花括號包含的主體。在這個主體中，有一個方法聲明的列表。與函數聲明不同的是，方法沒有前導的`fun`關鍵字。每個方法就是一個名稱、參數列表和方法主體。下面是一個例子：

```java
class Breakfast {
  cook() {
    print "Eggs a-fryin'!";
  }

  serve(who) {
    print "Enjoy your breakfast, " + who + ".";
  }
}
```

> Like most dynamically typed languages, fields are not explicitly listed in the class declaration. Instances are loose bags of data and you can freely add fields to them as you see fit using normal imperative code.
>

像大多數動態類型的語言一樣，字段沒有在類的聲明中明確列出。實例是鬆散的數據包，你可以使用正常的命令式代碼自由地向其中添加字段。

> Over in our AST generator, the `classDecl` grammar rule gets its own statement node.
>

在AST生成器中，`classDecl`語法規則有自己的語句節點。

*<u>tool/GenerateAst.java，在 main()方法中添加：</u>*

```java
      "Block      : List<Stmt> statements",
      // 新增部分開始
      "Class      : Token name, List<Stmt.Function> methods",
      // 新增部分結束
      "Expression : Expr expression",
```

> It stores the class’s name and the methods inside its body. Methods are represented by the existing Stmt.Function class that we use for function declaration AST nodes. That gives us all the bits of state that we need for a method: name, parameter list, and body.

它存儲了類的名稱和其主體內的方法。方法使用現有的表示函數聲明的Stmt.Function類來表示。這就為我們提供了一個方法所需的所有狀態：名稱、參數列表和方法體。

> A class can appear anywhere a named declaration is allowed, triggered by the leading `class` keyword.

類可以出現在任何允許名稱聲明的地方，由前導的`class`關鍵字來觸發。

*<u>lox/Parser.java，在 declaration()方法中添加：</u>*

```java
    try {  
      // 新增部分開始
      if (match(CLASS)) return classDeclaration();
      // 新增部分結束
      if (match(FUN)) return function("function");
```

> That calls out to:

進一步調用：

*<u>lox/Parser.java，在 declaration()方法後添加：</u>*

```java
  private Stmt classDeclaration() {
    Token name = consume(IDENTIFIER, "Expect class name.");
    consume(LEFT_BRACE, "Expect '{' before class body.");

    List<Stmt.Function> methods = new ArrayList<>();
    while (!check(RIGHT_BRACE) && !isAtEnd()) {
      methods.add(function("method"));
    }

    consume(RIGHT_BRACE, "Expect '}' after class body.");

    return new Stmt.Class(name, methods);
  }
```

> There’s more meat to this than most of the other parsing methods, but it roughly follows the grammar. We’ve already consumed the `class` keyword, so we look for the expected class name next, followed by the opening curly brace. Once inside the body, we keep parsing method declarations until we hit the closing brace. Each method declaration is parsed by a call to `function()`, which we defined back in the [chapter where functions were introduced](http://craftinginterpreters.com/functions.html).

這比其它大多數解析方法有更多的內容，但它大致上遵循了語法。我們已經使用了`class`關鍵字，所以我們接下來會查找預期的類名，然後是左花括號。一旦進入主體，我們就繼續解析方法聲明，直到碰到右花括號。每個方法聲明是通過調用`function()`方法來解析的，我們在介紹函數的那一章中定義了該函數。

> Like we do in any open-ended loop in the parser, we also check for hitting the end of the file. That won’t happen in correct code since a class should have a closing brace at the end, but it ensures the parser doesn’t get stuck in an infinite loop if the user has a syntax error and forgets to correctly end the class body.
>

就像我們在解析器中的所有開放式循環中的操作一樣，我們也要檢查是否到達文件結尾。這在正確的代碼是不會發生的，因為類的結尾應該有一個右花括號，但它可以確保在用户出現語法錯誤而忘記正確結束類的主體時，解析器不會陷入無限循環。

> We wrap the name and list of methods into a Stmt.Class node and we’re done. Previously, we would jump straight into the interpreter, but now we need to plumb the node through the resolver first.

我們將名稱和方法列表封裝到Stmt.Class節點中，這樣就完成了。以前，我們會直接進入解釋器中，但是現在我們需要先進入分析器中對節點進行分析。【譯者注：為了區分parse和resolve，這裏將resolver稱為分析器，用於對代碼中的變量進行分析】

*<u>lox/Resolver.java，在 visitBlockStmt()方法後添加：</u>*

```java
  @Override
  public Void visitClassStmt(Stmt.Class stmt) {
    declare(stmt.name);
    define(stmt.name);
    return null;
  }
```

> We aren’t going to worry about resolving the methods themselves yet, so for now all we need to do is declare the class using its name. It’s not common to declare a class as a local variable, but Lox permits it, so we need to handle it correctly.
>

我們還不用擔心針對方法本身的分析，我們目前需要做的是使用類的名稱來聲明這個類。將類聲明為一個局部變量並不常見，但是Lox中允許這樣做，所以我們需要正確處理。

> Now we interpret the class declaration.

現在我們解釋一下類的聲明。

*<u>lox/Interpreter.java，在 visitBlockStmt()方法後添加：</u>*

```java
  @Override
  public Void visitClassStmt(Stmt.Class stmt) {
    environment.define(stmt.name.lexeme, null);
    LoxClass klass = new LoxClass(stmt.name.lexeme);
    environment.assign(stmt.name, klass);
    return null;
  }
```

> This looks similar to how we execute function declarations. We declare the class’s name in the current environment. Then we turn the class *syntax node* into a LoxClass, the *runtime* representation of a class. We circle back and store the class object in the variable we previously declared. That two-stage variable binding process allows references to the class inside its own methods.

這看起來類似於我們執行函數聲明的方式。我們在當前環境中聲明該類的名稱。然後我們把類的*語法節點*轉換為LoxClass，即類的*運行時*表示。我們回過頭來，將類對象存儲在我們之前聲明的變量中。這個二階段的變量綁定過程允許在類的方法中引用其自身。

> We will refine it throughout the chapter, but the first draft of LoxClass looks like this:

我們會在整個章節中對其進行完善，但是LoxClass的初稿看起來如下：

*<u>lox/LoxClass.java，創建新文件：</u>*

```java
package com.craftinginterpreters.lox;

import java.util.List;
import java.util.Map;

class LoxClass {
  final String name;

  LoxClass(String name) {
    this.name = name;
  }

  @Override
  public String toString() {
    return name;
  }
}
```

> Literally a wrapper around a name. We don’t even store the methods yet. Not super useful, but it does have a `toString()` method so we can write a trivial script and test that class objects are actually being parsed and executed.

字面上看，就是一個對name的包裝。我們甚至還沒有保存類中的方法。不算很有用，但是它確實有一個`toString()`方法，所以我們可以編寫一個簡單的腳本，測試類對象是否真的被解析和執行。

```java
class DevonshireCream {
  serveOn() {
    return "Scones";
  }
}

print DevonshireCream; // Prints "DevonshireCream".
```

> ## 12 . 3 Creating Instances

## 12.3 創建實例

> We have classes, but they don’t do anything yet. Lox doesn’t have “static” methods that you can call right on the class itself, so without actual instances, classes are useless. Thus instances are the next step.

我們有了類，但是它們還不能做任何事。Lox沒有可以直接在類本身調用的“靜態”方法，所以如果沒有實例，類是沒有用的。因此，下一步就是實例化。

> While some syntax and semantics are fairly standard across OOP languages, the way you create new instances isn’t. Ruby, following Smalltalk, creates instances by calling a method on the class object itself, a recursively graceful approach. Some, like C++ and Java, have a `new` keyword dedicated to birthing a new object. Python has you “call” the class itself like a function. (JavaScript, ever weird, sort of does both.)

雖然一些語法和語義在OOP語言中是相當標準的，但創建新實例的方式並不是。Ruby，繼Smalltalk之後，通過調用類對象本身的一個方法來創建實例，這是一種遞歸的優雅方法[^3]。有些語言，像C++和Java，有一個`new`關鍵字專門用來創建一個新的對象。Python讓你像調用函數一樣“調用”類本身。(JavaScript，永遠都是那麼奇怪，兩者兼而有之)

> I took a minimal approach with Lox. We already have class objects, and we already have function calls, so we’ll use call expressions on class objects to create new instances. It’s as if a class is a factory function that generates instances of itself. This feels elegant to me, and also spares us the need to introduce syntax like `new`. Therefore, we can skip past the front end straight into the runtime.

我在Lox中採用了一種最簡單的方法。我們已經有了類對象，也有了函數調用，所以我們直接使用類對象的調用表達式來創建新的實例。這就好像類是一個生產自身實例的工廠函數。這讓我感覺很優雅，也不需要引入`new`這樣的語法。因此，我們可以跳過前端直接進入運行時。

> Right now, if you try this:

現在，如果你試着運行下面的代碼：

```java
class Bagel {}
Bagel();
```

> You get a runtime error. `visitCallExpr()` checks to see if the called object implements `LoxCallable` and reports an error since LoxClass doesn’t. Not *yet*, that is.

你會得到一個運行時錯誤。`visitCallExpr()`方法會檢查被調用的對象是否實現了`LoxCallable` 接口，因為LoxClass沒有實現所以會報錯。只是目前還沒有。

*<u>lox/LoxClass.java，替換一行：</u>*

```java
import java.util.Map;
// 替換部分開始
class LoxClass implements LoxCallable {
// 替換部分結束
  final String name;
```

> Implementing that interface requires two methods.

實現該接口需要兩個方法。

*<u>lox/LoxClass.java，在 toString()方法後添加:</u>*

```java
  @Override
  public Object call(Interpreter interpreter,
                     List<Object> arguments) {
    LoxInstance instance = new LoxInstance(this);
    return instance;
  }

  @Override
  public int arity() {
    return 0;
  }
```

> The interesting one is `call()`. When you “call” a class, it instantiates a new LoxInstance for the called class and returns it. The `arity()` method is how the interpreter validates that you passed the right number of arguments to a callable. For now, we’ll say you can’t pass any. When we get to user-defined constructors, we’ll revisit this.

有趣的是`call()`。當你“調用”一個類時，它會為被調用的類實例化一個新的LoxInstance並返回。`arity()` 方法是解釋器用於驗證你是否向callable中傳入了正確數量的參數。現在，我們會説你不用傳任何參數。當我們討論用户自定義的構造函數時，我們再重新考慮這個問題。

> That leads us to LoxInstance, the runtime representation of an instance of a Lox class. Again, our first implementation starts small.

這就引出了LoxInstance，它是Lox類實例的運行時表示。同樣，我們的第一個實現從小處着手。

*<u>lox/LoxInstance.java，創建新文件：</u>*

```java
package com.craftinginterpreters.lox;

import java.util.HashMap;
import java.util.Map;

class LoxInstance {
  private LoxClass klass;

  LoxInstance(LoxClass klass) {
    this.klass = klass;
  }

  @Override
  public String toString() {
    return klass.name + " instance";
  }
}
```

> Like LoxClass, it’s pretty bare bones, but we’re only getting started. If you want to give it a try, here’s a script to run:

和LoxClass一樣，它也是相當簡陋的，但我們才剛剛開始。如果你想測試一下，可以運行下面的腳本：

```javascript
class Bagel {}
var bagel = Bagel();
print bagel; // Prints "Bagel instance".
```

> This program doesn’t do much, but it’s starting to do *something*.

這段程序沒有做太多事，但是已經開始做*一些事情*了。

> ## 12 . 4 Properties on Instances

## 12.4 實例屬性

> We have instances, so we should make them useful. We’re at a fork in the road. We could add behavior first—methods—or we could start with state—properties. We’re going to take the latter because, as we’ll see, the two get entangled in an interesting way and it will be easier to make sense of them if we get properties working first.

我們有了實例，所以我們應該讓它們發揮作用。我們正處於一個岔路口。我們可以首先添加行為（方法），或者我們可以先從狀態（屬性）開始。我們將選擇後者，因為我們後面將會看到，這兩者以一種有趣的方式糾纏在一起，如果我們先支持屬性，就會更容易理解它們。

> Lox follows JavaScript and Python in how it handles state. Every instance is an open collection of named values. Methods on the instance’s class can access and modify properties, but so can outside code. Properties are accessed using a `.` syntax.
>

Lox遵循了JavaScript和Python處理狀態的方式。每個實例都是一個開放的命名值集合。實例類中的方法可以訪問和修改屬性，但外部代碼也可以[^4]。屬性通過`.`語法進行訪問。

```java
someObject.someProperty
```

> An expression followed by `.` and an identifier reads the property with that name from the object the expression evaluates to. That dot has the same precedence as the parentheses in a function call expression, so we slot it into the grammar by replacing the existing `call` rule with:

一個後面跟着`.`和一個標識符的表達式，會從表達式計算出的對象中讀取該名稱對應的屬性。這個點符號與函數調用表達式中的括號具有相同的優先級，所以我們要將該符號加入語法時，可以替換已有的`call`規則如下：

```
call           → primary ( "(" arguments? ")" | "." IDENTIFIER )* ;
```

> After a primary expression, we allow a series of any mixture of parenthesized calls and dotted property accesses. “Property access” is a mouthful, so from here on out, we’ll call these “get expressions”.

在基本表達式之後，我們允許跟一系列括號調用和點屬性訪問的任何混合。屬性訪問有點拗口，所以自此以後，我們稱其為“get表達式”。

> ### 12 . 4 . 1 Get expressions

### 12.4.1 Get表達式

> The syntax tree node is:

語法樹節點是：

*<u>tool/GenerateAst.java，在 main()方法中添加：</u>*

```java
      "Call     : Expr callee, Token paren, List<Expr> arguments",
      // 新增部分開始
      "Get      : Expr object, Token name",
      // 新增部分結束
      "Grouping : Expr expression",
```

> Following the grammar, the new parsing code goes in our existing `call()` method.

按照語法，在現有的`call()`方法中加入新的解析代碼。

*<u>lox/Parser.java，在 call()方法中添加代碼：</u>*

```java
    while (true) { 
      if (match(LEFT_PAREN)) {
        expr = finishCall(expr);
      // 新增部分開始
      } else if (match(DOT)) {
        Token name = consume(IDENTIFIER,
            "Expect property name after '.'.");
        expr = new Expr.Get(expr, name);
      // 新增部分結束  
      } else {
        break;
      }
    }
```

> The outer `while` loop there corresponds to the `*` in the grammar rule. We zip along the tokens building up a chain of calls and gets as we find parentheses and dots, like so:

外面的`while`循環對應於語法規則中的`*`。隨着查找括號和點，我們會沿着標記構建一系列的call和get，就像：

![Parsing a series of '.' and '()' expressions to an AST.](12.類/zip.png)

> Instances of the new Expr.Get node feed into the resolver.

新的Expr.Get節點實例會被送入分析器。

*<u>lox/Resolver.java，在visitCallExpr()方法後添加：</u>*

```java
  @Override
  public Void visitGetExpr(Expr.Get expr) {
    resolve(expr.object);
    return null;
  }
```

> OK, not much to that. Since properties are looked up dynamically, they don’t get resolved. During resolution, we recurse only into the expression to the left of the dot. The actual property access happens in the interpreter.

好吧，沒什麼好説的。因為屬性是動態查找的，所以不會解析它們。在解析過程中，我們只遞歸到點符左邊的表達式中。實際的屬性訪問發生在解釋器中。

*<u>lox/Interpreter.java，在 visitCallExpr()方法後添加：</u>*

```java
  @Override
  public Object visitGetExpr(Expr.Get expr) {
    Object object = evaluate(expr.object);
    if (object instanceof LoxInstance) {
      return ((LoxInstance) object).get(expr.name);
    }

    throw new RuntimeError(expr.name,
        "Only instances have properties.");
  }
```

> First, we evaluate the expression whose property is being accessed. In Lox, only instances of classes have properties. If the object is some other type like a number, invoking a getter on it is a runtime error.

首先，我們對屬性被訪問的表達式求值。在Lox中，只有類的實例才具有屬性。如果對象是其它類型（如數字），則對其執行getter是運行時錯誤。

> If the object is a LoxInstance, then we ask it to look up the property. It must be time to give LoxInstance some actual state. A map will do fine.

如果該對象是LoxInstance，我們就要求它去查找該屬性。現在必須給LoxInstance一些實際的狀態了。一個map就行了。

*<u>lox/LoxInstance.java，在 LoxInstance類中添加：</u>*

```
  private LoxClass klass;
  // 新增部分開始
  private final Map<String, Object> fields = new HashMap<>();
  // 新增部分結束
  LoxInstance(LoxClass klass) {
```

> Each key in the map is a property name and the corresponding value is the property’s value. To look up a property on an instance:

map中的每個鍵是一個屬性名稱，對應的值就是該屬性的值。查找實例中的一個屬性：

*<u>lox/LoxInstance.java，在 LoxInstance()方法後添加：</u>*

```java
  Object get(Token name) {
    if (fields.containsKey(name.lexeme)) {
      return fields.get(name.lexeme);
    }

    throw new RuntimeError(name, 
        "Undefined property '" + name.lexeme + "'.");
  }
```

> An interesting edge case we need to handle is what happens if the instance doesn’t *have* a property with the given name. We could silently return some dummy value like `nil`, but my experience with languages like JavaScript is that this behavior masks bugs more often than it does anything useful. Instead, we’ll make it a runtime error.

我們需要處理的一個有趣的邊緣情況是，如果這個實例中*不包含*給定名稱的屬性，會發生什麼。我們可以悄悄返回一些假值，如`nil`，但是根據我對JavaScript等語言的經驗，這種行為只是掩蓋了錯誤，而沒有做任何有用的事。相反，我們將它作為一個運行時錯誤。

> So the first thing we do is see if the instance actually has a field with the given name. Only then do we return it. Otherwise, we raise an error.

因此，我們首先要做的就是看看這個實例中是否真的包含給定名稱的字段。只有這樣，我們才會返回其值。其它情況下，我們會引發一個錯誤。

> Note how I switched from talking about “properties” to “fields”. There is a subtle difference between the two. Fields are named bits of state stored directly in an instance. Properties are the named, uh, *things*, that a get expression may return. Every field is a property, but as we’ll see later, not every property is a field.

注意我是如何從討論“屬性”轉換到討論“字段”的。這兩者之間有一個微妙的區別。字段是直接保存在實例中的命名狀態。屬性是get表達式可能返回的已命名的*東西*。每個字段都是一個屬性，但是正如我們稍後將看到的，並非每個屬性都是一個字段。

> In theory, we can now read properties on objects. But since there’s no way to actually stuff any state into an instance, there are no fields to access. Before we can test out reading, we must support writing.

理論上，我們現在可以讀取對象的屬性。但是由於沒有辦法將任何狀態真正填充到實例中，所以也沒有字段可以訪問。在我們測試讀取之前，我們需要先支持寫入。

> ### 12 . 4 . 2 Set expressions

### 12.4.2 Set表達式

> Setters use the same syntax as getters, except they appear on the left side of an assignment.

setter和getter使用相同的語法，區別只是它們出現在賦值表達式的左側。

```java
someObject.someProperty = value;
```

> In grammar land, we extend the rule for assignment to allow dotted identifiers on the left-hand side.

在語言方面，我們擴展了賦值規則，允許在左側使用點標識符。

```
assignment     → ( call "." )? IDENTIFIER "=" assignment
               | logic_or ;
```

> Unlike getters, setters don’t chain. However, the reference to `call` allows any high-precedence expression before the last dot, including any number of *getters*, as in:

與getter不同，setter不使用鏈。但是，對`call` 規則的引用允許在最後的點符號之前出現任何高優先級的表達式，包括任何數量的*getters*，如：

![breakfast.omelette.filling.meat = ham](12.類/setter.png)

> Note here that only the *last* part, the `.meat` is the *setter*. The `.omelette` and `.filling` parts are both *get* expressions.

注意，這裏只有最後一部分`.meat`是*setter*。`.omelette`和`.filling`部分都是*get*表達式。

> Just as we have two separate AST nodes for variable access and variable assignment, we need a second setter node to complement our getter node.

就像我們有兩個獨立的AST節點用於變量訪問和變量賦值一樣，我們也需要一個setter節點來補充getter節點。

*<u>tool/GenerateAst.java，在 main()方法中添加：</u>*

```java
      "Logical  : Expr left, Token operator, Expr right",
      // 新增部分開始
      "Set      : Expr object, Token name, Expr value",
      // 新增部分結束
      "Unary    : Token operator, Expr right",
```

> In case you don’t remember, the way we handle assignment in the parser is a little funny. We can’t easily tell that a series of tokens is the left-hand side of an assignment until we reach the `=`. Now that our assignment grammar rule has `call` on the left side, which can expand to arbitrarily large expressions, that final `=` may be many tokens away from the point where we need to know we’re parsing an assignment.

也許你不記得了，我們在解析器中處理賦值的方法有點奇怪。在遇到`=`之前，我們無法輕易判斷一系列標記是否是一個賦值表達式的左側部分。現在我們的賦值語法規則在左側添加了`call`，它可以擴展為任意大的表達式，最後的`=`可能與我們需要知道是否正在解析賦值表達式的地方隔着很多標記。

> Instead, the trick we do is parse the left-hand side as a normal expression. Then, when we stumble onto the equal sign after it, we take the expression we already parsed and transform it into the correct syntax tree node for the assignment.

相對地，我們的技巧就是把左邊的表達式作為一個正常表達式來解析。然後，當我們在後面發現等號時，我們就把已經解析的表達式轉換為正確的賦值語法樹節點。

> We add another clause to that transformation to handle turning an Expr.Get expression on the left into the corresponding Expr.Set.

我們在該轉換中添加另一個子句，將左邊的Expr.Get表達式轉化為相應的Expr.Set表達式。

*<u>lox/Parser.java，在 assignment()方法中添加：</u>*

```java
        return new Expr.Assign(name, value);
      // 新增部分開始  
      } else if (expr instanceof Expr.Get) {
        Expr.Get get = (Expr.Get)expr;
        return new Expr.Set(get.object, get.name, value);
      // 新增部分結束
      }
```

> That’s parsing our syntax. We push that node through into the resolver.

這就是語法解析。我們將該節點推入分析器中。

*<u>lox/Resolver.java，在 visitLogicalExpr()方法後添加：</u>*

```java
  @Override
  public Void visitSetExpr(Expr.Set expr) {
    resolve(expr.value);
    resolve(expr.object);
    return null;
  }
```

> Again, like Expr.Get, the property itself is dynamically evaluated, so there’s nothing to resolve there. All we need to do is recurse into the two subexpressions of Expr.Set, the object whose property is being set, and the value it’s being set to.

同樣，像Expr.Get一樣，屬性本身是動態計算的，所以沒有什麼需要分析的。我們只需要遞歸到Expr.Set的兩個子表達式中，即被設置屬性的對象和它被設置的值。

> That leads us to the interpreter.

這又會把我們引向解釋器。

*<u>lox/Interpreter.java，在 visitLogicalExpr()方法後添加：</u>*

```java
  @Override
  public Object visitSetExpr(Expr.Set expr) {
    Object object = evaluate(expr.object);

    if (!(object instanceof LoxInstance)) { 
      throw new RuntimeError(expr.name,
                             "Only instances have fields.");
    }

    Object value = evaluate(expr.value);
    ((LoxInstance)object).set(expr.name, value);
    return value;
  }
```

> We evaluate the object whose property is being set and check to see if it’s a LoxInstance. If not, that’s a runtime error. Otherwise, we evaluate the value being set and store it on the instance. That relies on a new method in LoxInstance.

我們先計算出被設置屬性的對象，然後檢查它是否是一個LoxInstance。如果不是，這就是一個運行時錯誤。否則，我們計算設置的值，並將其保存到該實例中。這一步依賴於LoxInstance中的一個新方法。

*<u>lox/LoxInstance.java，在 get()方法後添加：</u>*

```java
  void set(Token name, Object value) {
    fields.put(name.lexeme, value);
  }
```

> No real magic here. We stuff the values straight into the Java map where fields live. Since Lox allows freely creating new fields on instances, there’s no need to see if the key is already present.

這裏沒什麼複雜的。我們把這些值之間塞入字段所在的Java map中。由於Lox允許在實例上自由創建新字段，所以不需要檢查鍵是否已經存在。

> ## 12 . 5 Methods on Classes

## 12.5 類中的方法

> You can create instances of classes and stuff data into them, but the class itself doesn’t really *do* anything. Instances are just maps and all instances are more or less the same. To make them feel like instances *of classes*, we need behavior—methods.

你可以創建類的實例並將數據填入其中，但是類本身實際上並不能做任何事。實例只是一個map，而且所有的實例都是大同小異的。為了讓它們更像是*類*的實例，我們需要行為——方法。

> Our helpful parser already parses method declarations, so we’re good there. We also don’t need to add any new parser support for method *calls*. We already have `.` (getters) and `()` (function calls). A “method call” simply chains those together.

我們的解析器已經解析了方法聲明，所以我們在這部分做的不錯。我們也不需要為方法*調用*添加任何新的解析器支持。我們已經有了`.`(getter)和`()`(函數調用)。“方法調用”只是簡單地將這些串在一起。

![The syntax tree for 'object.method(argument)](12.類/method.png)

> That raises an interesting question. What happens when those two expressions are pulled apart? Assuming that `method` in this example is a method on the class of `object` and not a field on the instance, what should the following piece of code do?

這引出了一個有趣的問題。當這兩個表達式分開時會發生什麼？假設這個例子中的方法`method`是`object`的類中的一個方法，而不是實例中的 一個字段，下面的代碼應該做什麼？

```java
var m = object.method;
m(argument);
```

> This program “looks up” the method and stores the result—whatever that is—in a variable and then calls that object later. Is this allowed? Can you treat a method like it’s a function on the instance?

這個程序會“查找”該方法，並將結果（不管是什麼）存儲到一個變量中，稍後會調用該對象。允許這樣嗎？你能將方法作為實例中的一個函數來對待嗎？

> What about the other direction?

另一個方向呢？

```javascript
class Box {}

fun notMethod(argument) {
  print "called function with " + argument;
}

var box = Box();
box.function = notMethod;
box.function("argument");
```

> This program creates an instance and then stores a function in a field on it. Then it calls that function using the same syntax as a method call. Does that work?

這個程序創建了一個實例，然後在它的一個字段中存儲了一個函數。然後使用與方法調用相同的語法來調用該函數。這樣做有用嗎？

> Different languages have different answers to these questions. One could write a treatise on it. For Lox, we’ll say the answer to both of these is yes, it does work. We have a couple of reasons to justify that. For the second example—calling a function stored in a field—we want to support that because first-class functions are useful and storing them in fields is a perfectly normal thing to do.

不同的語言對這些問題有不同的答案。人們可以就此寫一篇論文。對於Lox來説，這兩個問題的答案都是肯定的，它確實有效。我們有幾個理由來證明這一點。對於第二個例子——調用存儲在字段中的函數——我們想要支持它，是因為頭等函數是有用的，而且將它們存儲在字段中是一件很正常的事情。

> The first example is more obscure. One motivation is that users generally expect to be able to hoist a subexpression out into a local variable without changing the meaning of the program. You can take this:

第一個例子就比較晦澀了。一個場景是，用户通常希望能夠在不改變程序含義的情況下，將子表達式賦值到一個局部變量中。你可以這樣做：

```javascript
breakfast(omelette.filledWith(cheese), sausage);
```

> And turn it into this:

並將其變成這樣：

```javascript
var eggs = omelette.filledWith(cheese);
breakfast(eggs, sausage);
```

> And it does the same thing. Likewise, since the `.` and the `()` in a method call *are* two separate expressions, it seems you should be able to hoist the *lookup* part into a variable and then call it later. We need to think carefully about what the *thing* you get when you look up a method is, and how it behaves, even in weird cases like:

它做的是同樣的事情。同樣，由於方法調用中的`.`和`()`是兩個獨立的表達式，你似乎應該把查詢部分提取到一個變量中，然後再調用它[^5]。我們需要仔細思考，當你查找一個方法時你得到的東西是什麼，它如何作用，甚至是在一些奇怪的情況下，比如：

```javascript
class Person {
  sayName() {
    print this.name;
  }
}

var jane = Person();
jane.name = "Jane";

var method = jane.sayName;
method(); // ?
```

> If you grab a handle to a method on some instance and call it later, does it “remember” the instance it was pulled off from? Does `this` inside the method still refer to that original object?

如果你在某個實例上獲取了一個方法的句柄，並在稍後再調用它，它是否能“記住”它是從哪個實例中提取出來的？方法內部的`this`是否仍然指向原始的那個對象？

> Here’s a more pathological example to bend your brain:

下面有一個更變態的例子，可以摧毀你的大腦：

```javascript
class Person {
  sayName() {
    print this.name;
  }
}

var jane = Person();
jane.name = "Jane";

var bill = Person();
bill.name = "Bill";

bill.sayName = jane.sayName;
bill.sayName(); // ?
```

> Does that last line print “Bill” because that’s the instance that we *called* the method through, or “Jane” because it’s the instance where we first grabbed the method?

最後一行會因為*調用*方法的實體是bill而打印“Bill”，還是因為我們第一次獲取方法的實例是jane而打印“Jane”。

> Equivalent code in Lua and JavaScript would print “Bill”. Those languages don’t really have a notion of “methods”. Everything is sort of functions-in-fields, so it’s not clear that `jane` “owns” `sayName` any more than `bill` does.

在Lua和JavaScript中，同樣的代碼會打印 "Bill"。這些語言並沒有真正的“方法”的概念。所有東西都類似於字段中的函數，所以並不清楚`jane` 是否更應該比`bill`“擁有”`sayName`。

> Lox, though, has real class syntax so we do know which callable things are methods and which are functions. Thus, like Python, C#, and others, we will have methods “bind” `this` to the original instance when the method is first grabbed. Python calls these **bound methods**.

不過，Lox有真正的類語法，所以我們確實知道哪些可調用的東西是方法，哪些是函數。因此，像Python、C#和其他語言一樣，當方法第一次被獲取時，我們會讓方法與原始實例`this`進行 "綁定"。Python將這些綁定的方法稱為**bound methods**（綁定方法）。

> In practice, that’s usually what you want. If you take a reference to a method on some object so you can use it as a callback later, you want to remember the instance it belonged to, even if that callback happens to be stored in a field on some other object.

在實踐中，這通常也是你想要的。如果你獲取到了某個對象中一個方法的引用，這樣你以後就可以把它作為一個回調函數使用，你想要記住它所屬的實例，即使這個回調被存儲在其它對象的字段中。

> OK, that’s a lot of semantics to load into your head. Forget about the edge cases for a bit. We’ll get back to those. For now, let’s get basic method calls working. We’re already parsing the method declarations inside the class body, so the next step is to resolve them.

好吧，這裏有很多語義需要裝到你的腦子裏。暫時先不考慮那些邊緣情況了，我們以後再講。現在，讓我們先把基本的方法調用做好。我們已經解析了類主體內的方法聲明，所以下一步就是對其分析。

*<u>lox/Resolver.java，在 visitClassStmt()方法內添加[^6]：</u>*

```java
    define(stmt.name);
    // 新增部分開始
    for (Stmt.Function method : stmt.methods) {
      FunctionType declaration = FunctionType.METHOD;
      resolveFunction(method, declaration); 
    }
    // 新增部分結束
    return null;
```

> We iterate through the methods in the class body and call the `resolveFunction()` method we wrote for handling function declarations already. The only difference is that we pass in a new FunctionType enum value.

我們遍歷類主體中的方法，並調用我們已經寫好的用來處理函數聲明的`resolveFunction()`方法。唯一的區別在於，我們傳入了一個新的FunctionType枚舉值。

*<u>lox/Resolver.java，在 FunctionType枚舉中添加代碼，在上一行末尾添加`,`：</u>*

```java
    NONE,
    FUNCTION,
    // 新增部分開始
    METHOD
    // 新增部分結束
  }
```

> That’s going to be important when we resolve `this` expressions. For now, don’t worry about it. The interesting stuff is in the interpreter.

這一點在我們分析`this`表達式時很重要。現在還不用擔心這個問題。有趣的部分在解釋器中。

*<u>lox/Interpreter.java，在 visitClassStmt()方法中替換一行：</u>*

```java
    environment.define(stmt.name.lexeme, null);
    // 替換部分開始
    Map<String, LoxFunction> methods = new HashMap<>();
    for (Stmt.Function method : stmt.methods) {
      LoxFunction function = new LoxFunction(method, environment);
      methods.put(method.name.lexeme, function);
    }

    LoxClass klass = new LoxClass(stmt.name.lexeme, methods);
    // 替換部分結束
    environment.assign(stmt.name, klass);
```

> When we interpret a class declaration statement, we turn the syntactic representation of the class—its AST node—into its runtime representation. Now, we need to do that for the methods contained in the class as well. Each method declaration blossoms into a LoxFunction object.

當我們解釋一個類聲明語句時，我們把類的語法表示（其AST節點）變成它的運行時表示。現在，我們也需要對類中包含的方法進行這樣的操作。每個方法聲明都會變成一個LoxFunction對象。

> We take all of those and wrap them up into a map, keyed by the method names. That gets stored in LoxClass.

我們把所有這些都打包到一個map中，以方法名稱作為鍵。這些數據存儲在LoxClass中。

*<u>lox/LoxClass.java，在類 LoxClass中，替換4行：</u>*

```java
  final String name;
  // 替換部分開始
  private final Map<String, LoxFunction> methods;

  LoxClass(String name, Map<String, LoxFunction> methods) {
    this.name = name;
    this.methods = methods;
  }
  // 替換部分結束
  @Override
  public String toString() {
```

> Where an instance stores state, the class stores behavior. LoxInstance has its map of fields, and LoxClass gets a map of methods. Even though methods are owned by the class, they are still accessed through instances of that class.

實例存儲狀態，類存儲行為。LoxInstance包含字段的map，而LoxClass包含方法的map。雖然方法是歸類所有，但仍然是通過類的實例來訪問。

*<u>lox/LoxInstance.java，在 get()方法中添加：</u>*

```java
  Object get(Token name) {
    if (fields.containsKey(name.lexeme)) {
      return fields.get(name.lexeme);
    }
    // 新增部分開始
    LoxFunction method = klass.findMethod(name.lexeme);
    if (method != null) return method;
    // 新增部分結束
    throw new RuntimeError(name, 
        "Undefined property '" + name.lexeme + "'.");
```

> When looking up a property on an instance, if we don’t find a matching field, we look for a method with that name on the instance’s class. If found, we return that. This is where the distinction between “field” and “property” becomes meaningful. When accessing a property, you might get a field—a bit of state stored on the instance—or you could hit a method defined on the instance’s class.

在實例上查找屬性時，如果我們沒有找到匹配的字段，我們就在實例的類中查找是否包含該名稱的方法。如果找到，我們就返回該方法[^7]。這就是“字段”和“屬性”之間的區別變得有意義的地方。當訪問一個屬性時，你可能會得到一個字段（存儲在實例上的狀態值），或者你會得到一個實例類中定義的方法。

> The method is looked up using this:

方法是通過下面的代碼進行查找的：

*<u>lox/LoxClass.java，在 LoxClass()方法後添加：</u>*

```java
  LoxFunction findMethod(String name) {
    if (methods.containsKey(name)) {
      return methods.get(name);
    }

    return null;
  }
```

> You can probably guess this method is going to get more interesting later. For now, a simple map lookup on the class’s method table is enough to get us started. Give it a try:

你大概能猜到這個方法後面會變得更有趣。但是現在，在類的方法表中進行簡單的映射查詢就足夠了。試一下：

```javascript
class Bacon {
  eat() {
    print "Crunch crunch crunch!";
  }
}

Bacon().eat(); // Prints "Crunch crunch crunch!".
```

## 12 . 6 This

> We can define both behavior and state on objects, but they aren’t tied together yet. Inside a method, we have no way to access the fields of the “current” object—the instance that the method was called on—nor can we call other methods on that same object.

我們可以在對象上定義行為和狀態，但是它們並沒有被綁定在一起。在一個方法中，我們沒有辦法訪問“當前”對象（調用該方法的實例）的字段，也不能調用同一個對象的其它方法。

> To get at that instance, it needs a name. Smalltalk, Ruby, and Swift use “self”. Simula, C++, Java, and others use “this”. Python uses “self” by convention, but you can technically call it whatever you like.

為了獲得這個實例，它需要一個名稱。Smalltalk、Ruby和Swift使用 "self"。Simula、C++、Java等使用 "this"。Python按慣例使用 "self"，但從技術上講，你可以隨便叫它什麼。

> For Lox, since we generally hew to Java-ish style, we’ll go with “this”. Inside a method body, a `this` expression evaluates to the instance that the method was called on. Or, more specifically, since methods are accessed and then invoked as two steps, it will refer to the object that the method was *accessed* from.

對於Lox來説，因為我們通常遵循Java風格，我們會使用“this”。在方法體中，`this`表達式計算結果為調用該方法的實例。或者，更確切地説，由於方法是分為兩個步驟進行訪問和調用的，因此它會引用調用方法的對象。

> That makes our job harder. Peep at:

這使得我們的工作更加困難。請看：

```javascript
class Egotist {
  speak() {
    print this;
  }
}

var method = Egotist().speak;
method();
```

> On the second-to-last line, we grab a reference to the `speak()` method off an instance of the class. That returns a function, and that function needs to remember the instance it was pulled off of so that *later*, on the last line, it can still find it when the function is called.

在倒數第二行，我們從該類的一個實例中獲取到了指向`speak()` 的引用。這個操作會返回一個函數，並且該函數需要記住它來自哪個實例，這樣稍後在最後一行，當函數被調用時，它仍然可用找到對應實例。

> We need to take `this` at the point that the method is accessed and attach it to the function somehow so that it stays around as long as we need it to. Hmm . . . a way to store some extra data that hangs around a function, eh? That sounds an awful lot like a *closure*, doesn’t it?

我們需要在方法被訪問時獲取到`this`，並將其附到函數上，這樣當我們需要的時候它就一直存在。嗯…一種存儲函數週圍的額外數據的方法，嗯？聽起來很像一個閉包，不是嗎？

> If we defined `this` as a sort of hidden variable in an environment that surrounds the function returned when looking up a method, then uses of `this` in the body would be able to find it later. LoxFunction already has the ability to hold on to a surrounding environment, so we have the machinery we need.

如果我們把`this`定義為在查找方法時返回的函數外圍環境中的一個隱藏變量，那麼稍後在方法主體中使用`this`時就可以找到它了。LoxFunction已經具備了保持外圍環境的能力，所以我們已經有了需要的機制。

> Let’s walk through an example to see how it works:

我們通過一個例子來看看它是如何工作的：

```javascript
class Cake {
  taste() {
    var adjective = "delicious";
    print "The " + this.flavor + " cake is " + adjective + "!";
  }
}

var cake = Cake();
cake.flavor = "German chocolate";
cake.taste(); // Prints "The German chocolate cake is delicious!".
```

> When we first evaluate the class definition, we create a LoxFunction for `taste()`. Its closure is the environment surrounding the class, in this case the global one. So the LoxFunction we store in the class’s method map looks like so:

當我們第一次執行類定義時，我們為`taste()`創建了一個LoxFunction。它的閉包是類外圍的環境，在這個例子中就是全局環境。所以我們在類的方法map中保存的LoxFunction看起來像是這樣的：

![The initial closure for the method.](12.類/closure.png)

> When we evaluate the `cake.taste` get expression, we create a new environment that binds `this` to the object the method is accessed from (here, `cake`). Then we make a *new* LoxFunction with the same code as the original one but using that new environment as its closure.

當我們執行`cake.taste`這個get表達式時，我們會創建一個新的環境，其中將`this`綁定到了訪問該方法的對象（這裏是`cake`）。然後我們創建一個*新*的LoxFunction，它的代碼與原始的代碼相同，但是使用新環境作為其閉包。

![The new closure that binds 'this'.](12.類/bound-method.png)

> This is the LoxFunction that gets returned when evaluating the get expression for the method name. When that function is later called by a `()` expression, we create an environment for the method body as usual.

這個是在執行方法名的get表達式時返回的LoxFunction。當這個函數稍後被一個`()`表達式調用時，我們像往常一樣為方法主體創建一個環境。

![Calling the bound method and creating a new environment for the method body.](12.類/call.png)

> The parent of the body environment is the environment we created earlier to bind `this` to the current object. Thus any use of `this` inside the body successfully resolves to that instance.

主體環境的父環境，也就是我們先前創建並在其中將`this`綁定到當前對象的那個環境。因此，在函數主體內使用`this`都可以成功解析到那個實例。

> Reusing our environment code for implementing `this` also takes care of interesting cases where methods and functions interact, like:

重用環境代碼來實現`this`時，也需要注意方法和函數交互的情況，比如：

```javascript
class Thing {
  getCallback() {
    fun localFunction() {
      print this;
    }

    return localFunction;
  }
}

var callback = Thing().getCallback();
callback();
```

> In, say, JavaScript, it’s common to return a callback from inside a method. That callback may want to hang on to and retain access to the original object—the `this` value—that the method was associated with. Our existing support for closures and environment chains should do all this correctly.

例如，在JavaScript中，在一個方法中返回一個回調函數是很常見的。這個回調函數可能希望保留對方法所關聯的原對象（`this`值）的訪問。我們現有的對閉包和環境鏈的支持應該可以正確地做到這一點。

> Let’s code it up. The first step is adding new syntax for `this`.

讓我們把它寫出來。第一步是為`this`添加新的語法。

*<u>tool/GenerateAst.java，在 main()方法中添加：</u>*

```java
      "Set      : Expr object, Token name, Expr value",
      // 新增部分開始
      "This     : Token keyword",
      // 新增部分結束
      "Unary    : Token operator, Expr right",
```

> Parsing is simple since it’s a single token which our lexer already recognizes as a reserved word.

解析很簡單，因為它是已經被詞法解析器當作關鍵字識別出來的單個詞法標記。

*<u>lox/Parser.java，在 primary()方法中添加：</u>*

```java
      return new Expr.Literal(previous().literal);
    }
    // 新增部分開始
    if (match(THIS)) return new Expr.This(previous());
    // 新增部分結束
    if (match(IDENTIFIER)) {
```

> You can start to see how `this` works like a variable when we get to the resolver.

當進入分析器後，就可以看到 `this` 是如何像變量一樣工作的。

*<u>lox/Resolver.java，在 visitSetExpr()方法後添加：</u>*

```java
  @Override
  public Void visitThisExpr(Expr.This expr) {
    resolveLocal(expr, expr.keyword);
    return null;
  }
```

> We resolve it exactly like any other local variable using “this” as the name for the “variable”. Of course, that’s not going to work right now, because “this” *isn’t* declared in any scope. Let’s fix that over in `visitClassStmt()`.

我們使用`this`作為“變量”的名稱，並像其它局部變量一樣對其分析。當然，現在這是行不通的，因為“this”沒有在任何作用域進行聲明。我們在`visitClassStmt()`方法中解決這個問題。

*<u>lox/Resolver.java，在visitClassStmt()方法中添加：</u>*

```java
    define(stmt.name);
    // 新增部分開始
    beginScope();
    scopes.peek().put("this", true);
    // 新增部分結束
    for (Stmt.Function method : stmt.methods) {
```

> Before we step in and start resolving the method bodies, we push a new scope and define “this” in it as if it were a variable. Then, when we’re done, we discard that surrounding scope.

在我們開始分析方法體之前，我們推入一個新的作用域，並在其中像定義變量一樣定義“this”。然後，當我們完成後，會丟棄這個外圍作用域。

*<u>lox/Resolver.java，在 visitClassStmt()方法中添加：</u>*

```java
    }
    // 新增部分開始
    endScope();
    // 新增部分結束
    return null;
```

> Now, whenever a `this` expression is encountered (at least inside a method) it will resolve to a “local variable” defined in an implicit scope just outside of the block for the method body.

現在，只要遇到`this`表達式（至少是在方法內部），它就會解析為一個“局部變量”，該變量定義在方法體塊之外的隱含作用域中。

> **The resolver has a new *scope* for `this`, so the interpreter needs to create a corresponding *environment* for it. Remember, we always have to keep the resolver’s scope chains and the interpreter’s linked environments in sync with each other. At runtime, we create the environment after we find the method on the instance. We replace the previous line of code that simply returned the meth**od’s LoxFunction with this:

分析器對`this`有一個新的*作用域*，所以解釋器需要為它創建一個對應的*環境*。記住，我們必須始終保持分析器的作用域鏈與解釋器的鏈式環境保持同步。在運行時，我們在找到實例上的方法後創建環境。我們把之前那行直接返回方法對應LoxFunction的代碼替換如下：

*<u>lox/LoxInstance.java，在 get()方法中替換一行：</u>*

```java
    LoxFunction method = klass.findMethod(name.lexeme);
    // 替換部分開始
    if (method != null) return method.bind(this);
    // 替換部分結束
    throw new RuntimeError(name, 
        "Undefined property '" + name.lexeme + "'.");
```

> Note the new call to `bind()`. That looks like so:

注意這裏對`bind()`的新調用。該方法看起來是這樣的：

*<u>lox/LoxFunction.java，在 LoxFunction()方法後添加：</u>*

```java
  LoxFunction bind(LoxInstance instance) {
    Environment environment = new Environment(closure);
    environment.define("this", instance);
    return new LoxFunction(declaration, environment);
  }
```

> There isn’t much to it. We create a new environment nestled inside the method’s original closure. Sort of a closure-within-a-closure. When the method is called, that will become the parent of the method body’s environment.

這沒什麼好説的。我們基於方法的原始閉包創建了一個新的環境。就像是閉包內的閉包。當方法被調用時，它將變成方法體對應環境的父環境。

> We declare “this” as a variable in that environment and bind it to the given instance, the instance that the method is being accessed from. *Et voilà*, the returned LoxFunction now carries around its own little persistent world where “this” is bound to the object.

我們將`this`聲明為該環境中的一個變量，並將其綁定到給定的實例（即方法被訪問時的實例）上。就是這樣，現在返回的LoxFunction帶着它自己的小持久化世界，其中的“this”被綁定到對象上。

> The remaining task is interpreting those `this` expressions. Similar to the resolver, it is the same as interpreting a variable expression.

剩下的任務就是解釋那些`this`表達式。與分析器類似，與解釋變量表達式是一樣的。

*<u>lox/Interpreter.java，在 visitSetExpr()方法後添加：</u>*

```java
  @Override
  public Object visitThisExpr(Expr.This expr) {
    return lookUpVariable(expr.keyword, expr);
  }
```

> Go ahead and give it a try using that cake example from earlier. With less than twenty lines of code, our interpreter handles `this` inside methods even in all of the weird ways it can interact with nested classes, functions inside methods, handles to methods, etc.

來吧，用前面那個蛋糕的例子試一試。通過添加不到20行代碼，我們的解釋器就能處理方法內部的`this`，甚至能以各種奇怪的方式與嵌套類、方法內部的函數、方法句柄等進行交互。

> ### 12 . 6 . 1 Invalid uses of this

### 12.6.1 this的無效使用

> Wait a minute. What happens if you try to use `this` *outside* of a method? What about:

等一下，如果你嘗試在方法之外使用`this`會怎麼樣？比如：

```java
print this;
```

> Or:

或者：

```javascript
fun notAMethod() {
  print this;
}
```

> There is no instance for `this` to point to if you’re not in a method. We could give it some default value like `nil` or make it a runtime error, but the user has clearly made a mistake. The sooner they find and fix that mistake, the happier they’ll be.

如果你不在一個方法中，就沒有可供`this`指向的實例。我們可以給它一些默認值如`nil`或者拋出一個運行時錯誤，但是用户顯然犯了一個錯誤。他們越早發現並糾正這個錯誤，就會越高興。

> Our resolution pass is a fine place to detect this error statically. It already detects `return` statements outside of functions. We’ll do something similar for `this`. In the vein of our existing FunctionType enum, we define a new ClassType one.

我們的分析過程是一個靜態檢測這個錯誤的好地方。它已經檢測了函數之外的`return`語句。我們可以針對`this`做一些類似的事情。在我們現有的FunctionType枚舉的基礎上，我們定義一個新的ClassType枚舉。

*<u>lox/Resolver.java，在 FunctionType枚舉後添加：</u>*

```java
  }
  // 新增部分開始
  private enum ClassType {
    NONE,
    CLASS
  }

  private ClassType currentClass = ClassType.NONE;
  // 新增部分結束
  void resolve(List<Stmt> statements) {
```

> Yes, it could be a Boolean. When we get to inheritance, it will get a third value, hence the enum right now. We also add a corresponding field, `currentClass`. Its value tells us if we are currently inside a class declaration while traversing the syntax tree. It starts out `NONE` which means we aren’t in one.

是的，它可以是一個布爾值。當我們談到繼承時，它會擴展第三個值，因此使用了枚舉。我們還添加了一個相應的字段`currentClass`。它的值告訴我們，在遍歷語法樹時，我們目前是否在一個類聲明中。它一開始是`NONE`，意味着我們不在類中。

> When we begin to resolve a class declaration, we change that.

當我們開始分析一個類聲明時，我們會改變它。

*<u>lox/Resolver.java，在 visitClassStmt()方法中添加：</u>*

```java
  public Void visitClassStmt(Stmt.Class stmt) {
    // 新增部分開始
    ClassType enclosingClass = currentClass;
    currentClass = ClassType.CLASS;
    // 新增部分結束
    declare(stmt.name);
```

> As with `currentFunction`, we store the previous value of the field in a local variable. This lets us piggyback onto the JVM to keep a stack of `currentClass` values. That way we don’t lose track of the previous value if one class nests inside another.

與`currentFunction`一樣，我們將字段的前一個值存儲在一個局部變量中。這樣我們可以在JVM中保持一個`currentClass`的棧。如果一個類嵌套在另一個類中，我們就不會丟失對前一個值的跟蹤。

> Once the methods have been resolved, we “pop” that stack by restoring the old value.

一旦這麼方法完成了分析，我們通過恢復舊值來“彈出”堆棧。

*<u>lox/Resolver.java,在 visitClassStmt()方法中添加：</u>*

```java
    endScope();
    // 新增部分開始
    currentClass = enclosingClass;
    // 新增部分結束
    return null;
```

> When we resolve a `this` expression, the `currentClass` field gives us the bit of data we need to report an error if the expression doesn’t occur nestled inside a method body.

當我們解析`this`表達式時，如果表達式沒有出現在一個方法體內，`currentClass`就為我們提供了報告錯誤所需的數據。

*<u>lox/Resolver.java，在 visitThisExpr()方法中添加：</u>*

```java
  public Void visitThisExpr(Expr.This expr) {
    // 新增部分開始
    if (currentClass == ClassType.NONE) {
      Lox.error(expr.keyword,
          "Can't use 'this' outside of a class.");
      return null;
    }
    // 新增部分結束
    resolveLocal(expr, expr.keyword);
```

> That should help users use `this` correctly, and it saves us from having to handle misuse at runtime in the interpreter.

這應該能幫助用户正確地使用`this`，並且它使我們不必在解釋器運行時中處理這個誤用問題。

> ## 12 . 7 Constructors and Initializers

## 12.7 構造函數和初始化

> We can do almost everything with classes now, and as we near the end of the chapter we find ourselves strangely focused on a beginning. Methods and fields let us encapsulate state and behavior together so that an object always *stays* in a valid configuration. But how do we ensure a brand new object *starts* in a good state?

我們現在幾乎可以用類來做任何事情，而當我們接近本章結尾時，卻發現自己奇怪地專注於開頭。方法和字段讓我們把狀態和行為封裝在一起，這樣一個對象就能始終保持在有效的配置狀態。但我們如何確保一個全新的對象是以良好的狀態開始的？

> For that, we need constructors. I find them one of the trickiest parts of a language to design, and if you peer closely at most other languages, you’ll see cracks around object construction where the seams of the design don’t quite fit together perfectly. Maybe there’s something intrinsically messy about the moment of birth.

為此，我們需要構造函數。我發現它們是語言設計中最棘手的部分之一，如果你仔細觀察大多數其它語言，就會發現圍繞着對象構造的缺陷，設計的接縫並不完全吻合[^8]。也許在一開始就存在本質上的混亂。

> “Constructing” an object is actually a pair of operations:

“構造”一個對象實際上是一對操作：

1. > The runtime *allocates* the memory required for a fresh instance. In most languages, this operation is at a fundamental level beneath what user code is able to access.

   運行時為一個新的實例*分配*所需的內存。在多數語言中，這個操作是在用户代碼可以訪問的層面之下的基礎層完成的[^9]。

2. > Then, a user-provided chunk of code is called which *initializes* the unformed object.

   然後，用户提供的一大塊代碼被調用，以初始化未成形的對象。

> The latter is what we tend to think of when we hear “constructor”, but the language itself has usually done some groundwork for us before we get to that point. In fact, our Lox interpreter already has that covered when it creates a new LoxInstance object.

當我們聽到“構造函數”時，我們往往會想到後者，但語言本身在此之前通常已經為我們做了一些基礎工作。事實上，我們的Lox解釋器在創建一個新的LoxInstance對象時已經涵蓋了這一點。

> We’ll do the remaining part—user-defined initialization—now. Languages have a variety of notations for the chunk of code that sets up a new object for a class. C++, Java, and C# use a method whose name matches the class name. Ruby and Python call it `init()`. The latter is nice and short, so we’ll do that.

我們現在要做的是剩下的部分——用户自定義的初始化。對於為類建立新對象的這塊代碼，不同的語言有不同的説法。C++、Java和C#使用一個名字與類名相匹配的方法。Ruby 和 Python 稱之為` init()`。後者又好又簡短，所以我們採用它。

> In LoxClass’s implementation of LoxCallable, we add a few more lines.

在LoxClass的LoxCallable實現中，我們再增加幾行。

*<u>lox/LoxClass.java,在 call()方法中添加：</u>*

```java
                     List<Object> arguments) {
    LoxInstance instance = new LoxInstance(this);
    // 新增部分開始
    LoxFunction initializer = findMethod("init");
    if (initializer != null) {
      initializer.bind(instance).call(interpreter, arguments);
    }
    // 新增部分結束
    return instance;
```

> When a class is called, after the LoxInstance is created, we look for an “init” method. If we find one, we immediately bind and invoke it just like a normal method call. The argument list is forwarded along.

當一個類被調用時，在LoxInstance被創建後，我們會尋找一個 "init "方法。如果我們找到了，我們就會立即綁定並調用它，就像普通的方法調用一樣。參數列表直接透傳。

> That argument list means we also need to tweak how a class declares its arity.

這個參數列表意味着我們也需要調整類聲明其元數的方式。

```
  public int arity() {
```

*<u>lox/LoxClass.java，在 arity()方法中替換一行：</u>*

```java
  public int arity() {
    // 替換部分開始
    LoxFunction initializer = findMethod("init");
    if (initializer == null) return 0;
    return initializer.arity();
    // 替換部分結束
  }
```

> If there is an initializer, that method’s arity determines how many arguments you must pass when you call the class itself. We don’t *require* a class to define an initializer, though, as a convenience. If you don’t have an initializer, the arity is still zero.

如果有初始化方法，該方法的元數就決定了在調用類本身的時候需要傳入多少個參數。但是，為了方便起見，我們並不要求類定義初始化方法。如果你沒有初始化方法，元數仍然是0。

> That’s basically it. Since we bind the `init()` method before we call it, it has access to `this` inside its body. That, along with the arguments passed to the class, are all you need to be able to set up the new instance however you desire.

基本上就是這樣了。因為我們在調用`init()`方法之前已經將其綁定，所以它可以在方法體內訪問`this`。這樣，連同傳遞給類的參數，你就可以按照自己的意願設置新實例了。

> ### 12 . 7 . 1 Invoking init() directly

### 12.7.1 直接執行init()

> As usual, exploring this new semantic territory rustles up a few weird creatures. Consider:

像往常一樣，探索這一新的語義領域會催生出一些奇怪的事物。考慮一下：

```javascript
class Foo {
  init() {
    print this;
  }
}

var foo = Foo();
print foo.init();
```

> Can you “re-initialize” an object by directly calling its `init()` method? If you do, what does it return? A reasonable answer would be `nil` since that’s what it appears the body returns.

你能否通過直接調用對象的`init()`方法對其進行“重新初始化”？如果可以，它的返回值是什麼？一個合理的答案應該是`nil`，因為這是方法主體返回的內容。

> However—and I generally dislike compromising to satisfy the implementation—it will make clox’s implementation of constructors much easier if we say that `init()` methods always return `this`, even when directly called. In order to keep jlox compatible with that, we add a little special case code in LoxFunction.

然而，我通常不喜歡為滿足實現而妥協[^10]，如果我們讓`init()`方法總是返回`this`（即使是被直接調用時），它會使clox中的構造函數實現更加簡單。為了保持jlox與之兼容，我們在LoxFunction中添加了一些針對特殊情況的代碼。

*<u>lox/LoxFunction.java，在 call()方法中添加：</u>*

```java
      return returnValue.value;
    }
    // 新增部分開始
    if (isInitializer) return closure.getAt(0, "this");
    // 新增部分結束
    return null;
```

> If the function is an initializer, we override the actual return value and forcibly return `this`. That relies on a new `isInitializer` field.

如果該函數是一個初始化方法，我們會覆蓋實際的返回值並強行返回`this`。這個操作依賴於一個新的`isInitializer`字段。

*<u>lox/LoxFunction.java，在 LoxFunction類中，替換一行：</u>*

```java
  private final Environment closure;
  // 替換部分開始
  private final boolean isInitializer;

  LoxFunction(Stmt.Function declaration, Environment closure, boolean isInitializer) {
    this.isInitializer = isInitializer;
    // 替換部分結束
    this.closure = closure;
    this.declaration = declaration;
```

> We can’t simply see if the name of the LoxFunction is “init” because the user could have defined a *function* with that name. In that case, there *is* no `this` to return. To avoid *that* weird edge case, we’ll directly store whether the LoxFunction represents an initializer method. That means we need to go back and fix the few places where we create LoxFunctions.

我們不能簡單地檢查LoxFunction的名字是否為“init”，因為用户可能已經定義了一個同名的*函數*。在這種情況下，是沒有`this`可供返回的。為了避免這種奇怪的邊緣情況，我們將直接存儲LoxFunction是否表示一個初始化方法。這意味着我們需要回頭修正我們創建LoxFunctions的幾個地方。

*<u>lox/Interpreter.java，在 visitFunctionStmt()方法中，替換一行：</u>*

```java
  public Void visitFunctionStmt(Stmt.Function stmt) {
    // 替換部分開始
    LoxFunction function = new LoxFunction(stmt, environment, false);
    // 替換部分結束                                       
    environment.define(stmt.name.lexeme, function);
```

> For actual function declarations, `isInitializer` is always false. For methods, we check the name.

對於實際的函數聲明， `isInitializer`取值總是false。對於方法來説，我們檢查其名稱。

*<u>lox/Interpreter.java，在 visitClassStmt()方法中，替換一行：</u>*

```java
    for (Stmt.Function method : stmt.methods) {
      // 替換部分開始
      LoxFunction function = new LoxFunction(method, environment,
          method.name.lexeme.equals("init"));
      // 替換部分結束    
      methods.put(method.name.lexeme, function);
```

> And then in `bind()` where we create the closure that binds `this` to a method, we pass along the original method’s value.

然後在`bind()`方法，在創建閉包並將`this`綁定到新方法時，我們將原始方法的值傳遞給新方法。

*<u>lox/LoxFunction.java，在 bind()方法中，替換一行：</u>*

```java
    environment.define("this", instance);
    // 替換部分開始
    return new LoxFunction(declaration, environment,
                           isInitializer);
    // 替換部分結束                       
  }
```

> ### 12 . 7 . 2 Returning from init()

### 12.7.2 從init()返回

> We aren’t out of the woods yet. We’ve been assuming that a user-written initializer doesn’t explicitly return a value because most constructors don’t. What should happen if a user tries:

我們還沒有走出困境。我們一直假設用户編寫的初始化方法不會顯式地返回一個值，因為大多數構造函數都不會。如果用户嘗試這樣做會發生什麼：

```java
class Foo {
  init() {
    return "something else";
  }
}
```

> It’s definitely not going to do what they want, so we may as well make it a static error. Back in the resolver, we add another case to FunctionType.

這肯定不會按照用户的期望執行，所以我們不妨把它作為一種靜態錯誤。回到分析器中，我們為FunctionType添加另一種情況。

*<u>lox/Resolver.java，在 FunctionType枚舉中添加：</u>*

```java
    FUNCTION,
    // 新增部分開始
    INITIALIZER,
    // 新增部分結束
    METHOD
```

> We use the visited method’s name to determine if we’re resolving an initializer or not.

我們通過被訪問方法的名稱來確定我們是否在分析一個初始化方法。

*<u>lox/Resolver.java，在 visitClassStmt()方法中添加：</u>*

```java
      FunctionType declaration = FunctionType.METHOD;
      // 新增部分開始
      if (method.name.lexeme.equals("init")) {
        declaration = FunctionType.INITIALIZER;
      }
      // 新增部分結束
      resolveFunction(method, declaration); 
```

> When we later traverse into a `return` statement, we check that field and make it an error to return a value from inside an `init()` method.

當我們稍後遍歷`return`語句時，我們會檢查該字段，如果從`init()`方法內部返回一個值時就拋出一個錯誤。

*<u>lox/Resolver.java，在 visitReturnStmt()方法中添加：</u>*

```java
    if (stmt.value != null) {
      // 新增部分開始
      if (currentFunction == FunctionType.INITIALIZER) {
        Lox.error(stmt.keyword,
            "Can't return a value from an initializer.");
      }
      // 新增部分結束
      resolve(stmt.value);
```

> We’re *still* not done. We statically disallow returning a *value* from an initializer, but you can still use an empty early `return`.

我們*仍然*沒有結束。我們靜態地禁止了從初始化方法返回一個值，但是你仍然可用使用一個空的`return`。

```java
class Foo {
  init() {
    return;
  }
}
```

> That is actually kind of useful sometimes, so we don’t want to disallow it entirely. Instead, it should return `this` instead of `nil`. That’s an easy fix over in LoxFunction.

有時候這實際上是有用的，所以我們不想完全禁止它。相對地，它應該返回`this`而不是`nil`。這在LoxFunction中很容易解決。

*<u>lox/LoxFunction.java，在 call()方法中添加：</u>*

```java
    } catch (Return returnValue) {
      // 新增部分開始
      if (isInitializer) return closure.getAt(0, "this");
      // 新增部分結束
      return returnValue.value;
```

> If we’re in an initializer and execute a `return` statement, instead of returning the value (which will always be `nil`), we again return `this`.

如果我們在一個初始化方法中執行`return`語句時，我們仍然返回`this`，而不是返回值（該值始終是`nil`）。

> Phew! That was a whole list of tasks but our reward is that our little interpreter has grown an entire programming paradigm. Classes, methods, fields, `this`, and constructors. Our baby language is looking awfully grown-up.

籲！這是一大堆任務，但是我們的收穫是，我們的小解釋器已經成長為一個完整的編程範式。類、方法、字段、`this`以及構造函數，我們的語言看起來已經非常成熟了。



[^1]: 但是，如果你真的討厭類，也可以跳過這兩章。它們與本書的其它部分是相當孤立的。就我個人而言，我覺得多瞭解自己不喜歡的對象是好事。有些事情乍一看很簡單，但當我近距離觀看時，細節出現了，我也獲得了一個更細緻入微的視角。
[^2]: Multimethods是你最不可能熟悉的方法。我很想多談論一下它們——我曾經圍繞它們設計了一個[業餘語言](http://magpie-lang.org/)，它們特別棒——但是我只能裝下這麼多頁面了。如果你想了解更多，可以看看[CLOS](https://en.wikipedia.org/wiki/Common_Lisp_Object_System) (Common Lisp中的對象系統), [Dylan](https://opendylan.org/), [Julia](https://julialang.org/), 或 [Raku](https://docs.raku.org/language/functions#Multi-dispatch)。

[^3]: 在Smalltalk中，甚至連類也是通過現有對象（通常是所需的超類）的方法來創建的。有點像是一直向下龜縮。最後，它會在一些神奇的類上觸底，比如Object和Metaclass，它們是運行時憑空創造出來的。
[^4]: 允許類之外的代碼直接修改對象的字段，這違背了面向對象的原則，即類封裝狀態。有些語言採取了更有原則的立場。在SmallTalk中，字段實際上是使用簡單的標識符訪問的，這些標識符是類方法作用域內的變量。Ruby使用@後跟名字來訪問對象中的字段。這種語法只有在方法中才有意義，並且總是訪問當前對象的狀態。不管怎樣，Lox對OOP的信仰並不是那麼虔誠。
[^5]: 它的經典用途之一就是回調。通常，你想要傳遞一個回調函數，其主體只是調用某個對象上的一個方法。既然能夠找到該方法並直接傳遞它，就省去了手動聲明一個函數對其進行包裝的麻煩工作。比較一下下面兩段代碼：

```java
// 方式1
fun callback(a, b, c) {
  object.method(a, b, c);
}

takeCallback(callback);

// 方式2
takeCallback(object.method);
```

[^6]: 現在將函數類型保存到一個局部變量中是沒有意義的，但我們稍後會擴展這段代碼，到時它就有意義了。
[^7]: 首先尋找字段，意味着字段會遮蔽方法，這是一個微妙但重要的語義點。
[^8]: 舉幾個例子：在Java中，儘管final字段必須被初始化，但仍有可能在被初始化之前被讀取。異常（一個龐大而複雜的特性）被添加到C++中主要是作為一種從構造函數發出錯誤的方式。
[^9]: C++中的 "[placement new](https://en.wikipedia.org/wiki/Placement_syntax) "是一個罕見的例子，在這種情況下，分配的內存被暴露出來供程序員使用。
[^10]: 也許“不喜歡”這個説法太過激了。讓語言實現的約束和資源影響語言的設計是合理的。一天只有這麼多時間，如果在這裏或那裏偷工減料可以讓你在更短的時間內為用户提供更多的功能，這可能會大大提高用户的幸福感和工作效率。訣竅在於，要弄清楚哪些彎路不會導致你的用户和未來的自己不會咒罵你的短視行為

------

> ## CHALLENGES

## 習題

1. > We have methods on instances, but there is no way to define “static” methods that can be called directly on the class object itself. Add support for them. Use a `class` keyword preceding the method to indicate a static method that hangs off the class object.

   我們有實例上的方法，但是沒有辦法定義可以直接在類對象上調用的“靜態”方法。添加對它們的支持，在方法之前使用`class`關鍵字指示該方法是一個掛載在類對象上的靜態方法。

   ```java
   class Math {
     class square(n) {
       return n * n;
     }
   }
   
   print Math.square(3); // Prints "9".
   ```

   > You can solve this however you like, but the “[metaclasses](https://en.wikipedia.org/wiki/Metaclass)” used by Smalltalk and Ruby are a particularly elegant approach. *Hint: Make LoxClass extend LoxInstance and go from there.*

   你可以用你喜歡的方式解決這問題，但是Smalltalk和Ruby使用的“[metaclasses](https://en.wikipedia.org/wiki/Metaclass)” 是一種特別優雅的方法。*提示：讓LoxClass繼承LoxInstance，然後開始實現。*

   

2. > Most modern languages support “getters” and “setters”—members on a class that look like field reads and writes but that actually execute user-defined code. Extend Lox to support getter methods. These are declared without a parameter list. The body of the getter is executed when a property with that name is accessed.

   大多數現代語言都支持“getters”和“setters”——類中的成員，看起來像是字段的讀寫，但實際上執行的用户自定義的代碼。擴展Lox以支持getter方法。這些方法在聲明時沒有參數列表。當訪問具有該名稱的屬性時，會執行getter的主體。

   ```java
   class Circle {
     init(radius) {
       this.radius = radius;
     }
   
     area {
       return 3.141592653 * this.radius * this.radius;
     }
   }
   
   var circle = Circle(4);
   print circle.area; // Prints roughly "50.2655".
   ```

3. > Python and JavaScript allow you to freely access an object’s fields from outside of its own methods. Ruby and Smalltalk encapsulate instance state. Only methods on the class can access the raw fields, and it is up to the class to decide which state is exposed. Most statically typed languages offer modifiers like `private` and `public` to control which parts of a class are externally accessible on a per-member basis.
   >
   > What are the trade-offs between these approaches and why might a language prefer one or the other?

   Python和JavaScript允許你從對象自身的方法之外的地方自由訪問對象的字段。Ruby和Smalltalk封裝了實例狀態。只有類上的方法可以訪問原始字段，並且由類來決定哪些狀態被暴露。大多數靜態類型的語言都提供了像`private`和`public`這樣的修飾符，以便按成員維度控制類的哪些部分可以被外部訪問。

   這些方式之間的權衡是什麼？為什麼一門語言可能會更偏愛某一種方法？

------

> ## DESIGN NOTE: PROTOTYPES AND POWER

## 設計筆記：原型與功率

> In this chapter, we introduced two new runtime entities, LoxClass and LoxInstance. The former is where behavior for objects lives, and the latter is for state. What if you could define methods right on a single object, inside LoxInstance? In that case, we wouldn’t need LoxClass at all. LoxInstance would be a complete package for defining the behavior and state of an object.
>
> We’d still want some way, without classes, to reuse behavior across multiple instances. We could let a LoxInstance [*delegate*](https://en.wikipedia.org/wiki/Prototype-based_programming#Delegation) directly to another LoxInstance to reuse its fields and methods, sort of like inheritance.
>
> Users would model their program as a constellation of objects, some of which delegate to each other to reflect commonality. Objects used as delegates represent “canonical” or “prototypical” objects that others refine. The result is a simpler runtime with only a single internal construct, LoxInstance.
>
> That’s where the name **[prototypes](https://en.wikipedia.org/wiki/Prototype-based_programming)** comes from for this paradigm. It was invented by David Ungar and Randall Smith in a language called [Self](http://www.selflanguage.org/). They came up with it by starting with Smalltalk and following the above mental exercise to see how much they could pare it down.
>
> Prototypes were an academic curiosity for a long time, a fascinating one that generated interesting research but didn’t make a dent in the larger world of programming. That is, until Brendan Eich crammed prototypes into JavaScript, which then promptly took over the world. Many (many) words have been written about prototypes in JavaScript. Whether that shows that prototypes are brilliant or confusing—or both!—is an open question.
>
> Including [more than a handful](http://gameprogrammingpatterns.com/prototype.html) by yours truly.
>
> I won’t get into whether or not I think prototypes are a good idea for a language. I’ve made languages that are [prototypal](http://finch.stuffwithstuff.com/) and [class-based](http://wren.io/), and my opinions of both are complex. What I want to discuss is the role of *simplicity* in a language.
>
> Prototypes are simpler than classes—less code for the language implementer to write, and fewer concepts for the user to learn and understand. Does that make them better? We language nerds have a tendency to fetishize minimalism. Personally, I think simplicity is only part of the equation. What we really want to give the user is *power*, which I define as:
>
> ```
> power = breadth × ease ÷ complexity
> ```
>
> None of these are precise numeric measures. I’m using math as analogy here, not actual quantification.
>
> - **Breadth** is the range of different things the language lets you express. C has a lot of breadth—it’s been used for everything from operating systems to user applications to games. Domain-specific languages like AppleScript and Matlab have less breadth.
> - **Ease** is how little effort it takes to make the language do what you want. “Usability” might be another term, though it carries more baggage than I want to bring in. “Higher-level” languages tend to have more ease than “lower-level” ones. Most languages have a “grain” to them where some things feel easier to express than others.
> - **Complexity** is how big the language (including its runtime, core libraries, tools, ecosystem, etc.) is. People talk about how many pages are in a language’s spec, or how many keywords it has. It’s how much the user has to load into their wetware before they can be productive in the system. It is the antonym of simplicity.
>
> Reducing complexity *does* increase power. The smaller the denominator, the larger the resulting value, so our intuition that simplicity is good is valid. However, when reducing complexity, we must take care not to sacrifice breadth or ease in the process, or the total power may go down. Java would be a strictly *simpler* language if it removed strings, but it probably wouldn’t handle text manipulation tasks well, nor would it be as easy to get things done.
>
> The art, then, is finding *accidental* complexity that can be omitted—language features and interactions that don’t carry their weight by increasing the breadth or ease of using the language.
>
> If users want to express their program in terms of categories of objects, then baking classes into the language increases the ease of doing that, hopefully by a large enough margin to pay for the added complexity. But if that isn’t how users are using your language, then by all means leave classes out.

在本章中，我們引入了兩個新的運行時實體，LoxClass和LoxInstance。前者是對象的行為所在，後者則是狀態所在。如果你可以在LoxInstance的單個對象中定義方法，會怎麼樣？這種情況下，我們根本就不需要LoxClass。LoxInstance將是一個用於定義對象行為和狀態的完整包。

我們仍然需要一些方法，在沒有類的情況下，可以跨多個實例重用對象行為。我們可以讓一個LoxInstance直接[委託](https://en.wikipedia.org/wiki/Prototype-based_programming#Delegation)給另一個LoxInstance來重用它的字段和方法，有點像繼承。

用户可以將他們的程序建模為一組對象，其中一些對象相互委託以反映共性。用作委託的對象代表“典型”或“原型”對象，會被其它對象完善。結果就是會有一個更簡單的運行時，只有一個內部結構LoxInstance。

這就是這種範式的名稱“[原型](https://en.wikipedia.org/wiki/Prototype-based_programming)”的由來。它是由David Ungar和Randall Smith在一種叫做[Self](http://www.selflanguage.org/)的語言中發明的。他們從Smalltalk開始，按照上面的練習，看他們能把它縮減到什麼程度，從而想到了這個方法。

長期以來，原型一直是學術上的探索，它是一個引人入勝的東西，也產生了有趣的研究，但是並沒有在更大的編程世界中產生影響。直到Brendan Eich把原型塞進JavaScript，然後迅速風靡世界。關於JavaScript中的原型，人們已經寫了很多（許多）文字。這是否能夠表明原型是出色的還是令人困惑的，或者兼而有之？這是一個開放的問題。

我不會去討論原型對於一門語言來説是不是一個好主意。基於原型和基於類的語言我都做過，我對兩者的看法很複雜。我想討論的是*簡單性*在一門語言中的作用。

原型比類更簡單——語言實現者要編寫的代碼更少，語言用户要學習和理解的概念更少。這是否意味着它讓語言變得更好呢？我們這些語言書呆子有一種迷戀極簡主義的傾向。就我個人而言，我認為簡單性只是一部分。我們真正想給用户的是功率，我將其定義為：

```
power = breadth × ease ÷ complexity
功率 = 廣度 × 易用性 ÷ 複雜性
```

這些都不是精確的數字度量。我這裏用數學作比喻，而不是實際的量化。

* **廣度**是語言可以表達的不同事物的範圍。C語言具有很大的廣度——從操作系統到用户應用程序再到遊戲，它被廣泛使用。像AppleScript和Matlab這樣的特定領域語言的廣度相對較小。
* 易用性是指用户付出多少努力就可以用語言做想做的事。“可用性Usability”是另一個概念，它包含的內容比我想要表達的更多。“高級”語言往往比“低級”語言更容易使用。大多數語言都有一個核心，對它們來説，有些東西比其它的更容易表達。
* 複雜性是指語言的規模（包括其運行時、核心庫、工具、生態等）有多大。人們談論一種語言的規範有多少頁，或者它有多少個關鍵詞。這是指用户在使用系統之前，必須在先學習多少東西，才能產生效益。它是簡單性的反義詞。

降低複雜性確實可以提高功率，分母越小，得到的值就越大，所以我們直覺認為“簡單的是好的”是對的。然而，在降低複雜性時，我們必須注意不要在這個過程中犧牲廣度或易用性，否則總功率可能會下降。如果去掉字符串，Java將變成一種嚴格意義上的簡單語言，但它可能無法很好地處理文本操作任務，也不會那麼容易完成事情。

因此，關鍵就在於找到可以省略的意外複雜性，也就是哪些沒有通過增加語言廣度或語言易用性來體現其重要性的語言特性與交互。

如果用户想用對象的類別來表達他們的程序，那麼在語言中加入類就能提高這類操作的便利性，希望能有足夠大的提升幅度來彌補所增加的複雜性。但如果這不是用户使用您的語言的方式，那麼無論如何都不要使用類。
